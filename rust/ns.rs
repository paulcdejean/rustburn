// Add the following dependency to your Cargo.toml
// to use these bindings:
//
// [dependencies]
// ts-bindgen-rt = "0.5.0"
// wasm-bindgen = "0.2.63"
// serde = { version = "1.0", features = ["derive"] }
// js-sys = "0.3.53" # optional, depending on your typescript
// web-sys = { version = "0.3.53", features = ["Window"] } # optional, update with features for any types your bindings use
//
// Generated by ts-bindgen, a Ratchet Designs utility.
// Generator available at: https://ts-bindgen.ratchetdesigns.com

#![allow(
    clippy::let_and_return,
    clippy::type_complexity,
    clippy::unused_unit,
    clippy::manual_non_exhaustive,
    clippy::redundant_closure
)]
#[cfg(target_family = "wasm")]
pub mod ns {
    #[allow(unused)]
    use super::*;
    #[allow(unused)]
    use wasm_bindgen::prelude::*;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct UserInterfaceWindowSizeReturn(pub f64, pub f64);
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct GangMemberInfo {
        #[serde(rename = "wantedLevelGain")]
        pub wanted_level_gain: f64,
        #[serde(rename = "def")]
        pub def: f64,
        #[serde(rename = "cha_asc_points")]
        pub cha_asc_points: f64,
        #[serde(rename = "agi")]
        pub agi: f64,
        #[serde(rename = "def_asc_points")]
        pub def_asc_points: f64,
        #[serde(rename = "agi_mult")]
        pub agi_mult: f64,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "hack_mult")]
        pub hack_mult: f64,
        #[serde(rename = "hack_exp")]
        pub hack_exp: f64,
        #[serde(rename = "dex_mult")]
        pub dex_mult: f64,
        #[serde(rename = "cha")]
        pub cha: f64,
        #[serde(rename = "moneyGain")]
        pub money_gain: f64,
        #[serde(rename = "earnedRespect")]
        pub earned_respect: f64,
        #[serde(rename = "str_mult")]
        pub str_mult: f64,
        #[serde(rename = "augmentations")]
        pub augmentations: Vec<String>,
        #[serde(rename = "cha_exp")]
        pub cha_exp: f64,
        #[serde(rename = "dex_exp")]
        pub dex_exp: f64,
        #[serde(rename = "hack_asc_points")]
        pub hack_asc_points: f64,
        #[serde(rename = "dex")]
        pub dex: f64,
        #[serde(rename = "def_asc_mult")]
        pub def_asc_mult: f64,
        #[serde(rename = "str_asc_mult")]
        pub str_asc_mult: f64,
        #[serde(rename = "respectGain")]
        pub respect_gain: f64,
        #[serde(rename = "task")]
        pub task: String,
        #[serde(rename = "str_asc_points")]
        pub str_asc_points: f64,
        #[serde(rename = "def_exp")]
        pub def_exp: f64,
        #[serde(rename = "upgrades")]
        pub upgrades: Vec<String>,
        #[serde(rename = "hack")]
        pub hack: f64,
        #[serde(rename = "hack_asc_mult")]
        pub hack_asc_mult: f64,
        #[serde(rename = "cha_mult")]
        pub cha_mult: f64,
        #[serde(rename = "agi_asc_mult")]
        pub agi_asc_mult: f64,
        #[serde(rename = "agi_asc_points")]
        pub agi_asc_points: f64,
        #[serde(rename = "def_mult")]
        pub def_mult: f64,
        #[serde(rename = "str")]
        pub str: f64,
        #[serde(rename = "cha_asc_mult")]
        pub cha_asc_mult: f64,
        #[serde(rename = "str_exp")]
        pub str_exp: f64,
        #[serde(rename = "agi_exp")]
        pub agi_exp: f64,
        #[serde(rename = "dex_asc_points")]
        pub dex_asc_points: f64,
        #[serde(rename = "dex_asc_mult")]
        pub dex_asc_mult: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait GangMemberInfo_Trait {
        fn set_hack_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hack_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_wanted_level_gain(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn wanted_level_gain(&self) -> std::result::Result<f64, JsValue>;
        fn set_hack_asc_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hack_asc_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_str_asc_points(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn str_asc_points(&self) -> std::result::Result<f64, JsValue>;
        fn set_money_gain(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn money_gain(&self) -> std::result::Result<f64, JsValue>;
        fn set_agi_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn agi_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_agi_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn agi_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_upgrades(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue>;
        fn upgrades(&self) -> std::result::Result<Vec<String>, JsValue>;
        fn set_dex_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn dex_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_def_asc_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn def_asc_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_cha_asc_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cha_asc_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_dex(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn dex(&self) -> std::result::Result<f64, JsValue>;
        fn set_cha_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cha_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_str_asc_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn str_asc_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_agi_asc_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn agi_asc_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_respect_gain(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn respect_gain(&self) -> std::result::Result<f64, JsValue>;
        fn set_str_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn str_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_agi_asc_points(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn agi_asc_points(&self) -> std::result::Result<f64, JsValue>;
        fn set_def_asc_points(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn def_asc_points(&self) -> std::result::Result<f64, JsValue>;
        fn set_def(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn def(&self) -> std::result::Result<f64, JsValue>;
        fn set_cha_asc_points(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cha_asc_points(&self) -> std::result::Result<f64, JsValue>;
        fn set_dex_asc_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn dex_asc_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_task(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn task(&self) -> std::result::Result<String, JsValue>;
        fn set_hack_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hack_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_def_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn def_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_cha(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cha(&self) -> std::result::Result<f64, JsValue>;
        fn set_agi(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn agi(&self) -> std::result::Result<f64, JsValue>;
        fn set_cha_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cha_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_def_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn def_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_str(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn str(&self) -> std::result::Result<f64, JsValue>;
        fn set_dex_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn dex_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_hack(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hack(&self) -> std::result::Result<f64, JsValue>;
        fn set_earned_respect(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn earned_respect(&self) -> std::result::Result<f64, JsValue>;
        fn set_str_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn str_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_augmentations(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue>;
        fn augmentations(&self) -> std::result::Result<Vec<String>, JsValue>;
        fn set_dex_asc_points(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn dex_asc_points(&self) -> std::result::Result<f64, JsValue>;
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn name(&self) -> std::result::Result<String, JsValue>;
        fn set_hack_asc_points(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hack_asc_points(&self) -> std::result::Result<f64, JsValue>;
    }
    impl GangMemberInfo_Trait for GangMemberInfo {
        fn set_hack_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hack_mult = value;
            Ok(())
        }
        fn hack_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hack_mult)
        }
        fn set_wanted_level_gain(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.wanted_level_gain = value;
            Ok(())
        }
        fn wanted_level_gain(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.wanted_level_gain)
        }
        fn set_hack_asc_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hack_asc_mult = value;
            Ok(())
        }
        fn hack_asc_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hack_asc_mult)
        }
        fn set_str_asc_points(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.str_asc_points = value;
            Ok(())
        }
        fn str_asc_points(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.str_asc_points)
        }
        fn set_money_gain(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.money_gain = value;
            Ok(())
        }
        fn money_gain(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.money_gain)
        }
        fn set_agi_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.agi_mult = value;
            Ok(())
        }
        fn agi_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.agi_mult)
        }
        fn set_agi_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.agi_exp = value;
            Ok(())
        }
        fn agi_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.agi_exp)
        }
        fn set_upgrades(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue> {
            self.upgrades = value;
            Ok(())
        }
        fn upgrades(&self) -> std::result::Result<Vec<String>, JsValue> {
            Ok(self.upgrades.clone())
        }
        fn set_dex_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.dex_mult = value;
            Ok(())
        }
        fn dex_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.dex_mult)
        }
        fn set_def_asc_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.def_asc_mult = value;
            Ok(())
        }
        fn def_asc_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.def_asc_mult)
        }
        fn set_cha_asc_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cha_asc_mult = value;
            Ok(())
        }
        fn cha_asc_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cha_asc_mult)
        }
        fn set_dex(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.dex = value;
            Ok(())
        }
        fn dex(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.dex)
        }
        fn set_cha_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cha_exp = value;
            Ok(())
        }
        fn cha_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cha_exp)
        }
        fn set_str_asc_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.str_asc_mult = value;
            Ok(())
        }
        fn str_asc_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.str_asc_mult)
        }
        fn set_agi_asc_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.agi_asc_mult = value;
            Ok(())
        }
        fn agi_asc_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.agi_asc_mult)
        }
        fn set_respect_gain(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.respect_gain = value;
            Ok(())
        }
        fn respect_gain(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.respect_gain)
        }
        fn set_str_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.str_exp = value;
            Ok(())
        }
        fn str_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.str_exp)
        }
        fn set_agi_asc_points(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.agi_asc_points = value;
            Ok(())
        }
        fn agi_asc_points(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.agi_asc_points)
        }
        fn set_def_asc_points(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.def_asc_points = value;
            Ok(())
        }
        fn def_asc_points(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.def_asc_points)
        }
        fn set_def(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.def = value;
            Ok(())
        }
        fn def(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.def)
        }
        fn set_cha_asc_points(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cha_asc_points = value;
            Ok(())
        }
        fn cha_asc_points(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cha_asc_points)
        }
        fn set_dex_asc_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.dex_asc_mult = value;
            Ok(())
        }
        fn dex_asc_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.dex_asc_mult)
        }
        fn set_task(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.task = value;
            Ok(())
        }
        fn task(&self) -> std::result::Result<String, JsValue> {
            Ok(self.task.clone())
        }
        fn set_hack_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hack_exp = value;
            Ok(())
        }
        fn hack_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hack_exp)
        }
        fn set_def_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.def_exp = value;
            Ok(())
        }
        fn def_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.def_exp)
        }
        fn set_cha(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cha = value;
            Ok(())
        }
        fn cha(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cha)
        }
        fn set_agi(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.agi = value;
            Ok(())
        }
        fn agi(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.agi)
        }
        fn set_cha_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cha_mult = value;
            Ok(())
        }
        fn cha_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cha_mult)
        }
        fn set_def_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.def_mult = value;
            Ok(())
        }
        fn def_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.def_mult)
        }
        fn set_str(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.str = value;
            Ok(())
        }
        fn str(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.str)
        }
        fn set_dex_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.dex_exp = value;
            Ok(())
        }
        fn dex_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.dex_exp)
        }
        fn set_hack(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hack = value;
            Ok(())
        }
        fn hack(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hack)
        }
        fn set_earned_respect(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.earned_respect = value;
            Ok(())
        }
        fn earned_respect(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.earned_respect)
        }
        fn set_str_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.str_mult = value;
            Ok(())
        }
        fn str_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.str_mult)
        }
        fn set_augmentations(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue> {
            self.augmentations = value;
            Ok(())
        }
        fn augmentations(&self) -> std::result::Result<Vec<String>, JsValue> {
            Ok(self.augmentations.clone())
        }
        fn set_dex_asc_points(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.dex_asc_points = value;
            Ok(())
        }
        fn dex_asc_points(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.dex_asc_points)
        }
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.name = value;
            Ok(())
        }
        fn name(&self) -> std::result::Result<String, JsValue> {
            Ok(self.name.clone())
        }
        fn set_hack_asc_points(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hack_asc_points = value;
            Ok(())
        }
        fn hack_asc_points(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hack_asc_points)
        }
    }
    #[wasm_bindgen]
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum UniversityClassType {
        ComputerScience = "Computer Science",
        DataStructures = "Data Structures",
        Networks = "Networks",
        Algorithms = "Algorithms",
        Management = "Management",
        Leadership = "Leadership",
    }
    #[allow(dead_code, non_camel_case_types)]
    type SleeveSynchroTask = SleeveSynchroTaskAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct HackingFormulas {
        #[serde(
            rename = "hackTime",
            serialize_with = "HackingFormulas::__TSB__serialize_hack_time",
            deserialize_with = "HackingFormulas::__TSB__deserialize_hack_time"
        )]
        pub hack_time: std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "growThreads",
            serialize_with = "HackingFormulas::__TSB__serialize_grow_threads",
            deserialize_with = "HackingFormulas::__TSB__deserialize_grow_threads"
        )]
        pub grow_threads:
            std::rc::Rc<dyn Fn(Server, Person, f64, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "hackPercent",
            serialize_with = "HackingFormulas::__TSB__serialize_hack_percent",
            deserialize_with = "HackingFormulas::__TSB__deserialize_hack_percent"
        )]
        pub hack_percent: std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "hackExp",
            serialize_with = "HackingFormulas::__TSB__serialize_hack_exp",
            deserialize_with = "HackingFormulas::__TSB__deserialize_hack_exp"
        )]
        pub hack_exp: std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "growPercent",
            serialize_with = "HackingFormulas::__TSB__serialize_grow_percent",
            deserialize_with = "HackingFormulas::__TSB__deserialize_grow_percent"
        )]
        pub grow_percent:
            std::rc::Rc<dyn Fn(Server, f64, Person, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "weakenTime",
            serialize_with = "HackingFormulas::__TSB__serialize_weaken_time",
            deserialize_with = "HackingFormulas::__TSB__deserialize_weaken_time"
        )]
        pub weaken_time: std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "hackChance",
            serialize_with = "HackingFormulas::__TSB__serialize_hack_chance",
            deserialize_with = "HackingFormulas::__TSB__deserialize_hack_chance"
        )]
        pub hack_chance: std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "growTime",
            serialize_with = "HackingFormulas::__TSB__serialize_grow_time",
            deserialize_with = "HackingFormulas::__TSB__deserialize_grow_time"
        )]
        pub grow_time: std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait HackingFormulas_Trait {
        fn set_hack_chance(
            &mut self,
            value: std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn hack_chance(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_grow_threads(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(Server, Person, f64, f64) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn grow_threads(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_hack_percent(
            &mut self,
            value: std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn hack_percent(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_hack_time(
            &mut self,
            value: std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn hack_time(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_grow_percent(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(Server, f64, Person, f64) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn grow_percent(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, f64, Person, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_grow_time(
            &mut self,
            value: std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn grow_time(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_weaken_time(
            &mut self,
            value: std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn weaken_time(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_hack_exp(
            &mut self,
            value: std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn hack_exp(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
    }
    impl HackingFormulas_Trait for HackingFormulas {
        fn set_hack_chance(
            &mut self,
            value: std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.hack_chance = value;
            Ok(())
        }
        fn hack_chance(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.hack_chance.clone())
        }
        fn set_grow_threads(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(Server, Person, f64, f64) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.grow_threads = value;
            Ok(())
        }
        fn grow_threads(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.grow_threads.clone())
        }
        fn set_hack_percent(
            &mut self,
            value: std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.hack_percent = value;
            Ok(())
        }
        fn hack_percent(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.hack_percent.clone())
        }
        fn set_hack_time(
            &mut self,
            value: std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.hack_time = value;
            Ok(())
        }
        fn hack_time(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.hack_time.clone())
        }
        fn set_grow_percent(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(Server, f64, Person, f64) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.grow_percent = value;
            Ok(())
        }
        fn grow_percent(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, f64, Person, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.grow_percent.clone())
        }
        fn set_grow_time(
            &mut self,
            value: std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.grow_time = value;
            Ok(())
        }
        fn grow_time(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.grow_time.clone())
        }
        fn set_weaken_time(
            &mut self,
            value: std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.weaken_time = value;
            Ok(())
        }
        fn weaken_time(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.weaken_time.clone())
        }
        fn set_hack_exp(
            &mut self,
            value: std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.hack_exp = value;
            Ok(())
        }
        fn hack_exp(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.hack_exp.clone())
        }
    }
    impl HackingFormulas {
        #[allow(non_snake_case)]
        fn __TSB__serialize_hack_time<S>(
            hack_time: &std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hack_time = hack_time.clone();
            let hack_time_closure = Closure::wrap(Box::new(
                move |arg0: JsValue, arg1: JsValue| -> std::result::Result<f64, JsValue> {
                    let result = hack_time(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue, JsValue) -> std::result::Result<f64, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &hack_time_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_grow_threads<S>(
            grow_threads: &std::rc::Rc<
                dyn Fn(Server, Person, f64, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let grow_threads = grow_threads.clone();
            let grow_threads_closure = Closure::wrap(Box::new(
                move |arg0: JsValue,
                      arg1: JsValue,
                      arg2: f64,
                      arg3: f64|
                      -> std::result::Result<f64, JsValue> {
                    let result = grow_threads(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue, JsValue, f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &grow_threads_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_hack_percent<S>(
            hack_percent: &std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hack_percent = hack_percent.clone();
            let hack_percent_closure = Closure::wrap(Box::new(
                move |arg0: JsValue, arg1: JsValue| -> std::result::Result<f64, JsValue> {
                    let result = hack_percent(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue, JsValue) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &hack_percent_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_hack_exp<S>(
            hack_exp: &std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hack_exp = hack_exp.clone();
            let hack_exp_closure = Closure::wrap(Box::new(
                move |arg0: JsValue, arg1: JsValue| -> std::result::Result<f64, JsValue> {
                    let result = hack_exp(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue, JsValue) -> std::result::Result<f64, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &hack_exp_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_grow_percent<S>(
            grow_percent: &std::rc::Rc<
                dyn Fn(Server, f64, Person, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let grow_percent = grow_percent.clone();
            let grow_percent_closure = Closure::wrap(Box::new(
                move |arg0: JsValue,
                      arg1: f64,
                      arg2: JsValue,
                      arg3: f64|
                      -> std::result::Result<f64, JsValue> {
                    let result = grow_percent(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        arg1,
                        ts_bindgen_rt::from_jsvalue(&arg2).map_err(ts_bindgen_rt::Error::from)?,
                        arg3,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue, f64, JsValue, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &grow_percent_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_weaken_time<S>(
            weaken_time: &std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let weaken_time = weaken_time.clone();
            let weaken_time_closure = Closure::wrap(Box::new(
                move |arg0: JsValue, arg1: JsValue| -> std::result::Result<f64, JsValue> {
                    let result = weaken_time(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue, JsValue) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &weaken_time_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_hack_chance<S>(
            hack_chance: &std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hack_chance = hack_chance.clone();
            let hack_chance_closure = Closure::wrap(Box::new(
                move |arg0: JsValue, arg1: JsValue| -> std::result::Result<f64, JsValue> {
                    let result = hack_chance(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue, JsValue) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &hack_chance_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_grow_time<S>(
            grow_time: &std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let grow_time = grow_time.clone();
            let grow_time_closure = Closure::wrap(Box::new(
                move |arg0: JsValue, arg1: JsValue| -> std::result::Result<f64, JsValue> {
                    let result = grow_time(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue, JsValue) -> std::result::Result<f64, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &grow_time_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hack_time<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hack_time: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            hack_time
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: Server, arg1: Person| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_grow_threads<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person, f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let grow_threads: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            grow_threads
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: Server, arg1: Person, arg2: f64, arg3: f64| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let arg3 = JsValue::from(arg3);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        _Args.push(&arg3);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(Server, Person, f64, f64) -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hack_percent<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hack_percent: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            hack_percent
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: Server, arg1: Person| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hack_exp<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hack_exp: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            hack_exp
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: Server, arg1: Person| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_grow_percent<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, f64, Person, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let grow_percent: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            grow_percent
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: Server, arg1: f64, arg2: Person, arg3: f64| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = ts_bindgen_rt::to_jsvalue(&arg2);
                        let arg3 = JsValue::from(arg3);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        _Args.push(&arg3);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(Server, f64, Person, f64) -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_weaken_time<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let weaken_time: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            weaken_time
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: Server, arg1: Person| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hack_chance<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hack_chance: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            hack_chance
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: Server, arg1: Person| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_grow_time<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let grow_time: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            grow_time
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: Server, arg1: Person| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(Server, Person) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum AutocompleteDataFlagsReturn {
        VecOfString(Vec<String>),
        ScriptArg(ScriptArg),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct MoneySources {
        #[serde(rename = "sinceStart")]
        pub since_start: MoneySource,
        #[serde(rename = "sinceInstall")]
        pub since_install: MoneySource,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait MoneySources_Trait {
        fn set_since_install(&mut self, value: MoneySource) -> std::result::Result<(), JsValue>;
        fn since_install(&self) -> std::result::Result<MoneySource, JsValue>;
        fn set_since_start(&mut self, value: MoneySource) -> std::result::Result<(), JsValue>;
        fn since_start(&self) -> std::result::Result<MoneySource, JsValue>;
    }
    impl MoneySources_Trait for MoneySources {
        fn set_since_install(&mut self, value: MoneySource) -> std::result::Result<(), JsValue> {
            self.since_install = value;
            Ok(())
        }
        fn since_install(&self) -> std::result::Result<MoneySource, JsValue> {
            Ok(self.since_install.clone())
        }
        fn set_since_start(&mut self, value: MoneySource) -> std::result::Result<(), JsValue> {
            self.since_start = value;
            Ok(())
        }
        fn since_start(&self) -> std::result::Result<MoneySource, JsValue> {
            Ok(self.since_start.clone())
        }
    }
    #[allow(dead_code, non_camel_case_types)]
    type SleeveRecoveryTask = SleeveRecoveryTaskAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Skills {
        #[serde(rename = "strength")]
        pub strength: f64,
        #[serde(rename = "agility")]
        pub agility: f64,
        #[serde(rename = "hacking")]
        pub hacking: f64,
        #[serde(rename = "defense")]
        pub defense: f64,
        #[serde(rename = "dexterity")]
        pub dexterity: f64,
        #[serde(rename = "intelligence")]
        pub intelligence: f64,
        #[serde(rename = "charisma")]
        pub charisma: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait Skills_Trait {
        fn set_charisma(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn charisma(&self) -> std::result::Result<f64, JsValue>;
        fn set_strength(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn strength(&self) -> std::result::Result<f64, JsValue>;
        fn set_agility(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn agility(&self) -> std::result::Result<f64, JsValue>;
        fn set_hacking(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hacking(&self) -> std::result::Result<f64, JsValue>;
        fn set_defense(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn defense(&self) -> std::result::Result<f64, JsValue>;
        fn set_dexterity(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn dexterity(&self) -> std::result::Result<f64, JsValue>;
        fn set_intelligence(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn intelligence(&self) -> std::result::Result<f64, JsValue>;
    }
    impl Skills_Trait for Skills {
        fn set_charisma(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.charisma = value;
            Ok(())
        }
        fn charisma(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.charisma)
        }
        fn set_strength(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.strength = value;
            Ok(())
        }
        fn strength(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.strength)
        }
        fn set_agility(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.agility = value;
            Ok(())
        }
        fn agility(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.agility)
        }
        fn set_hacking(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hacking = value;
            Ok(())
        }
        fn hacking(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacking)
        }
        fn set_defense(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.defense = value;
            Ok(())
        }
        fn defense(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.defense)
        }
        fn set_dexterity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.dexterity = value;
            Ok(())
        }
        fn dexterity(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.dexterity)
        }
        fn set_intelligence(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.intelligence = value;
            Ok(())
        }
        fn intelligence(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.intelligence)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct BladeburnerGetStaminaReturn(pub f64, pub f64);
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct ReputationFormulas {
        #[serde(
            rename = "calculateFavorToRep",
            serialize_with = "ReputationFormulas::__TSB__serialize_calculate_favor_to_rep",
            deserialize_with = "ReputationFormulas::__TSB__deserialize_calculate_favor_to_rep"
        )]
        pub calculate_favor_to_rep: std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "repFromDonation",
            serialize_with = "ReputationFormulas::__TSB__serialize_rep_from_donation",
            deserialize_with = "ReputationFormulas::__TSB__deserialize_rep_from_donation"
        )]
        pub rep_from_donation:
            std::rc::Rc<dyn Fn(f64, Person) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "calculateRepToFavor",
            serialize_with = "ReputationFormulas::__TSB__serialize_calculate_rep_to_favor",
            deserialize_with = "ReputationFormulas::__TSB__deserialize_calculate_rep_to_favor"
        )]
        pub calculate_rep_to_favor: std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait ReputationFormulas_Trait {
        fn set_rep_from_donation(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, Person) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn rep_from_donation(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, Person) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_calculate_rep_to_favor(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn calculate_rep_to_favor(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_calculate_favor_to_rep(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn calculate_favor_to_rep(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
    }
    impl ReputationFormulas_Trait for ReputationFormulas {
        fn set_rep_from_donation(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, Person) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.rep_from_donation = value;
            Ok(())
        }
        fn rep_from_donation(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, Person) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.rep_from_donation.clone())
        }
        fn set_calculate_rep_to_favor(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.calculate_rep_to_favor = value;
            Ok(())
        }
        fn calculate_rep_to_favor(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.calculate_rep_to_favor.clone())
        }
        fn set_calculate_favor_to_rep(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.calculate_favor_to_rep = value;
            Ok(())
        }
        fn calculate_favor_to_rep(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.calculate_favor_to_rep.clone())
        }
    }
    impl ReputationFormulas {
        #[allow(non_snake_case)]
        fn __TSB__serialize_calculate_favor_to_rep<S>(
            calculate_favor_to_rep: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let calculate_favor_to_rep = calculate_favor_to_rep.clone();
            let calculate_favor_to_rep_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<f64, JsValue> {
                    let result = calculate_favor_to_rep(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &calculate_favor_to_rep_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_rep_from_donation<S>(
            rep_from_donation: &std::rc::Rc<
                dyn Fn(f64, Person) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let rep_from_donation = rep_from_donation.clone();
            let rep_from_donation_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: JsValue| -> std::result::Result<f64, JsValue> {
                    let result = rep_from_donation(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, JsValue) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &rep_from_donation_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_calculate_rep_to_favor<S>(
            calculate_rep_to_favor: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let calculate_rep_to_favor = calculate_rep_to_favor.clone();
            let calculate_rep_to_favor_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<f64, JsValue> {
                    let result = calculate_rep_to_favor(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &calculate_rep_to_favor_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_calculate_favor_to_rep<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let calculate_favor_to_rep: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            calculate_favor_to_rep
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_rep_from_donation<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, Person) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let rep_from_donation: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            rep_from_donation
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: Person| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, Person) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_calculate_rep_to_favor<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let calculate_rep_to_favor: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            calculate_rep_to_favor
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[wasm_bindgen]
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum CrimeType {
        Shoplift = "Shoplift",
        RobStore = "Rob Store",
        Mug = "Mug",
        Larceny = "Larceny",
        DealDrugs = "Deal Drugs",
        BondForgery = "Bond Forgery",
        TraffickArms = "Traffick Arms",
        Homicide = "Homicide",
        GrandTheftAuto = "Grand Theft Auto",
        Kidnap = "Kidnap",
        Assassination = "Assassination",
        Heist = "Heist",
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum CorpIndustryNameAliased {
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct NetscriptPort {
        #[serde(
            rename = "peek",
            serialize_with = "NetscriptPort::__TSB__serialize_peek",
            deserialize_with = "NetscriptPort::__TSB__deserialize_peek"
        )]
        pub peek: std::rc::Rc<dyn Fn() -> std::result::Result<PortData, JsValue>>,
        #[serde(
            rename = "full",
            serialize_with = "NetscriptPort::__TSB__serialize_full",
            deserialize_with = "NetscriptPort::__TSB__deserialize_full"
        )]
        pub full: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "empty",
            serialize_with = "NetscriptPort::__TSB__serialize_empty",
            deserialize_with = "NetscriptPort::__TSB__deserialize_empty"
        )]
        pub empty: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "read",
            serialize_with = "NetscriptPort::__TSB__serialize_read",
            deserialize_with = "NetscriptPort::__TSB__deserialize_read"
        )]
        pub read: std::rc::Rc<dyn Fn() -> std::result::Result<PortData, JsValue>>,
        #[serde(
            rename = "clear",
            serialize_with = "NetscriptPort::__TSB__serialize_clear",
            deserialize_with = "NetscriptPort::__TSB__deserialize_clear"
        )]
        pub clear: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "nextWrite",
            serialize_with = "NetscriptPort::__TSB__serialize_next_write",
            deserialize_with = "NetscriptPort::__TSB__deserialize_next_write"
        )]
        pub next_write: std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
        #[serde(
            rename = "write",
            serialize_with = "NetscriptPort::__TSB__serialize_write",
            deserialize_with = "NetscriptPort::__TSB__deserialize_write"
        )]
        pub write: std::rc::Rc<
            dyn Fn(
                NetscriptPortWriteParamsValue,
            ) -> std::result::Result<NetscriptPortWriteReturn, JsValue>,
        >,
        #[serde(
            rename = "tryWrite",
            serialize_with = "NetscriptPort::__TSB__serialize_try_write",
            deserialize_with = "NetscriptPort::__TSB__deserialize_try_write"
        )]
        pub try_write: std::rc::Rc<
            dyn Fn(NetscriptPortTryWriteParamsValue) -> std::result::Result<bool, JsValue>,
        >,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait NetscriptPort_Trait {
        fn set_full(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn full(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_write(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    NetscriptPortWriteParamsValue,
                ) -> std::result::Result<NetscriptPortWriteReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn write(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    NetscriptPortWriteParamsValue,
                ) -> std::result::Result<NetscriptPortWriteReturn, JsValue>,
            >,
            JsValue,
        >;
        fn set_peek(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<PortData, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn peek(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<PortData, JsValue>>,
            JsValue,
        >;
        fn set_empty(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn empty(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_read(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<PortData, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn read(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<PortData, JsValue>>,
            JsValue,
        >;
        fn set_clear(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn clear(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, JsValue>;
        fn set_try_write(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(NetscriptPortTryWriteParamsValue) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn try_write(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(NetscriptPortTryWriteParamsValue) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        >;
        fn set_next_write(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn next_write(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
            JsValue,
        >;
    }
    impl NetscriptPort_Trait for NetscriptPort {
        fn set_full(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.full = value;
            Ok(())
        }
        fn full(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.full.clone())
        }
        fn set_write(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    NetscriptPortWriteParamsValue,
                ) -> std::result::Result<NetscriptPortWriteReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.write = value;
            Ok(())
        }
        fn write(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    NetscriptPortWriteParamsValue,
                ) -> std::result::Result<NetscriptPortWriteReturn, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.write.clone())
        }
        fn set_peek(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<PortData, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.peek = value;
            Ok(())
        }
        fn peek(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<PortData, JsValue>>,
            JsValue,
        > {
            Ok(self.peek.clone())
        }
        fn set_empty(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.empty = value;
            Ok(())
        }
        fn empty(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.empty.clone())
        }
        fn set_read(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<PortData, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.read = value;
            Ok(())
        }
        fn read(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<PortData, JsValue>>,
            JsValue,
        > {
            Ok(self.read.clone())
        }
        fn set_clear(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.clear = value;
            Ok(())
        }
        fn clear(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, JsValue>
        {
            Ok(self.clear.clone())
        }
        fn set_try_write(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(NetscriptPortTryWriteParamsValue) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.try_write = value;
            Ok(())
        }
        fn try_write(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(NetscriptPortTryWriteParamsValue) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.try_write.clone())
        }
        fn set_next_write(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.next_write = value;
            Ok(())
        }
        fn next_write(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
            JsValue,
        > {
            Ok(self.next_write.clone())
        }
    }
    impl NetscriptPort {
        #[allow(non_snake_case)]
        fn __TSB__serialize_peek<S>(
            peek: &std::rc::Rc<dyn Fn() -> std::result::Result<PortData, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let peek = peek.clone();
            let peek_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = peek()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &peek_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_full<S>(
            full: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let full = full.clone();
            let full_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = full()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &full_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_empty<S>(
            empty: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let empty = empty.clone();
            let empty_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = empty()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &empty_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_read<S>(
            read: &std::rc::Rc<dyn Fn() -> std::result::Result<PortData, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let read = read.clone();
            let read_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = read()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &read_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_clear<S>(
            clear: &std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let clear = clear.clone();
            let clear_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<(), JsValue> {
                    let result = clear()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<(), JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &clear_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_next_write<S>(
            next_write: &std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let next_write = next_write.clone();
            let next_write_closure = Closure::wrap(Box::new(
                move || -> std::result::Result<js_sys::Promise, JsValue> {
                    let result = next_write()?;
                    Ok(result)
                },
            )
                as Box<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &next_write_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_write<S>(
            write: &std::rc::Rc<
                dyn Fn(
                    NetscriptPortWriteParamsValue,
                ) -> std::result::Result<NetscriptPortWriteReturn, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let write = write.clone();
            let write_closure = Closure::wrap(Box::new(
                move |arg0: JsValue| -> std::result::Result<JsValue, JsValue> {
                    let result = write(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(JsValue) -> std::result::Result<JsValue, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &write_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_try_write<S>(
            try_write: &std::rc::Rc<
                dyn Fn(NetscriptPortTryWriteParamsValue) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let try_write = try_write.clone();
            let try_write_closure = Closure::wrap(Box::new(
                move |arg0: JsValue| -> std::result::Result<bool, JsValue> {
                    let result = try_write(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue) -> std::result::Result<bool, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &try_write_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_peek<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<PortData, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let peek: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            peek.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(move || {
                    let _Args = js_sys::Array::new();
                    let ret = f.apply(&JsValue::null(), &_Args)?;
                    Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                })
                    as std::rc::Rc<dyn Fn() -> std::result::Result<PortData, JsValue>>
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_full<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let full: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            full.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(move || {
                    let _Args = js_sys::Array::new();
                    let ret = f.apply(&JsValue::null(), &_Args)?;
                    Ok(ret.into_serde().unwrap())
                }) as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_empty<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let empty: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            empty
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_read<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<PortData, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let read: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            read.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(move || {
                    let _Args = js_sys::Array::new();
                    let ret = f.apply(&JsValue::null(), &_Args)?;
                    Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                })
                    as std::rc::Rc<dyn Fn() -> std::result::Result<PortData, JsValue>>
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_clear<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let clear: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            clear
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_next_write<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let next_write: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            next_write
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_write<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    NetscriptPortWriteParamsValue,
                ) -> std::result::Result<NetscriptPortWriteReturn, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let write: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            write
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: NetscriptPortWriteParamsValue| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                NetscriptPortWriteParamsValue,
                            )
                                -> std::result::Result<NetscriptPortWriteReturn, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_try_write<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(NetscriptPortTryWriteParamsValue) -> std::result::Result<bool, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let try_write: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            try_write
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: NetscriptPortTryWriteParamsValue| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                NetscriptPortTryWriteParamsValue,
                            )
                                -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum SleeveSetToFactionWorkReturn {
        Bool(bool),
        #[serde(
            serialize_with = "ts_bindgen_rt::serialize_undefined",
            deserialize_with = "ts_bindgen_rt::deserialize_undefined"
        )]
        TsBindgenRtUndefined,
    }
    #[allow(dead_code, non_camel_case_types)]
    type SleeveCrimeTask = SleeveCrimeTaskAliased;
    #[allow(dead_code, non_camel_case_types)]
    type SleeveInfiltrateTask = SleeveInfiltrateTaskAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct AugmentPair {
        #[serde(rename = "cost")]
        pub cost: f64,
        #[serde(rename = "name")]
        pub name: String,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait AugmentPair_Trait {
        fn set_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn name(&self) -> std::result::Result<String, JsValue>;
    }
    impl AugmentPair_Trait for AugmentPair {
        fn set_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cost = value;
            Ok(())
        }
        fn cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cost)
        }
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.name = value;
            Ok(())
        }
        fn name(&self) -> std::result::Result<String, JsValue> {
            Ok(self.name.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum SleeveClassTaskAliasedClassType {
        UniversityClassType(UniversityClassType),
        GymType(GymType),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Bladeburner {
        #[serde(
            rename = "inBladeburner",
            serialize_with = "Bladeburner::__TSB__serialize_in_bladeburner",
            deserialize_with = "Bladeburner::__TSB__deserialize_in_bladeburner"
        )]
        pub in_bladeburner: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getCityCommunities",
            serialize_with = "Bladeburner::__TSB__serialize_get_city_communities",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_city_communities"
        )]
        pub get_city_communities:
            std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getBlackOpRank",
            serialize_with = "Bladeburner::__TSB__serialize_get_black_op_rank",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_black_op_rank"
        )]
        pub get_black_op_rank: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "setTeamSize",
            serialize_with = "Bladeburner::__TSB__serialize_set_team_size",
            deserialize_with = "Bladeburner::__TSB__deserialize_set_team_size"
        )]
        pub set_team_size:
            std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getCurrentAction",
            serialize_with = "Bladeburner::__TSB__serialize_get_current_action",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_current_action"
        )]
        pub get_current_action:
            std::rc::Rc<dyn Fn() -> std::result::Result<BladeburnerCurAction, JsValue>>,
        #[serde(
            rename = "getActionTime",
            serialize_with = "Bladeburner::__TSB__serialize_get_action_time",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_action_time"
        )]
        pub get_action_time:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "switchCity",
            serialize_with = "Bladeburner::__TSB__serialize_switch_city",
            deserialize_with = "Bladeburner::__TSB__deserialize_switch_city"
        )]
        pub switch_city: std::rc::Rc<dyn Fn(CityName) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getTeamSize",
            serialize_with = "Bladeburner::__TSB__serialize_get_team_size",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_team_size"
        )]
        pub get_team_size: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getActionAutolevel",
            serialize_with = "Bladeburner::__TSB__serialize_get_action_autolevel",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_action_autolevel"
        )]
        pub get_action_autolevel:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getSkillUpgradeCost",
            serialize_with = "Bladeburner::__TSB__serialize_get_skill_upgrade_cost",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_skill_upgrade_cost"
        )]
        pub get_skill_upgrade_cost:
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getActionSuccesses",
            serialize_with = "Bladeburner::__TSB__serialize_get_action_successes",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_action_successes"
        )]
        pub get_action_successes:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getActionCurrentLevel",
            serialize_with = "Bladeburner::__TSB__serialize_get_action_current_level",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_action_current_level"
        )]
        pub get_action_current_level:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getCity",
            serialize_with = "Bladeburner::__TSB__serialize_get_city",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_city"
        )]
        pub get_city: std::rc::Rc<dyn Fn() -> std::result::Result<CityName, JsValue>>,
        #[serde(
            rename = "getSkillNames",
            serialize_with = "Bladeburner::__TSB__serialize_get_skill_names",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_skill_names"
        )]
        pub get_skill_names: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "getBlackOpNames",
            serialize_with = "Bladeburner::__TSB__serialize_get_black_op_names",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_black_op_names"
        )]
        pub get_black_op_names: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "getStamina",
            serialize_with = "Bladeburner::__TSB__serialize_get_stamina",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_stamina"
        )]
        pub get_stamina:
            std::rc::Rc<dyn Fn() -> std::result::Result<BladeburnerGetStaminaReturn, JsValue>>,
        #[serde(
            rename = "startAction",
            serialize_with = "Bladeburner::__TSB__serialize_start_action",
            deserialize_with = "Bladeburner::__TSB__deserialize_start_action"
        )]
        pub start_action: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "setActionAutolevel",
            serialize_with = "Bladeburner::__TSB__serialize_set_action_autolevel",
            deserialize_with = "Bladeburner::__TSB__deserialize_set_action_autolevel"
        )]
        pub set_action_autolevel:
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "getActionCurrentTime",
            serialize_with = "Bladeburner::__TSB__serialize_get_action_current_time",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_action_current_time"
        )]
        pub get_action_current_time: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getActionMaxLevel",
            serialize_with = "Bladeburner::__TSB__serialize_get_action_max_level",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_action_max_level"
        )]
        pub get_action_max_level:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getSkillLevel",
            serialize_with = "Bladeburner::__TSB__serialize_get_skill_level",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_skill_level"
        )]
        pub get_skill_level: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getRank",
            serialize_with = "Bladeburner::__TSB__serialize_get_rank",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_rank"
        )]
        pub get_rank: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "joinBladeburnerFaction",
            serialize_with = "Bladeburner::__TSB__serialize_join_bladeburner_faction",
            deserialize_with = "Bladeburner::__TSB__deserialize_join_bladeburner_faction"
        )]
        pub join_bladeburner_faction: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getGeneralActionNames",
            serialize_with = "Bladeburner::__TSB__serialize_get_general_action_names",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_general_action_names"
        )]
        pub get_general_action_names:
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "getCityChaos",
            serialize_with = "Bladeburner::__TSB__serialize_get_city_chaos",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_city_chaos"
        )]
        pub get_city_chaos: std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getBonusTime",
            serialize_with = "Bladeburner::__TSB__serialize_get_bonus_time",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_bonus_time"
        )]
        pub get_bonus_time: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "setActionLevel",
            serialize_with = "Bladeburner::__TSB__serialize_set_action_level",
            deserialize_with = "Bladeburner::__TSB__deserialize_set_action_level"
        )]
        pub set_action_level:
            std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "getCityEstimatedPopulation",
            serialize_with = "Bladeburner::__TSB__serialize_get_city_estimated_population",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_city_estimated_population"
        )]
        pub get_city_estimated_population:
            std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getActionCountRemaining",
            serialize_with = "Bladeburner::__TSB__serialize_get_action_count_remaining",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_action_count_remaining"
        )]
        pub get_action_count_remaining:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getActionEstimatedSuccessChance",
            serialize_with = "Bladeburner::__TSB__serialize_get_action_estimated_success_chance",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_action_estimated_success_chance"
        )]
        pub get_action_estimated_success_chance: std::rc::Rc<
            dyn Fn(
                String,
                String,
            ) -> std::result::Result<
                BladeburnerGetActionEstimatedSuccessChanceReturn,
                JsValue,
            >,
        >,
        #[serde(
            rename = "getActionRepGain",
            serialize_with = "Bladeburner::__TSB__serialize_get_action_rep_gain",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_action_rep_gain"
        )]
        pub get_action_rep_gain:
            std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "joinBladeburnerDivision",
            serialize_with = "Bladeburner::__TSB__serialize_join_bladeburner_division",
            deserialize_with = "Bladeburner::__TSB__deserialize_join_bladeburner_division"
        )]
        pub join_bladeburner_division: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getOperationNames",
            serialize_with = "Bladeburner::__TSB__serialize_get_operation_names",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_operation_names"
        )]
        pub get_operation_names: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "upgradeSkill",
            serialize_with = "Bladeburner::__TSB__serialize_upgrade_skill",
            deserialize_with = "Bladeburner::__TSB__deserialize_upgrade_skill"
        )]
        pub upgrade_skill: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getContractNames",
            serialize_with = "Bladeburner::__TSB__serialize_get_contract_names",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_contract_names"
        )]
        pub get_contract_names: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "getSkillPoints",
            serialize_with = "Bladeburner::__TSB__serialize_get_skill_points",
            deserialize_with = "Bladeburner::__TSB__deserialize_get_skill_points"
        )]
        pub get_skill_points: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "stopBladeburnerAction",
            serialize_with = "Bladeburner::__TSB__serialize_stop_bladeburner_action",
            deserialize_with = "Bladeburner::__TSB__deserialize_stop_bladeburner_action"
        )]
        pub stop_bladeburner_action: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait Bladeburner_Trait {
        fn set_in_bladeburner(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn in_bladeburner(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_get_black_op_rank(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_black_op_rank(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_action_estimated_success_chance(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                ) -> std::result::Result<
                    BladeburnerGetActionEstimatedSuccessChanceReturn,
                    JsValue,
                >,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_action_estimated_success_chance(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                ) -> std::result::Result<
                    BladeburnerGetActionEstimatedSuccessChanceReturn,
                    JsValue,
                >,
            >,
            JsValue,
        >;
        fn set_get_stamina(
            &mut self,
            value: std::rc::Rc<
                dyn Fn() -> std::result::Result<BladeburnerGetStaminaReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_stamina(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<BladeburnerGetStaminaReturn, JsValue>>,
            JsValue,
        >;
        fn set_stop_bladeburner_action(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn stop_bladeburner_action(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, JsValue>;
        fn set_start_action(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn start_action(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_skill_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_skill_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_city_communities(
            &mut self,
            value: std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_city_communities(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_skill_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_skill_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_set_action_autolevel(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_action_autolevel(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_join_bladeburner_division(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn join_bladeburner_division(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_upgrade_skill(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn upgrade_skill(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_set_team_size(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_team_size(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_action_time(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_action_time(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_city(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<CityName, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_city(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<CityName, JsValue>>,
            JsValue,
        >;
        fn set_get_action_successes(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_action_successes(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_operation_names(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_operation_names(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_get_current_action(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<BladeburnerCurAction, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_current_action(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<BladeburnerCurAction, JsValue>>,
            JsValue,
        >;
        fn set_get_team_size(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_team_size(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_join_bladeburner_faction(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn join_bladeburner_faction(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_get_rank(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_rank(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_get_bonus_time(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_bonus_time(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_get_city_estimated_population(
            &mut self,
            value: std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_city_estimated_population(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_set_action_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_action_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_get_contract_names(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_contract_names(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_get_action_autolevel(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_action_autolevel(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_action_count_remaining(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_action_count_remaining(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_action_rep_gain(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_action_rep_gain(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_skill_names(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_skill_names(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_get_black_op_names(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_black_op_names(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_get_action_current_time(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_action_current_time(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_switch_city(
            &mut self,
            value: std::rc::Rc<dyn Fn(CityName) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn switch_city(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CityName) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_skill_points(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_skill_points(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_get_general_action_names(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_general_action_names(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_get_action_max_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_action_max_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_action_current_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_action_current_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_city_chaos(
            &mut self,
            value: std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_city_chaos(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
    }
    impl Bladeburner_Trait for Bladeburner {
        fn set_in_bladeburner(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.in_bladeburner = value;
            Ok(())
        }
        fn in_bladeburner(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.in_bladeburner.clone())
        }
        fn set_get_black_op_rank(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_black_op_rank = value;
            Ok(())
        }
        fn get_black_op_rank(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_black_op_rank.clone())
        }
        fn set_get_action_estimated_success_chance(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                ) -> std::result::Result<
                    BladeburnerGetActionEstimatedSuccessChanceReturn,
                    JsValue,
                >,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_action_estimated_success_chance = value;
            Ok(())
        }
        fn get_action_estimated_success_chance(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                ) -> std::result::Result<
                    BladeburnerGetActionEstimatedSuccessChanceReturn,
                    JsValue,
                >,
            >,
            JsValue,
        > {
            Ok(self.get_action_estimated_success_chance.clone())
        }
        fn set_get_stamina(
            &mut self,
            value: std::rc::Rc<
                dyn Fn() -> std::result::Result<BladeburnerGetStaminaReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_stamina = value;
            Ok(())
        }
        fn get_stamina(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<BladeburnerGetStaminaReturn, JsValue>>,
            JsValue,
        > {
            Ok(self.get_stamina.clone())
        }
        fn set_stop_bladeburner_action(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.stop_bladeburner_action = value;
            Ok(())
        }
        fn stop_bladeburner_action(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, JsValue>
        {
            Ok(self.stop_bladeburner_action.clone())
        }
        fn set_start_action(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.start_action = value;
            Ok(())
        }
        fn start_action(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.start_action.clone())
        }
        fn set_get_skill_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_skill_level = value;
            Ok(())
        }
        fn get_skill_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_skill_level.clone())
        }
        fn set_get_city_communities(
            &mut self,
            value: std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_city_communities = value;
            Ok(())
        }
        fn get_city_communities(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_city_communities.clone())
        }
        fn set_get_skill_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_skill_upgrade_cost = value;
            Ok(())
        }
        fn get_skill_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_skill_upgrade_cost.clone())
        }
        fn set_set_action_autolevel(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_action_autolevel = value;
            Ok(())
        }
        fn set_action_autolevel(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.set_action_autolevel.clone())
        }
        fn set_join_bladeburner_division(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.join_bladeburner_division = value;
            Ok(())
        }
        fn join_bladeburner_division(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.join_bladeburner_division.clone())
        }
        fn set_upgrade_skill(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.upgrade_skill = value;
            Ok(())
        }
        fn upgrade_skill(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.upgrade_skill.clone())
        }
        fn set_set_team_size(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_team_size = value;
            Ok(())
        }
        fn set_team_size(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.set_team_size.clone())
        }
        fn set_get_action_time(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_action_time = value;
            Ok(())
        }
        fn get_action_time(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_action_time.clone())
        }
        fn set_get_city(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<CityName, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_city = value;
            Ok(())
        }
        fn get_city(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<CityName, JsValue>>,
            JsValue,
        > {
            Ok(self.get_city.clone())
        }
        fn set_get_action_successes(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_action_successes = value;
            Ok(())
        }
        fn get_action_successes(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_action_successes.clone())
        }
        fn set_get_operation_names(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_operation_names = value;
            Ok(())
        }
        fn get_operation_names(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_operation_names.clone())
        }
        fn set_get_current_action(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<BladeburnerCurAction, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_current_action = value;
            Ok(())
        }
        fn get_current_action(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<BladeburnerCurAction, JsValue>>,
            JsValue,
        > {
            Ok(self.get_current_action.clone())
        }
        fn set_get_team_size(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_team_size = value;
            Ok(())
        }
        fn get_team_size(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_team_size.clone())
        }
        fn set_join_bladeburner_faction(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.join_bladeburner_faction = value;
            Ok(())
        }
        fn join_bladeburner_faction(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.join_bladeburner_faction.clone())
        }
        fn set_get_rank(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_rank = value;
            Ok(())
        }
        fn get_rank(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_rank.clone())
        }
        fn set_get_bonus_time(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_bonus_time = value;
            Ok(())
        }
        fn get_bonus_time(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_bonus_time.clone())
        }
        fn set_get_city_estimated_population(
            &mut self,
            value: std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_city_estimated_population = value;
            Ok(())
        }
        fn get_city_estimated_population(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_city_estimated_population.clone())
        }
        fn set_set_action_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_action_level = value;
            Ok(())
        }
        fn set_action_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.set_action_level.clone())
        }
        fn set_get_contract_names(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_contract_names = value;
            Ok(())
        }
        fn get_contract_names(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_contract_names.clone())
        }
        fn set_get_action_autolevel(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_action_autolevel = value;
            Ok(())
        }
        fn get_action_autolevel(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.get_action_autolevel.clone())
        }
        fn set_get_action_count_remaining(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_action_count_remaining = value;
            Ok(())
        }
        fn get_action_count_remaining(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_action_count_remaining.clone())
        }
        fn set_get_action_rep_gain(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_action_rep_gain = value;
            Ok(())
        }
        fn get_action_rep_gain(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_action_rep_gain.clone())
        }
        fn set_get_skill_names(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_skill_names = value;
            Ok(())
        }
        fn get_skill_names(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_skill_names.clone())
        }
        fn set_get_black_op_names(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_black_op_names = value;
            Ok(())
        }
        fn get_black_op_names(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_black_op_names.clone())
        }
        fn set_get_action_current_time(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_action_current_time = value;
            Ok(())
        }
        fn get_action_current_time(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_action_current_time.clone())
        }
        fn set_switch_city(
            &mut self,
            value: std::rc::Rc<dyn Fn(CityName) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.switch_city = value;
            Ok(())
        }
        fn switch_city(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CityName) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.switch_city.clone())
        }
        fn set_get_skill_points(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_skill_points = value;
            Ok(())
        }
        fn get_skill_points(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_skill_points.clone())
        }
        fn set_get_general_action_names(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_general_action_names = value;
            Ok(())
        }
        fn get_general_action_names(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_general_action_names.clone())
        }
        fn set_get_action_max_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_action_max_level = value;
            Ok(())
        }
        fn get_action_max_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_action_max_level.clone())
        }
        fn set_get_action_current_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_action_current_level = value;
            Ok(())
        }
        fn get_action_current_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_action_current_level.clone())
        }
        fn set_get_city_chaos(
            &mut self,
            value: std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_city_chaos = value;
            Ok(())
        }
        fn get_city_chaos(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_city_chaos.clone())
        }
    }
    impl Bladeburner {
        #[allow(non_snake_case)]
        fn __TSB__serialize_in_bladeburner<S>(
            in_bladeburner: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let in_bladeburner = in_bladeburner.clone();
            let in_bladeburner_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = in_bladeburner()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &in_bladeburner_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_city_communities<S>(
            get_city_communities: &std::rc::Rc<
                dyn Fn(CityName) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_city_communities = get_city_communities.clone();
            let get_city_communities_closure = Closure::wrap(Box::new(
                move |arg0: JsValue| -> std::result::Result<f64, JsValue> {
                    let result = get_city_communities(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_city_communities_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_black_op_rank<S>(
            get_black_op_rank: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_black_op_rank = get_black_op_rank.clone();
            let get_black_op_rank_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_black_op_rank(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_black_op_rank_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_team_size<S>(
            set_team_size: &std::rc::Rc<
                dyn Fn(String, String, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_team_size = set_team_size.clone();
            let set_team_size_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String, arg2: f64| -> std::result::Result<f64, JsValue> {
                    let result = set_team_size(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_team_size_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_current_action<S>(
            get_current_action: &std::rc::Rc<
                dyn Fn() -> std::result::Result<BladeburnerCurAction, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_current_action = get_current_action.clone();
            let get_current_action_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_current_action()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_current_action_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_action_time<S>(
            get_action_time: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_action_time = get_action_time.clone();
            let get_action_time_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<f64, JsValue> {
                    let result = get_action_time(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_action_time_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_switch_city<S>(
            switch_city: &std::rc::Rc<dyn Fn(CityName) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let switch_city = switch_city.clone();
            let switch_city_closure = Closure::wrap(Box::new(
                move |arg0: JsValue| -> std::result::Result<bool, JsValue> {
                    let result = switch_city(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &switch_city_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_team_size<S>(
            get_team_size: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_team_size = get_team_size.clone();
            let get_team_size_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<f64, JsValue> {
                    let result = get_team_size(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_team_size_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_action_autolevel<S>(
            get_action_autolevel: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_action_autolevel = get_action_autolevel.clone();
            let get_action_autolevel_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<bool, JsValue> {
                    let result = get_action_autolevel(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_action_autolevel_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_skill_upgrade_cost<S>(
            get_skill_upgrade_cost: &std::rc::Rc<
                dyn Fn(String, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_skill_upgrade_cost = get_skill_upgrade_cost.clone();
            let get_skill_upgrade_cost_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = get_skill_upgrade_cost(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_skill_upgrade_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_action_successes<S>(
            get_action_successes: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_action_successes = get_action_successes.clone();
            let get_action_successes_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<f64, JsValue> {
                    let result = get_action_successes(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_action_successes_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_action_current_level<S>(
            get_action_current_level: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_action_current_level = get_action_current_level.clone();
            let get_action_current_level_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<f64, JsValue> {
                    let result = get_action_current_level(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_action_current_level_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_city<S>(
            get_city: &std::rc::Rc<dyn Fn() -> std::result::Result<CityName, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_city = get_city.clone();
            let get_city_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_city()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &get_city_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_skill_names<S>(
            get_skill_names: &std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_skill_names = get_skill_names.clone();
            let get_skill_names_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_skill_names()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_skill_names_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_black_op_names<S>(
            get_black_op_names: &std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_black_op_names = get_black_op_names.clone();
            let get_black_op_names_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_black_op_names()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_black_op_names_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_stamina<S>(
            get_stamina: &std::rc::Rc<
                dyn Fn() -> std::result::Result<BladeburnerGetStaminaReturn, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_stamina = get_stamina.clone();
            let get_stamina_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_stamina()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        let result_item_0 = result.0;
                        result_array.push(&JsValue::from(result_item_0));
                        let result_item_1 = result.1;
                        result_array.push(&JsValue::from(result_item_1));
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_stamina_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_start_action<S>(
            start_action: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let start_action = start_action.clone();
            let start_action_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<bool, JsValue> {
                    let result = start_action(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &start_action_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_action_autolevel<S>(
            set_action_autolevel: &std::rc::Rc<
                dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_action_autolevel = set_action_autolevel.clone();
            let set_action_autolevel_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String, arg2: bool| -> std::result::Result<(), JsValue> {
                    let result = set_action_autolevel(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_action_autolevel_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_action_current_time<S>(
            get_action_current_time: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_action_current_time = get_action_current_time.clone();
            let get_action_current_time_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_action_current_time()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_action_current_time_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_action_max_level<S>(
            get_action_max_level: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_action_max_level = get_action_max_level.clone();
            let get_action_max_level_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<f64, JsValue> {
                    let result = get_action_max_level(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_action_max_level_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_skill_level<S>(
            get_skill_level: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_skill_level = get_skill_level.clone();
            let get_skill_level_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_skill_level(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_skill_level_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_rank<S>(
            get_rank: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_rank = get_rank.clone();
            let get_rank_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_rank()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &get_rank_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_join_bladeburner_faction<S>(
            join_bladeburner_faction: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let join_bladeburner_faction = join_bladeburner_faction.clone();
            let join_bladeburner_faction_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = join_bladeburner_faction()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &join_bladeburner_faction_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_general_action_names<S>(
            get_general_action_names: &std::rc::Rc<
                dyn Fn() -> std::result::Result<Vec<String>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_general_action_names = get_general_action_names.clone();
            let get_general_action_names_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_general_action_names()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_general_action_names_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_city_chaos<S>(
            get_city_chaos: &std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_city_chaos = get_city_chaos.clone();
            let get_city_chaos_closure = Closure::wrap(Box::new(
                move |arg0: JsValue| -> std::result::Result<f64, JsValue> {
                    let result = get_city_chaos(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_city_chaos_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_bonus_time<S>(
            get_bonus_time: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_bonus_time = get_bonus_time.clone();
            let get_bonus_time_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_bonus_time()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_bonus_time_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_action_level<S>(
            set_action_level: &std::rc::Rc<
                dyn Fn(String, String, f64) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_action_level = set_action_level.clone();
            let set_action_level_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String, arg2: f64| -> std::result::Result<(), JsValue> {
                    let result = set_action_level(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String, f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_action_level_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_city_estimated_population<S>(
            get_city_estimated_population: &std::rc::Rc<
                dyn Fn(CityName) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_city_estimated_population = get_city_estimated_population.clone();
            let get_city_estimated_population_closure = Closure::wrap(Box::new(
                move |arg0: JsValue| -> std::result::Result<f64, JsValue> {
                    let result = get_city_estimated_population(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_city_estimated_population_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_action_count_remaining<S>(
            get_action_count_remaining: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_action_count_remaining = get_action_count_remaining.clone();
            let get_action_count_remaining_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<f64, JsValue> {
                    let result = get_action_count_remaining(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_action_count_remaining_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_action_estimated_success_chance<S>(
            get_action_estimated_success_chance: &std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                ) -> std::result::Result<
                    BladeburnerGetActionEstimatedSuccessChanceReturn,
                    JsValue,
                >,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_action_estimated_success_chance = get_action_estimated_success_chance.clone();
            let get_action_estimated_success_chance_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<JsValue, JsValue> {
                    let result = get_action_estimated_success_chance(arg0, arg1)?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        let result_item_0 = result.0;
                        result_array.push(&JsValue::from(result_item_0));
                        let result_item_1 = result.1;
                        result_array.push(&JsValue::from(result_item_1));
                        result_array.into()
                    })
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_action_estimated_success_chance_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_action_rep_gain<S>(
            get_action_rep_gain: &std::rc::Rc<
                dyn Fn(String, String, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_action_rep_gain = get_action_rep_gain.clone();
            let get_action_rep_gain_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String, arg2: f64| -> std::result::Result<f64, JsValue> {
                    let result = get_action_rep_gain(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_action_rep_gain_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_join_bladeburner_division<S>(
            join_bladeburner_division: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let join_bladeburner_division = join_bladeburner_division.clone();
            let join_bladeburner_division_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = join_bladeburner_division()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &join_bladeburner_division_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_operation_names<S>(
            get_operation_names: &std::rc::Rc<
                dyn Fn() -> std::result::Result<Vec<String>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_operation_names = get_operation_names.clone();
            let get_operation_names_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_operation_names()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_operation_names_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_upgrade_skill<S>(
            upgrade_skill: &std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let upgrade_skill = upgrade_skill.clone();
            let upgrade_skill_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: f64| -> std::result::Result<bool, JsValue> {
                    let result = upgrade_skill(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &upgrade_skill_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_contract_names<S>(
            get_contract_names: &std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_contract_names = get_contract_names.clone();
            let get_contract_names_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_contract_names()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_contract_names_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_skill_points<S>(
            get_skill_points: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_skill_points = get_skill_points.clone();
            let get_skill_points_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_skill_points()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_skill_points_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_stop_bladeburner_action<S>(
            stop_bladeburner_action: &std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let stop_bladeburner_action = stop_bladeburner_action.clone();
            let stop_bladeburner_action_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<(), JsValue> {
                    let result = stop_bladeburner_action()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &stop_bladeburner_action_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_in_bladeburner<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let in_bladeburner: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            in_bladeburner
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_city_communities<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_city_communities: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_city_communities
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: CityName| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_black_op_rank<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_black_op_rank: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_black_op_rank
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_team_size<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_team_size: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_team_size
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, String, f64) -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_current_action<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<BladeburnerCurAction, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_current_action: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_current_action
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn() -> std::result::Result<BladeburnerCurAction, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_action_time<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_action_time: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_action_time
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_switch_city<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CityName) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let switch_city: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            switch_city
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: CityName| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(CityName) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_team_size<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_team_size: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_team_size
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_action_autolevel<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_action_autolevel: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_action_autolevel
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_skill_upgrade_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_skill_upgrade_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_skill_upgrade_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_action_successes<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_action_successes: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_action_successes
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_action_current_level<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_action_current_level: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_action_current_level
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_city<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<CityName, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_city: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_city
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<CityName, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_skill_names<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_skill_names: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_skill_names
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_black_op_names<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_black_op_names: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_black_op_names
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_stamina<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<BladeburnerGetStaminaReturn, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_stamina: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_stamina
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn() -> std::result::Result<BladeburnerGetStaminaReturn, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_start_action<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let start_action: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            start_action
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_action_autolevel<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_action_autolevel: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_action_autolevel
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String, arg2: bool| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_action_current_time<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_action_current_time: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_action_current_time
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_action_max_level<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_action_max_level: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_action_max_level
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_skill_level<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_skill_level: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_skill_level
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_rank<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_rank: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_rank
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_join_bladeburner_faction<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let join_bladeburner_faction: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            join_bladeburner_faction
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_general_action_names<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_general_action_names: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_general_action_names
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_city_chaos<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_city_chaos: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_city_chaos
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: CityName| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_bonus_time<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_bonus_time: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_bonus_time
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_action_level<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_action_level: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_action_level
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, String, f64) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_city_estimated_population<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_city_estimated_population: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_city_estimated_population
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: CityName| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(CityName) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_action_count_remaining<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_action_count_remaining: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_action_count_remaining
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_action_estimated_success_chance<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                ) -> std::result::Result<
                    BladeburnerGetActionEstimatedSuccessChanceReturn,
                    JsValue,
                >,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_action_estimated_success_chance: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_action_estimated_success_chance
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                String,
                            ) -> std::result::Result<
                                BladeburnerGetActionEstimatedSuccessChanceReturn,
                                JsValue,
                            >,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_action_rep_gain<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_action_rep_gain: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_action_rep_gain
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, String, f64) -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_join_bladeburner_division<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let join_bladeburner_division: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            join_bladeburner_division
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_operation_names<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_operation_names: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_operation_names
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_upgrade_skill<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let upgrade_skill: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            upgrade_skill
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_contract_names<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_contract_names: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_contract_names
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_skill_points<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_skill_points: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_skill_points
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_stop_bladeburner_action<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let stop_bladeburner_action: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            stop_bladeburner_action
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum StanekGetFragmentReturn {
        ActiveFragment(ActiveFragment),
        #[serde(
            serialize_with = "ts_bindgen_rt::serialize_undefined",
            deserialize_with = "ts_bindgen_rt::deserialize_undefined"
        )]
        TsBindgenRtUndefined,
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsGetScriptLogsParamsArgs {
        Bool(bool),
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct CorporationInfo {
        #[serde(rename = "dividendEarnings")]
        pub dividend_earnings: f64,
        #[serde(rename = "totalShares")]
        pub total_shares: f64,
        #[serde(rename = "numShares")]
        pub num_shares: f64,
        #[serde(rename = "public")]
        pub public: bool,
        #[serde(rename = "shareSaleCooldown")]
        pub share_sale_cooldown: f64,
        #[serde(rename = "divisions")]
        pub divisions: Vec<String>,
        #[serde(rename = "funds")]
        pub funds: f64,
        #[serde(rename = "sharePrice")]
        pub share_price: f64,
        #[serde(rename = "expenses")]
        pub expenses: f64,
        #[serde(rename = "issuedShares")]
        pub issued_shares: f64,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "revenue")]
        pub revenue: f64,
        #[serde(rename = "dividendTax")]
        pub dividend_tax: f64,
        #[serde(rename = "dividendRate")]
        pub dividend_rate: f64,
        #[serde(rename = "state")]
        pub state: String,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait CorporationInfo_Trait {
        fn set_num_shares(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn num_shares(&self) -> std::result::Result<f64, JsValue>;
        fn set_issued_shares(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn issued_shares(&self) -> std::result::Result<f64, JsValue>;
        fn set_dividend_rate(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn dividend_rate(&self) -> std::result::Result<f64, JsValue>;
        fn set_share_price(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn share_price(&self) -> std::result::Result<f64, JsValue>;
        fn set_dividend_tax(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn dividend_tax(&self) -> std::result::Result<f64, JsValue>;
        fn set_revenue(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn revenue(&self) -> std::result::Result<f64, JsValue>;
        fn set_funds(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn funds(&self) -> std::result::Result<f64, JsValue>;
        fn set_public(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn public(&self) -> std::result::Result<bool, JsValue>;
        fn set_state(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn state(&self) -> std::result::Result<String, JsValue>;
        fn set_dividend_earnings(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn dividend_earnings(&self) -> std::result::Result<f64, JsValue>;
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn name(&self) -> std::result::Result<String, JsValue>;
        fn set_divisions(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue>;
        fn divisions(&self) -> std::result::Result<Vec<String>, JsValue>;
        fn set_total_shares(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn total_shares(&self) -> std::result::Result<f64, JsValue>;
        fn set_expenses(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn expenses(&self) -> std::result::Result<f64, JsValue>;
        fn set_share_sale_cooldown(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn share_sale_cooldown(&self) -> std::result::Result<f64, JsValue>;
    }
    impl CorporationInfo_Trait for CorporationInfo {
        fn set_num_shares(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.num_shares = value;
            Ok(())
        }
        fn num_shares(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.num_shares)
        }
        fn set_issued_shares(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.issued_shares = value;
            Ok(())
        }
        fn issued_shares(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.issued_shares)
        }
        fn set_dividend_rate(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.dividend_rate = value;
            Ok(())
        }
        fn dividend_rate(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.dividend_rate)
        }
        fn set_share_price(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.share_price = value;
            Ok(())
        }
        fn share_price(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.share_price)
        }
        fn set_dividend_tax(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.dividend_tax = value;
            Ok(())
        }
        fn dividend_tax(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.dividend_tax)
        }
        fn set_revenue(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.revenue = value;
            Ok(())
        }
        fn revenue(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.revenue)
        }
        fn set_funds(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.funds = value;
            Ok(())
        }
        fn funds(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.funds)
        }
        fn set_public(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.public = value;
            Ok(())
        }
        fn public(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.public)
        }
        fn set_state(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.state = value;
            Ok(())
        }
        fn state(&self) -> std::result::Result<String, JsValue> {
            Ok(self.state.clone())
        }
        fn set_dividend_earnings(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.dividend_earnings = value;
            Ok(())
        }
        fn dividend_earnings(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.dividend_earnings)
        }
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.name = value;
            Ok(())
        }
        fn name(&self) -> std::result::Result<String, JsValue> {
            Ok(self.name.clone())
        }
        fn set_divisions(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue> {
            self.divisions = value;
            Ok(())
        }
        fn divisions(&self) -> std::result::Result<Vec<String>, JsValue> {
            Ok(self.divisions.clone())
        }
        fn set_total_shares(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.total_shares = value;
            Ok(())
        }
        fn total_shares(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.total_shares)
        }
        fn set_expenses(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.expenses = value;
            Ok(())
        }
        fn expenses(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.expenses)
        }
        fn set_share_sale_cooldown(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.share_sale_cooldown = value;
            Ok(())
        }
        fn share_sale_cooldown(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.share_sale_cooldown)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsWriteParamsMode {
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum MaterialDesiredSellAmount {
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsWritePortReturn {
        TsBindgenRtNull,
        PortData(PortData),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Division {
        #[serde(rename = "thisCycleExpenses")]
        pub this_cycle_expenses: f64,
        #[serde(rename = "products")]
        pub products: Vec<String>,
        #[serde(rename = "lastCycleRevenue")]
        pub last_cycle_revenue: f64,
        #[serde(rename = "productionMult")]
        pub production_mult: f64,
        #[serde(rename = "awareness")]
        pub awareness: f64,
        #[serde(rename = "maxProducts")]
        pub max_products: f64,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "cities")]
        pub cities: Vec<CityName>,
        #[serde(rename = "popularity")]
        pub popularity: f64,
        #[serde(rename = "researchPoints")]
        pub research_points: f64,
        #[serde(rename = "lastCycleExpenses")]
        pub last_cycle_expenses: f64,
        #[serde(rename = "numAdVerts")]
        pub num_ad_verts: f64,
        #[serde(rename = "type")]
        pub type_: CorpIndustryName,
        #[serde(rename = "thisCycleRevenue")]
        pub this_cycle_revenue: f64,
        #[serde(rename = "makesProducts")]
        pub makes_products: bool,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait Division_Trait {
        fn set_max_products(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn max_products(&self) -> std::result::Result<f64, JsValue>;
        fn set_research_points(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn research_points(&self) -> std::result::Result<f64, JsValue>;
        fn set_production_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn production_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_num_ad_verts(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn num_ad_verts(&self) -> std::result::Result<f64, JsValue>;
        fn set_this_cycle_expenses(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn this_cycle_expenses(&self) -> std::result::Result<f64, JsValue>;
        fn set_products(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue>;
        fn products(&self) -> std::result::Result<Vec<String>, JsValue>;
        fn set_makes_products(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn makes_products(&self) -> std::result::Result<bool, JsValue>;
        fn set_awareness(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn awareness(&self) -> std::result::Result<f64, JsValue>;
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn name(&self) -> std::result::Result<String, JsValue>;
        fn set_type_(&mut self, value: CorpIndustryName) -> std::result::Result<(), JsValue>;
        fn type_(&self) -> std::result::Result<CorpIndustryName, JsValue>;
        fn set_cities(&mut self, value: Vec<CityName>) -> std::result::Result<(), JsValue>;
        fn cities(&self) -> std::result::Result<Vec<CityName>, JsValue>;
        fn set_popularity(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn popularity(&self) -> std::result::Result<f64, JsValue>;
        fn set_this_cycle_revenue(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn this_cycle_revenue(&self) -> std::result::Result<f64, JsValue>;
        fn set_last_cycle_expenses(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn last_cycle_expenses(&self) -> std::result::Result<f64, JsValue>;
        fn set_last_cycle_revenue(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn last_cycle_revenue(&self) -> std::result::Result<f64, JsValue>;
    }
    impl Division_Trait for Division {
        fn set_max_products(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.max_products = value;
            Ok(())
        }
        fn max_products(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.max_products)
        }
        fn set_research_points(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.research_points = value;
            Ok(())
        }
        fn research_points(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.research_points)
        }
        fn set_production_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.production_mult = value;
            Ok(())
        }
        fn production_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.production_mult)
        }
        fn set_num_ad_verts(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.num_ad_verts = value;
            Ok(())
        }
        fn num_ad_verts(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.num_ad_verts)
        }
        fn set_this_cycle_expenses(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.this_cycle_expenses = value;
            Ok(())
        }
        fn this_cycle_expenses(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.this_cycle_expenses)
        }
        fn set_products(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue> {
            self.products = value;
            Ok(())
        }
        fn products(&self) -> std::result::Result<Vec<String>, JsValue> {
            Ok(self.products.clone())
        }
        fn set_makes_products(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.makes_products = value;
            Ok(())
        }
        fn makes_products(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.makes_products)
        }
        fn set_awareness(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.awareness = value;
            Ok(())
        }
        fn awareness(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.awareness)
        }
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.name = value;
            Ok(())
        }
        fn name(&self) -> std::result::Result<String, JsValue> {
            Ok(self.name.clone())
        }
        fn set_type_(&mut self, value: CorpIndustryName) -> std::result::Result<(), JsValue> {
            self.type_ = value;
            Ok(())
        }
        fn type_(&self) -> std::result::Result<CorpIndustryName, JsValue> {
            Ok(self.type_.clone())
        }
        fn set_cities(&mut self, value: Vec<CityName>) -> std::result::Result<(), JsValue> {
            self.cities = value;
            Ok(())
        }
        fn cities(&self) -> std::result::Result<Vec<CityName>, JsValue> {
            Ok(self.cities.clone())
        }
        fn set_popularity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.popularity = value;
            Ok(())
        }
        fn popularity(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.popularity)
        }
        fn set_this_cycle_revenue(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.this_cycle_revenue = value;
            Ok(())
        }
        fn this_cycle_revenue(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.this_cycle_revenue)
        }
        fn set_last_cycle_expenses(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.last_cycle_expenses = value;
            Ok(())
        }
        fn last_cycle_expenses(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.last_cycle_expenses)
        }
        fn set_last_cycle_revenue(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.last_cycle_revenue = value;
            Ok(())
        }
        fn last_cycle_revenue(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.last_cycle_revenue)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct SourceFileLvl {
        #[serde(rename = "n")]
        pub n: f64,
        #[serde(rename = "lvl")]
        pub lvl: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait SourceFileLvl_Trait {
        fn set_n(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn n(&self) -> std::result::Result<f64, JsValue>;
        fn set_lvl(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn lvl(&self) -> std::result::Result<f64, JsValue>;
    }
    impl SourceFileLvl_Trait for SourceFileLvl {
        fn set_n(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.n = value;
            Ok(())
        }
        fn n(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.n)
        }
        fn set_lvl(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.lvl = value;
            Ok(())
        }
        fn lvl(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.lvl)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Stanek {
        #[serde(
            rename = "acceptGift",
            serialize_with = "Stanek::__TSB__serialize_accept_gift",
            deserialize_with = "Stanek::__TSB__deserialize_accept_gift"
        )]
        pub accept_gift: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "placeFragment",
            serialize_with = "Stanek::__TSB__serialize_place_fragment",
            deserialize_with = "Stanek::__TSB__deserialize_place_fragment"
        )]
        pub place_fragment:
            std::rc::Rc<dyn Fn(f64, f64, f64, f64) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "giftHeight",
            serialize_with = "Stanek::__TSB__serialize_gift_height",
            deserialize_with = "Stanek::__TSB__deserialize_gift_height"
        )]
        pub gift_height: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "giftWidth",
            serialize_with = "Stanek::__TSB__serialize_gift_width",
            deserialize_with = "Stanek::__TSB__deserialize_gift_width"
        )]
        pub gift_width: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "chargeFragment",
            serialize_with = "Stanek::__TSB__serialize_charge_fragment",
            deserialize_with = "Stanek::__TSB__deserialize_charge_fragment"
        )]
        pub charge_fragment:
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<js_sys::Promise, JsValue>>,
        #[serde(
            rename = "activeFragments",
            serialize_with = "Stanek::__TSB__serialize_active_fragments",
            deserialize_with = "Stanek::__TSB__deserialize_active_fragments"
        )]
        pub active_fragments:
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<ActiveFragment>, JsValue>>,
        #[serde(
            rename = "removeFragment",
            serialize_with = "Stanek::__TSB__serialize_remove_fragment",
            deserialize_with = "Stanek::__TSB__deserialize_remove_fragment"
        )]
        pub remove_fragment: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getFragment",
            serialize_with = "Stanek::__TSB__serialize_get_fragment",
            deserialize_with = "Stanek::__TSB__deserialize_get_fragment"
        )]
        pub get_fragment:
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<StanekGetFragmentReturn, JsValue>>,
        #[serde(
            rename = "canPlaceFragment",
            serialize_with = "Stanek::__TSB__serialize_can_place_fragment",
            deserialize_with = "Stanek::__TSB__deserialize_can_place_fragment"
        )]
        pub can_place_fragment:
            std::rc::Rc<dyn Fn(f64, f64, f64, f64) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "fragmentDefinitions",
            serialize_with = "Stanek::__TSB__serialize_fragment_definitions",
            deserialize_with = "Stanek::__TSB__deserialize_fragment_definitions"
        )]
        pub fragment_definitions:
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<Fragment>, JsValue>>,
        #[serde(
            rename = "clearGift",
            serialize_with = "Stanek::__TSB__serialize_clear_gift",
            deserialize_with = "Stanek::__TSB__deserialize_clear_gift"
        )]
        pub clear_gift: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait Stanek_Trait {
        fn set_can_place_fragment(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn can_place_fragment(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_gift_height(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn gift_height(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_remove_fragment(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn remove_fragment(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_accept_gift(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn accept_gift(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_fragment_definitions(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<Fragment>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn fragment_definitions(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<Fragment>, JsValue>>,
            JsValue,
        >;
        fn set_get_fragment(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(f64, f64) -> std::result::Result<StanekGetFragmentReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_fragment(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<StanekGetFragmentReturn, JsValue>>,
            JsValue,
        >;
        fn set_clear_gift(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn clear_gift(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, JsValue>;
        fn set_active_fragments(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<ActiveFragment>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn active_fragments(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<ActiveFragment>, JsValue>>,
            JsValue,
        >;
        fn set_charge_fragment(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<js_sys::Promise, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn charge_fragment(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<js_sys::Promise, JsValue>>,
            JsValue,
        >;
        fn set_gift_width(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn gift_width(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_place_fragment(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn place_fragment(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
    }
    impl Stanek_Trait for Stanek {
        fn set_can_place_fragment(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.can_place_fragment = value;
            Ok(())
        }
        fn can_place_fragment(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.can_place_fragment.clone())
        }
        fn set_gift_height(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.gift_height = value;
            Ok(())
        }
        fn gift_height(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.gift_height.clone())
        }
        fn set_remove_fragment(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.remove_fragment = value;
            Ok(())
        }
        fn remove_fragment(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.remove_fragment.clone())
        }
        fn set_accept_gift(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.accept_gift = value;
            Ok(())
        }
        fn accept_gift(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.accept_gift.clone())
        }
        fn set_fragment_definitions(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<Fragment>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.fragment_definitions = value;
            Ok(())
        }
        fn fragment_definitions(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<Fragment>, JsValue>>,
            JsValue,
        > {
            Ok(self.fragment_definitions.clone())
        }
        fn set_get_fragment(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(f64, f64) -> std::result::Result<StanekGetFragmentReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_fragment = value;
            Ok(())
        }
        fn get_fragment(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<StanekGetFragmentReturn, JsValue>>,
            JsValue,
        > {
            Ok(self.get_fragment.clone())
        }
        fn set_clear_gift(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.clear_gift = value;
            Ok(())
        }
        fn clear_gift(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, JsValue>
        {
            Ok(self.clear_gift.clone())
        }
        fn set_active_fragments(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<ActiveFragment>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.active_fragments = value;
            Ok(())
        }
        fn active_fragments(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<ActiveFragment>, JsValue>>,
            JsValue,
        > {
            Ok(self.active_fragments.clone())
        }
        fn set_charge_fragment(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<js_sys::Promise, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.charge_fragment = value;
            Ok(())
        }
        fn charge_fragment(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<js_sys::Promise, JsValue>>,
            JsValue,
        > {
            Ok(self.charge_fragment.clone())
        }
        fn set_gift_width(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.gift_width = value;
            Ok(())
        }
        fn gift_width(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.gift_width.clone())
        }
        fn set_place_fragment(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.place_fragment = value;
            Ok(())
        }
        fn place_fragment(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.place_fragment.clone())
        }
    }
    impl Stanek {
        #[allow(non_snake_case)]
        fn __TSB__serialize_accept_gift<S>(
            accept_gift: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let accept_gift = accept_gift.clone();
            let accept_gift_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = accept_gift()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &accept_gift_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_place_fragment<S>(
            place_fragment: &std::rc::Rc<
                dyn Fn(f64, f64, f64, f64) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let place_fragment = place_fragment.clone();
            let place_fragment_closure = Closure::wrap(Box::new(
                move |arg0: f64,
                      arg1: f64,
                      arg2: f64,
                      arg3: f64|
                      -> std::result::Result<bool, JsValue> {
                    let result = place_fragment(arg0, arg1, arg2, arg3)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64, f64, f64) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &place_fragment_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_gift_height<S>(
            gift_height: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let gift_height = gift_height.clone();
            let gift_height_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = gift_height()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &gift_height_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_gift_width<S>(
            gift_width: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let gift_width = gift_width.clone();
            let gift_width_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = gift_width()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &gift_width_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_charge_fragment<S>(
            charge_fragment: &std::rc::Rc<
                dyn Fn(f64, f64) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let charge_fragment = charge_fragment.clone();
            let charge_fragment_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<js_sys::Promise, JsValue> {
                    let result = charge_fragment(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<js_sys::Promise, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &charge_fragment_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_active_fragments<S>(
            active_fragments: &std::rc::Rc<
                dyn Fn() -> std::result::Result<Vec<ActiveFragment>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let active_fragments = active_fragments.clone();
            let active_fragments_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = active_fragments()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(
                                &ts_bindgen_rt::to_jsvalue(&result_item)
                                    .map_err(ts_bindgen_rt::Error::from)?,
                            );
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &active_fragments_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_remove_fragment<S>(
            remove_fragment: &std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let remove_fragment = remove_fragment.clone();
            let remove_fragment_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<bool, JsValue> {
                    let result = remove_fragment(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &remove_fragment_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_fragment<S>(
            get_fragment: &std::rc::Rc<
                dyn Fn(f64, f64) -> std::result::Result<StanekGetFragmentReturn, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_fragment = get_fragment.clone();
            let get_fragment_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<JsValue, JsValue> {
                    let result = get_fragment(arg0, arg1)?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_fragment_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_can_place_fragment<S>(
            can_place_fragment: &std::rc::Rc<
                dyn Fn(f64, f64, f64, f64) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let can_place_fragment = can_place_fragment.clone();
            let can_place_fragment_closure = Closure::wrap(Box::new(
                move |arg0: f64,
                      arg1: f64,
                      arg2: f64,
                      arg3: f64|
                      -> std::result::Result<bool, JsValue> {
                    let result = can_place_fragment(arg0, arg1, arg2, arg3)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64, f64, f64) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &can_place_fragment_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_fragment_definitions<S>(
            fragment_definitions: &std::rc::Rc<
                dyn Fn() -> std::result::Result<Vec<Fragment>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let fragment_definitions = fragment_definitions.clone();
            let fragment_definitions_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = fragment_definitions()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(
                                &ts_bindgen_rt::to_jsvalue(&result_item)
                                    .map_err(ts_bindgen_rt::Error::from)?,
                            );
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &fragment_definitions_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_clear_gift<S>(
            clear_gift: &std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let clear_gift = clear_gift.clone();
            let clear_gift_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<(), JsValue> {
                    let result = clear_gift()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &clear_gift_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_accept_gift<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let accept_gift: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            accept_gift
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_place_fragment<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64, f64) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let place_fragment: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            place_fragment
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64, arg2: f64, arg3: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let arg3 = JsValue::from(arg3);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        _Args.push(&arg3);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(f64, f64, f64, f64) -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_gift_height<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let gift_height: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            gift_height
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_gift_width<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let gift_width: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            gift_width
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_charge_fragment<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<js_sys::Promise, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let charge_fragment: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            charge_fragment
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(f64, f64) -> std::result::Result<js_sys::Promise, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_active_fragments<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<ActiveFragment>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let active_fragments: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            active_fragments
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn() -> std::result::Result<Vec<ActiveFragment>, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_remove_fragment<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let remove_fragment: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            remove_fragment
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_fragment<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<StanekGetFragmentReturn, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_fragment: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_fragment
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                f64,
                                f64,
                            )
                                -> std::result::Result<StanekGetFragmentReturn, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_can_place_fragment<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64, f64) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let can_place_fragment: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            can_place_fragment
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64, arg2: f64, arg3: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let arg3 = JsValue::from(arg3);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        _Args.push(&arg3);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(f64, f64, f64, f64) -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_fragment_definitions<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<Fragment>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let fragment_definitions: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            fragment_definitions
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<Fragment>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_clear_gift<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let clear_gift: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            clear_gift
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct SleeveSupportTaskAliased {
        #[serde(rename = "type")]
        pub type_: String,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait SleeveSupportTaskAliased_Trait {
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn type_(&self) -> std::result::Result<String, JsValue>;
    }
    impl SleeveSupportTaskAliased_Trait for SleeveSupportTaskAliased {
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.type_ = value;
            Ok(())
        }
        fn type_(&self) -> std::result::Result<String, JsValue> {
            Ok(self.type_.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum UserInterfaceThemeIndexer {
        String(String),
        #[serde(
            serialize_with = "ts_bindgen_rt::serialize_undefined",
            deserialize_with = "ts_bindgen_rt::deserialize_undefined"
        )]
        TsBindgenRtUndefined,
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct CorpMaterialConstantDataDemandRange(pub f64, pub f64);
    #[allow(dead_code, non_camel_case_types)]
    type SleeveBladeburnerTask = SleeveBladeburnerTaskAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum CorpMaterialNameAliased {
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum CompanyPositionInfoNextPosition {
        JobName(JobName),
        TsBindgenRtNull,
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum CorpUnlockNameAliased {
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct RunningScript {
        #[serde(rename = "onlineExpGained")]
        pub online_exp_gained: f64,
        #[serde(rename = "title")]
        pub title: String,
        #[serde(rename = "threads")]
        pub threads: f64,
        #[serde(rename = "onlineRunningTime")]
        pub online_running_time: f64,
        #[serde(rename = "logs")]
        pub logs: Vec<String>,
        #[serde(rename = "pid")]
        pub pid: f64,
        #[serde(rename = "args")]
        pub args: Vec<RunningScriptArgs>,
        #[serde(rename = "filename")]
        pub filename: String,
        #[serde(rename = "offlineExpGained")]
        pub offline_exp_gained: f64,
        #[serde(rename = "ramUsage")]
        pub ram_usage: f64,
        #[serde(rename = "onlineMoneyMade")]
        pub online_money_made: f64,
        #[serde(rename = "tailProperties")]
        pub tail_properties: RunningScriptTailProperties,
        #[serde(rename = "server")]
        pub server: String,
        #[serde(rename = "offlineMoneyMade")]
        pub offline_money_made: f64,
        #[serde(rename = "offlineRunningTime")]
        pub offline_running_time: f64,
        #[serde(rename = "temporary")]
        pub temporary: bool,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait RunningScript_Trait {
        fn set_online_exp_gained(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn online_exp_gained(&self) -> std::result::Result<f64, JsValue>;
        fn set_temporary(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn temporary(&self) -> std::result::Result<bool, JsValue>;
        fn set_offline_exp_gained(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn offline_exp_gained(&self) -> std::result::Result<f64, JsValue>;
        fn set_tail_properties(
            &mut self,
            value: RunningScriptTailProperties,
        ) -> std::result::Result<(), JsValue>;
        fn tail_properties(&self) -> std::result::Result<RunningScriptTailProperties, JsValue>;
        fn set_filename(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn filename(&self) -> std::result::Result<String, JsValue>;
        fn set_title(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn title(&self) -> std::result::Result<String, JsValue>;
        fn set_threads(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn threads(&self) -> std::result::Result<f64, JsValue>;
        fn set_offline_running_time(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn offline_running_time(&self) -> std::result::Result<f64, JsValue>;
        fn set_server(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn server(&self) -> std::result::Result<String, JsValue>;
        fn set_logs(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue>;
        fn logs(&self) -> std::result::Result<Vec<String>, JsValue>;
        fn set_offline_money_made(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn offline_money_made(&self) -> std::result::Result<f64, JsValue>;
        fn set_ram_usage(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn ram_usage(&self) -> std::result::Result<f64, JsValue>;
        fn set_pid(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn pid(&self) -> std::result::Result<f64, JsValue>;
        fn set_online_running_time(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn online_running_time(&self) -> std::result::Result<f64, JsValue>;
        fn set_online_money_made(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn online_money_made(&self) -> std::result::Result<f64, JsValue>;
        fn set_args(&mut self, value: Vec<RunningScriptArgs>) -> std::result::Result<(), JsValue>;
        fn args(&self) -> std::result::Result<Vec<RunningScriptArgs>, JsValue>;
    }
    impl RunningScript_Trait for RunningScript {
        fn set_online_exp_gained(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.online_exp_gained = value;
            Ok(())
        }
        fn online_exp_gained(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.online_exp_gained)
        }
        fn set_temporary(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.temporary = value;
            Ok(())
        }
        fn temporary(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.temporary)
        }
        fn set_offline_exp_gained(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.offline_exp_gained = value;
            Ok(())
        }
        fn offline_exp_gained(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.offline_exp_gained)
        }
        fn set_tail_properties(
            &mut self,
            value: RunningScriptTailProperties,
        ) -> std::result::Result<(), JsValue> {
            self.tail_properties = value;
            Ok(())
        }
        fn tail_properties(&self) -> std::result::Result<RunningScriptTailProperties, JsValue> {
            Ok(self.tail_properties.clone())
        }
        fn set_filename(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.filename = value;
            Ok(())
        }
        fn filename(&self) -> std::result::Result<String, JsValue> {
            Ok(self.filename.clone())
        }
        fn set_title(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.title = value;
            Ok(())
        }
        fn title(&self) -> std::result::Result<String, JsValue> {
            Ok(self.title.clone())
        }
        fn set_threads(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.threads = value;
            Ok(())
        }
        fn threads(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.threads)
        }
        fn set_offline_running_time(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.offline_running_time = value;
            Ok(())
        }
        fn offline_running_time(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.offline_running_time)
        }
        fn set_server(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.server = value;
            Ok(())
        }
        fn server(&self) -> std::result::Result<String, JsValue> {
            Ok(self.server.clone())
        }
        fn set_logs(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue> {
            self.logs = value;
            Ok(())
        }
        fn logs(&self) -> std::result::Result<Vec<String>, JsValue> {
            Ok(self.logs.clone())
        }
        fn set_offline_money_made(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.offline_money_made = value;
            Ok(())
        }
        fn offline_money_made(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.offline_money_made)
        }
        fn set_ram_usage(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.ram_usage = value;
            Ok(())
        }
        fn ram_usage(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.ram_usage)
        }
        fn set_pid(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.pid = value;
            Ok(())
        }
        fn pid(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.pid)
        }
        fn set_online_running_time(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.online_running_time = value;
            Ok(())
        }
        fn online_running_time(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.online_running_time)
        }
        fn set_online_money_made(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.online_money_made = value;
            Ok(())
        }
        fn online_money_made(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.online_money_made)
        }
        fn set_args(&mut self, value: Vec<RunningScriptArgs>) -> std::result::Result<(), JsValue> {
            self.args = value;
            Ok(())
        }
        fn args(&self) -> std::result::Result<Vec<RunningScriptArgs>, JsValue> {
            Ok(self.args.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Hp {
        #[serde(rename = "max")]
        pub max: f64,
        #[serde(rename = "current")]
        pub current: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait Hp_Trait {
        fn set_max(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn max(&self) -> std::result::Result<f64, JsValue>;
        fn set_current(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn current(&self) -> std::result::Result<f64, JsValue>;
    }
    impl Hp_Trait for Hp {
        fn set_max(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.max = value;
            Ok(())
        }
        fn max(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.max)
        }
        fn set_current(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.current = value;
            Ok(())
        }
        fn current(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.current)
        }
    }
    #[allow(dead_code, non_camel_case_types)]
    type CorpEmployeePosition = CorpEmployeePositionAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct BitNodeMultipliers {
        #[serde(rename = "DexterityLevelMultiplier")]
        pub dexterity_level_multiplier: f64,
        #[serde(rename = "InfiltrationRep")]
        pub infiltration_rep: f64,
        #[serde(rename = "BladeburnerSkillCost")]
        pub bladeburner_skill_cost: f64,
        #[serde(rename = "HomeComputerRamCost")]
        pub home_computer_ram_cost: f64,
        #[serde(rename = "FactionWorkRepGain")]
        pub faction_work_rep_gain: f64,
        #[serde(rename = "StrengthLevelMultiplier")]
        pub strength_level_multiplier: f64,
        #[serde(rename = "ServerStartingMoney")]
        pub server_starting_money: f64,
        #[serde(rename = "BladeburnerRank")]
        pub bladeburner_rank: f64,
        #[serde(rename = "HacknetNodeMoney")]
        pub hacknet_node_money: f64,
        #[serde(rename = "ServerStartingSecurity")]
        pub server_starting_security: f64,
        #[serde(rename = "FourSigmaMarketDataCost")]
        pub four_sigma_market_data_cost: f64,
        #[serde(rename = "FactionWorkExpGain")]
        pub faction_work_exp_gain: f64,
        #[serde(rename = "CompanyWorkMoney")]
        pub company_work_money: f64,
        #[serde(rename = "PurchasedServerLimit")]
        pub purchased_server_limit: f64,
        #[serde(rename = "GangSoftcap")]
        pub gang_softcap: f64,
        #[serde(rename = "CorporationSoftcap")]
        pub corporation_softcap: f64,
        #[serde(rename = "ServerGrowthRate")]
        pub server_growth_rate: f64,
        #[serde(rename = "AugmentationMoneyCost")]
        pub augmentation_money_cost: f64,
        #[serde(rename = "CorporationValuation")]
        pub corporation_valuation: f64,
        #[serde(rename = "DaedalusAugsRequirement")]
        pub daedalus_augs_requirement: f64,
        #[serde(rename = "ScriptHackMoneyGain")]
        pub script_hack_money_gain: f64,
        #[serde(rename = "CrimeMoney")]
        pub crime_money: f64,
        #[serde(rename = "StaneksGiftExtraSize")]
        pub staneks_gift_extra_size: f64,
        #[serde(rename = "DefenseLevelMultiplier")]
        pub defense_level_multiplier: f64,
        #[serde(rename = "ScriptHackMoney")]
        pub script_hack_money: f64,
        #[serde(rename = "AugmentationRepCost")]
        pub augmentation_rep_cost: f64,
        #[serde(rename = "FactionPassiveRepGain")]
        pub faction_passive_rep_gain: f64,
        #[serde(rename = "FourSigmaMarketDataApiCost")]
        pub four_sigma_market_data_api_cost: f64,
        #[serde(rename = "WorldDaemonDifficulty")]
        pub world_daemon_difficulty: f64,
        #[serde(rename = "CrimeExpGain")]
        pub crime_exp_gain: f64,
        #[serde(rename = "ClassGymExpGain")]
        pub class_gym_exp_gain: f64,
        #[serde(rename = "CompanyWorkExpGain")]
        pub company_work_exp_gain: f64,
        #[serde(rename = "ServerMaxMoney")]
        pub server_max_money: f64,
        #[serde(rename = "ServerWeakenRate")]
        pub server_weaken_rate: f64,
        #[serde(rename = "CodingContractMoney")]
        pub coding_contract_money: f64,
        #[serde(rename = "ManualHackMoney")]
        pub manual_hack_money: f64,
        #[serde(rename = "HackingLevelMultiplier")]
        pub hacking_level_multiplier: f64,
        #[serde(rename = "PurchasedServerSoftcap")]
        pub purchased_server_softcap: f64,
        #[serde(rename = "CharismaLevelMultiplier")]
        pub charisma_level_multiplier: f64,
        #[serde(rename = "InfiltrationMoney")]
        pub infiltration_money: f64,
        #[serde(rename = "HackExpGain")]
        pub hack_exp_gain: f64,
        #[serde(rename = "PurchasedServerCost")]
        pub purchased_server_cost: f64,
        #[serde(rename = "StaneksGiftPowerMultiplier")]
        pub staneks_gift_power_multiplier: f64,
        #[serde(rename = "PurchasedServerMaxRam")]
        pub purchased_server_max_ram: f64,
        #[serde(rename = "AgilityLevelMultiplier")]
        pub agility_level_multiplier: f64,
        #[serde(rename = "RepToDonateToFaction")]
        pub rep_to_donate_to_faction: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait BitNodeMultipliers_Trait {
        fn set_crime_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn crime_money(&self) -> std::result::Result<f64, JsValue>;
        fn set_staneks_gift_power_multiplier(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue>;
        fn staneks_gift_power_multiplier(&self) -> std::result::Result<f64, JsValue>;
        fn set_home_computer_ram_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn home_computer_ram_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_faction_work_rep_gain(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn faction_work_rep_gain(&self) -> std::result::Result<f64, JsValue>;
        fn set_hacking_level_multiplier(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hacking_level_multiplier(&self) -> std::result::Result<f64, JsValue>;
        fn set_staneks_gift_extra_size(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn staneks_gift_extra_size(&self) -> std::result::Result<f64, JsValue>;
        fn set_purchased_server_softcap(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn purchased_server_softcap(&self) -> std::result::Result<f64, JsValue>;
        fn set_daedalus_augs_requirement(&mut self, value: f64)
            -> std::result::Result<(), JsValue>;
        fn daedalus_augs_requirement(&self) -> std::result::Result<f64, JsValue>;
        fn set_charisma_level_multiplier(&mut self, value: f64)
            -> std::result::Result<(), JsValue>;
        fn charisma_level_multiplier(&self) -> std::result::Result<f64, JsValue>;
        fn set_infiltration_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn infiltration_money(&self) -> std::result::Result<f64, JsValue>;
        fn set_agility_level_multiplier(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn agility_level_multiplier(&self) -> std::result::Result<f64, JsValue>;
        fn set_strength_level_multiplier(&mut self, value: f64)
            -> std::result::Result<(), JsValue>;
        fn strength_level_multiplier(&self) -> std::result::Result<f64, JsValue>;
        fn set_server_growth_rate(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn server_growth_rate(&self) -> std::result::Result<f64, JsValue>;
        fn set_server_max_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn server_max_money(&self) -> std::result::Result<f64, JsValue>;
        fn set_company_work_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn company_work_money(&self) -> std::result::Result<f64, JsValue>;
        fn set_rep_to_donate_to_faction(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn rep_to_donate_to_faction(&self) -> std::result::Result<f64, JsValue>;
        fn set_augmentation_rep_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn augmentation_rep_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_crime_exp_gain(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn crime_exp_gain(&self) -> std::result::Result<f64, JsValue>;
        fn set_class_gym_exp_gain(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn class_gym_exp_gain(&self) -> std::result::Result<f64, JsValue>;
        fn set_company_work_exp_gain(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn company_work_exp_gain(&self) -> std::result::Result<f64, JsValue>;
        fn set_faction_passive_rep_gain(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn faction_passive_rep_gain(&self) -> std::result::Result<f64, JsValue>;
        fn set_server_weaken_rate(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn server_weaken_rate(&self) -> std::result::Result<f64, JsValue>;
        fn set_defense_level_multiplier(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn defense_level_multiplier(&self) -> std::result::Result<f64, JsValue>;
        fn set_gang_softcap(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn gang_softcap(&self) -> std::result::Result<f64, JsValue>;
        fn set_manual_hack_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn manual_hack_money(&self) -> std::result::Result<f64, JsValue>;
        fn set_server_starting_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn server_starting_money(&self) -> std::result::Result<f64, JsValue>;
        fn set_hack_exp_gain(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hack_exp_gain(&self) -> std::result::Result<f64, JsValue>;
        fn set_bladeburner_rank(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn bladeburner_rank(&self) -> std::result::Result<f64, JsValue>;
        fn set_coding_contract_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn coding_contract_money(&self) -> std::result::Result<f64, JsValue>;
        fn set_purchased_server_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn purchased_server_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_augmentation_money_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn augmentation_money_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_bladeburner_skill_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn bladeburner_skill_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_four_sigma_market_data_api_cost(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue>;
        fn four_sigma_market_data_api_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_hacknet_node_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hacknet_node_money(&self) -> std::result::Result<f64, JsValue>;
        fn set_corporation_softcap(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn corporation_softcap(&self) -> std::result::Result<f64, JsValue>;
        fn set_corporation_valuation(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn corporation_valuation(&self) -> std::result::Result<f64, JsValue>;
        fn set_four_sigma_market_data_cost(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue>;
        fn four_sigma_market_data_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_dexterity_level_multiplier(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue>;
        fn dexterity_level_multiplier(&self) -> std::result::Result<f64, JsValue>;
        fn set_server_starting_security(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn server_starting_security(&self) -> std::result::Result<f64, JsValue>;
        fn set_world_daemon_difficulty(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn world_daemon_difficulty(&self) -> std::result::Result<f64, JsValue>;
        fn set_infiltration_rep(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn infiltration_rep(&self) -> std::result::Result<f64, JsValue>;
        fn set_script_hack_money_gain(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn script_hack_money_gain(&self) -> std::result::Result<f64, JsValue>;
        fn set_purchased_server_max_ram(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn purchased_server_max_ram(&self) -> std::result::Result<f64, JsValue>;
        fn set_faction_work_exp_gain(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn faction_work_exp_gain(&self) -> std::result::Result<f64, JsValue>;
        fn set_script_hack_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn script_hack_money(&self) -> std::result::Result<f64, JsValue>;
        fn set_purchased_server_limit(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn purchased_server_limit(&self) -> std::result::Result<f64, JsValue>;
    }
    impl BitNodeMultipliers_Trait for BitNodeMultipliers {
        fn set_crime_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.crime_money = value;
            Ok(())
        }
        fn crime_money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.crime_money)
        }
        fn set_staneks_gift_power_multiplier(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue> {
            self.staneks_gift_power_multiplier = value;
            Ok(())
        }
        fn staneks_gift_power_multiplier(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.staneks_gift_power_multiplier)
        }
        fn set_home_computer_ram_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.home_computer_ram_cost = value;
            Ok(())
        }
        fn home_computer_ram_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.home_computer_ram_cost)
        }
        fn set_faction_work_rep_gain(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.faction_work_rep_gain = value;
            Ok(())
        }
        fn faction_work_rep_gain(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.faction_work_rep_gain)
        }
        fn set_hacking_level_multiplier(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hacking_level_multiplier = value;
            Ok(())
        }
        fn hacking_level_multiplier(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacking_level_multiplier)
        }
        fn set_staneks_gift_extra_size(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.staneks_gift_extra_size = value;
            Ok(())
        }
        fn staneks_gift_extra_size(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.staneks_gift_extra_size)
        }
        fn set_purchased_server_softcap(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.purchased_server_softcap = value;
            Ok(())
        }
        fn purchased_server_softcap(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.purchased_server_softcap)
        }
        fn set_daedalus_augs_requirement(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue> {
            self.daedalus_augs_requirement = value;
            Ok(())
        }
        fn daedalus_augs_requirement(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.daedalus_augs_requirement)
        }
        fn set_charisma_level_multiplier(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue> {
            self.charisma_level_multiplier = value;
            Ok(())
        }
        fn charisma_level_multiplier(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.charisma_level_multiplier)
        }
        fn set_infiltration_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.infiltration_money = value;
            Ok(())
        }
        fn infiltration_money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.infiltration_money)
        }
        fn set_agility_level_multiplier(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.agility_level_multiplier = value;
            Ok(())
        }
        fn agility_level_multiplier(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.agility_level_multiplier)
        }
        fn set_strength_level_multiplier(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue> {
            self.strength_level_multiplier = value;
            Ok(())
        }
        fn strength_level_multiplier(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.strength_level_multiplier)
        }
        fn set_server_growth_rate(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.server_growth_rate = value;
            Ok(())
        }
        fn server_growth_rate(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.server_growth_rate)
        }
        fn set_server_max_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.server_max_money = value;
            Ok(())
        }
        fn server_max_money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.server_max_money)
        }
        fn set_company_work_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.company_work_money = value;
            Ok(())
        }
        fn company_work_money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.company_work_money)
        }
        fn set_rep_to_donate_to_faction(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.rep_to_donate_to_faction = value;
            Ok(())
        }
        fn rep_to_donate_to_faction(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.rep_to_donate_to_faction)
        }
        fn set_augmentation_rep_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.augmentation_rep_cost = value;
            Ok(())
        }
        fn augmentation_rep_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.augmentation_rep_cost)
        }
        fn set_crime_exp_gain(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.crime_exp_gain = value;
            Ok(())
        }
        fn crime_exp_gain(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.crime_exp_gain)
        }
        fn set_class_gym_exp_gain(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.class_gym_exp_gain = value;
            Ok(())
        }
        fn class_gym_exp_gain(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.class_gym_exp_gain)
        }
        fn set_company_work_exp_gain(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.company_work_exp_gain = value;
            Ok(())
        }
        fn company_work_exp_gain(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.company_work_exp_gain)
        }
        fn set_faction_passive_rep_gain(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.faction_passive_rep_gain = value;
            Ok(())
        }
        fn faction_passive_rep_gain(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.faction_passive_rep_gain)
        }
        fn set_server_weaken_rate(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.server_weaken_rate = value;
            Ok(())
        }
        fn server_weaken_rate(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.server_weaken_rate)
        }
        fn set_defense_level_multiplier(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.defense_level_multiplier = value;
            Ok(())
        }
        fn defense_level_multiplier(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.defense_level_multiplier)
        }
        fn set_gang_softcap(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.gang_softcap = value;
            Ok(())
        }
        fn gang_softcap(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.gang_softcap)
        }
        fn set_manual_hack_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.manual_hack_money = value;
            Ok(())
        }
        fn manual_hack_money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.manual_hack_money)
        }
        fn set_server_starting_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.server_starting_money = value;
            Ok(())
        }
        fn server_starting_money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.server_starting_money)
        }
        fn set_hack_exp_gain(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hack_exp_gain = value;
            Ok(())
        }
        fn hack_exp_gain(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hack_exp_gain)
        }
        fn set_bladeburner_rank(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.bladeburner_rank = value;
            Ok(())
        }
        fn bladeburner_rank(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.bladeburner_rank)
        }
        fn set_coding_contract_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.coding_contract_money = value;
            Ok(())
        }
        fn coding_contract_money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.coding_contract_money)
        }
        fn set_purchased_server_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.purchased_server_cost = value;
            Ok(())
        }
        fn purchased_server_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.purchased_server_cost)
        }
        fn set_augmentation_money_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.augmentation_money_cost = value;
            Ok(())
        }
        fn augmentation_money_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.augmentation_money_cost)
        }
        fn set_bladeburner_skill_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.bladeburner_skill_cost = value;
            Ok(())
        }
        fn bladeburner_skill_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.bladeburner_skill_cost)
        }
        fn set_four_sigma_market_data_api_cost(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue> {
            self.four_sigma_market_data_api_cost = value;
            Ok(())
        }
        fn four_sigma_market_data_api_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.four_sigma_market_data_api_cost)
        }
        fn set_hacknet_node_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hacknet_node_money = value;
            Ok(())
        }
        fn hacknet_node_money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacknet_node_money)
        }
        fn set_corporation_softcap(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.corporation_softcap = value;
            Ok(())
        }
        fn corporation_softcap(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.corporation_softcap)
        }
        fn set_corporation_valuation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.corporation_valuation = value;
            Ok(())
        }
        fn corporation_valuation(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.corporation_valuation)
        }
        fn set_four_sigma_market_data_cost(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue> {
            self.four_sigma_market_data_cost = value;
            Ok(())
        }
        fn four_sigma_market_data_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.four_sigma_market_data_cost)
        }
        fn set_dexterity_level_multiplier(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue> {
            self.dexterity_level_multiplier = value;
            Ok(())
        }
        fn dexterity_level_multiplier(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.dexterity_level_multiplier)
        }
        fn set_server_starting_security(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.server_starting_security = value;
            Ok(())
        }
        fn server_starting_security(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.server_starting_security)
        }
        fn set_world_daemon_difficulty(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.world_daemon_difficulty = value;
            Ok(())
        }
        fn world_daemon_difficulty(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.world_daemon_difficulty)
        }
        fn set_infiltration_rep(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.infiltration_rep = value;
            Ok(())
        }
        fn infiltration_rep(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.infiltration_rep)
        }
        fn set_script_hack_money_gain(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.script_hack_money_gain = value;
            Ok(())
        }
        fn script_hack_money_gain(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.script_hack_money_gain)
        }
        fn set_purchased_server_max_ram(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.purchased_server_max_ram = value;
            Ok(())
        }
        fn purchased_server_max_ram(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.purchased_server_max_ram)
        }
        fn set_faction_work_exp_gain(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.faction_work_exp_gain = value;
            Ok(())
        }
        fn faction_work_exp_gain(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.faction_work_exp_gain)
        }
        fn set_script_hack_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.script_hack_money = value;
            Ok(())
        }
        fn script_hack_money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.script_hack_money)
        }
        fn set_purchased_server_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.purchased_server_limit = value;
            Ok(())
        }
        fn purchased_server_limit(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.purchased_server_limit)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsPromptParamsOptionsType {
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsArgs {
        Bool(bool),
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Player {
        #[serde(rename = "jobs")]
        pub jobs: std::collections::HashMap<String, String>,
        #[serde(rename = "hp")]
        pub hp: Hp,
        #[serde(rename = "location")]
        pub location: String,
        #[serde(rename = "exp")]
        pub exp: Skills,
        #[serde(rename = "city")]
        pub city: CityName,
        #[serde(rename = "skills")]
        pub skills: Skills,
        #[serde(rename = "totalPlaytime")]
        pub total_playtime: f64,
        #[serde(rename = "money")]
        pub money: f64,
        #[serde(rename = "factions")]
        pub factions: Vec<String>,
        #[serde(rename = "entropy")]
        pub entropy: f64,
        #[serde(rename = "mults")]
        pub mults: Multipliers,
        #[serde(rename = "numPeopleKilled")]
        pub num_people_killed: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait Player_Trait: Person_Trait {
        fn set_total_playtime(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn total_playtime(&self) -> std::result::Result<f64, JsValue>;
        fn set_location(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn location(&self) -> std::result::Result<String, JsValue>;
        fn set_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn money(&self) -> std::result::Result<f64, JsValue>;
        fn set_jobs(
            &mut self,
            value: std::collections::HashMap<String, String>,
        ) -> std::result::Result<(), JsValue>;
        fn jobs(&self) -> std::result::Result<std::collections::HashMap<String, String>, JsValue>;
        fn set_entropy(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn entropy(&self) -> std::result::Result<f64, JsValue>;
        fn set_factions(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue>;
        fn factions(&self) -> std::result::Result<Vec<String>, JsValue>;
        fn set_num_people_killed(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn num_people_killed(&self) -> std::result::Result<f64, JsValue>;
    }
    impl Person_Trait for Player {
        fn set_hp(&mut self, value: Hp) -> std::result::Result<(), JsValue> {
            self.hp = value;
            Ok(())
        }
        fn hp(&self) -> std::result::Result<Hp, JsValue> {
            Ok(self.hp.clone())
        }
        fn set_exp(&mut self, value: Skills) -> std::result::Result<(), JsValue> {
            self.exp = value;
            Ok(())
        }
        fn exp(&self) -> std::result::Result<Skills, JsValue> {
            Ok(self.exp.clone())
        }
        fn set_skills(&mut self, value: Skills) -> std::result::Result<(), JsValue> {
            self.skills = value;
            Ok(())
        }
        fn skills(&self) -> std::result::Result<Skills, JsValue> {
            Ok(self.skills.clone())
        }
        fn set_mults(&mut self, value: Multipliers) -> std::result::Result<(), JsValue> {
            self.mults = value;
            Ok(())
        }
        fn mults(&self) -> std::result::Result<Multipliers, JsValue> {
            Ok(self.mults.clone())
        }
        fn set_city(&mut self, value: CityName) -> std::result::Result<(), JsValue> {
            self.city = value;
            Ok(())
        }
        fn city(&self) -> std::result::Result<CityName, JsValue> {
            Ok(self.city.clone())
        }
    }
    impl Player_Trait for Player
    where
        Player: Person_Trait,
    {
        fn set_total_playtime(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.total_playtime = value;
            Ok(())
        }
        fn total_playtime(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.total_playtime)
        }
        fn set_location(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.location = value;
            Ok(())
        }
        fn location(&self) -> std::result::Result<String, JsValue> {
            Ok(self.location.clone())
        }
        fn set_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.money = value;
            Ok(())
        }
        fn money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.money)
        }
        fn set_jobs(
            &mut self,
            value: std::collections::HashMap<String, String>,
        ) -> std::result::Result<(), JsValue> {
            self.jobs = value;
            Ok(())
        }
        fn jobs(&self) -> std::result::Result<std::collections::HashMap<String, String>, JsValue> {
            Ok(self.jobs.clone())
        }
        fn set_entropy(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.entropy = value;
            Ok(())
        }
        fn entropy(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.entropy)
        }
        fn set_factions(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue> {
            self.factions = value;
            Ok(())
        }
        fn factions(&self) -> std::result::Result<Vec<String>, JsValue> {
            Ok(self.factions.clone())
        }
        fn set_num_people_killed(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.num_people_killed = value;
            Ok(())
        }
        fn num_people_killed(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.num_people_killed)
        }
    }
    #[allow(dead_code, non_camel_case_types)]
    type CorpStateName = CorpStateNameAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Formulas {
        #[serde(
            rename = "mockPerson",
            serialize_with = "Formulas::__TSB__serialize_mock_person",
            deserialize_with = "Formulas::__TSB__deserialize_mock_person"
        )]
        pub mock_person: std::rc::Rc<dyn Fn() -> std::result::Result<Person, JsValue>>,
        #[serde(rename = "work")]
        pub work: WorkFormulas,
        #[serde(rename = "hacking")]
        pub hacking: HackingFormulas,
        #[serde(rename = "reputation")]
        pub reputation: ReputationFormulas,
        #[serde(rename = "gang")]
        pub gang: GangFormulas,
        #[serde(rename = "hacknetServers")]
        pub hacknet_servers: HacknetServersFormulas,
        #[serde(rename = "hacknetNodes")]
        pub hacknet_nodes: HacknetNodesFormulas,
        #[serde(
            rename = "mockServer",
            serialize_with = "Formulas::__TSB__serialize_mock_server",
            deserialize_with = "Formulas::__TSB__deserialize_mock_server"
        )]
        pub mock_server: std::rc::Rc<dyn Fn() -> std::result::Result<Server, JsValue>>,
        #[serde(rename = "skills")]
        pub skills: SkillsFormulas,
        #[serde(
            rename = "mockPlayer",
            serialize_with = "Formulas::__TSB__serialize_mock_player",
            deserialize_with = "Formulas::__TSB__deserialize_mock_player"
        )]
        pub mock_player: std::rc::Rc<dyn Fn() -> std::result::Result<Player, JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait Formulas_Trait {
        fn set_mock_player(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Player, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn mock_player(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Player, JsValue>>,
            JsValue,
        >;
        fn set_mock_person(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Person, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn mock_person(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Person, JsValue>>,
            JsValue,
        >;
        fn set_mock_server(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Server, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn mock_server(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Server, JsValue>>,
            JsValue,
        >;
        fn set_hacknet_servers(
            &mut self,
            value: HacknetServersFormulas,
        ) -> std::result::Result<(), JsValue>;
        fn hacknet_servers(&self) -> std::result::Result<HacknetServersFormulas, JsValue>;
        fn set_hacknet_nodes(
            &mut self,
            value: HacknetNodesFormulas,
        ) -> std::result::Result<(), JsValue>;
        fn hacknet_nodes(&self) -> std::result::Result<HacknetNodesFormulas, JsValue>;
        fn set_gang(&mut self, value: GangFormulas) -> std::result::Result<(), JsValue>;
        fn gang(&self) -> std::result::Result<GangFormulas, JsValue>;
        fn set_skills(&mut self, value: SkillsFormulas) -> std::result::Result<(), JsValue>;
        fn skills(&self) -> std::result::Result<SkillsFormulas, JsValue>;
        fn set_work(&mut self, value: WorkFormulas) -> std::result::Result<(), JsValue>;
        fn work(&self) -> std::result::Result<WorkFormulas, JsValue>;
        fn set_reputation(&mut self, value: ReputationFormulas)
            -> std::result::Result<(), JsValue>;
        fn reputation(&self) -> std::result::Result<ReputationFormulas, JsValue>;
        fn set_hacking(&mut self, value: HackingFormulas) -> std::result::Result<(), JsValue>;
        fn hacking(&self) -> std::result::Result<HackingFormulas, JsValue>;
    }
    impl Formulas_Trait for Formulas {
        fn set_mock_player(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Player, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.mock_player = value;
            Ok(())
        }
        fn mock_player(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Player, JsValue>>,
            JsValue,
        > {
            Ok(self.mock_player.clone())
        }
        fn set_mock_person(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Person, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.mock_person = value;
            Ok(())
        }
        fn mock_person(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Person, JsValue>>,
            JsValue,
        > {
            Ok(self.mock_person.clone())
        }
        fn set_mock_server(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Server, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.mock_server = value;
            Ok(())
        }
        fn mock_server(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Server, JsValue>>,
            JsValue,
        > {
            Ok(self.mock_server.clone())
        }
        fn set_hacknet_servers(
            &mut self,
            value: HacknetServersFormulas,
        ) -> std::result::Result<(), JsValue> {
            self.hacknet_servers = value;
            Ok(())
        }
        fn hacknet_servers(&self) -> std::result::Result<HacknetServersFormulas, JsValue> {
            Ok(self.hacknet_servers.clone())
        }
        fn set_hacknet_nodes(
            &mut self,
            value: HacknetNodesFormulas,
        ) -> std::result::Result<(), JsValue> {
            self.hacknet_nodes = value;
            Ok(())
        }
        fn hacknet_nodes(&self) -> std::result::Result<HacknetNodesFormulas, JsValue> {
            Ok(self.hacknet_nodes.clone())
        }
        fn set_gang(&mut self, value: GangFormulas) -> std::result::Result<(), JsValue> {
            self.gang = value;
            Ok(())
        }
        fn gang(&self) -> std::result::Result<GangFormulas, JsValue> {
            Ok(self.gang.clone())
        }
        fn set_skills(&mut self, value: SkillsFormulas) -> std::result::Result<(), JsValue> {
            self.skills = value;
            Ok(())
        }
        fn skills(&self) -> std::result::Result<SkillsFormulas, JsValue> {
            Ok(self.skills.clone())
        }
        fn set_work(&mut self, value: WorkFormulas) -> std::result::Result<(), JsValue> {
            self.work = value;
            Ok(())
        }
        fn work(&self) -> std::result::Result<WorkFormulas, JsValue> {
            Ok(self.work.clone())
        }
        fn set_reputation(
            &mut self,
            value: ReputationFormulas,
        ) -> std::result::Result<(), JsValue> {
            self.reputation = value;
            Ok(())
        }
        fn reputation(&self) -> std::result::Result<ReputationFormulas, JsValue> {
            Ok(self.reputation.clone())
        }
        fn set_hacking(&mut self, value: HackingFormulas) -> std::result::Result<(), JsValue> {
            self.hacking = value;
            Ok(())
        }
        fn hacking(&self) -> std::result::Result<HackingFormulas, JsValue> {
            Ok(self.hacking.clone())
        }
    }
    impl Formulas {
        #[allow(non_snake_case)]
        fn __TSB__serialize_mock_person<S>(
            mock_person: &std::rc::Rc<dyn Fn() -> std::result::Result<Person, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let mock_person = mock_person.clone();
            let mock_person_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = mock_person()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &mock_person_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_mock_server<S>(
            mock_server: &std::rc::Rc<dyn Fn() -> std::result::Result<Server, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let mock_server = mock_server.clone();
            let mock_server_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = mock_server()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &mock_server_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_mock_player<S>(
            mock_player: &std::rc::Rc<dyn Fn() -> std::result::Result<Player, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let mock_player = mock_player.clone();
            let mock_player_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = mock_player()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &mock_player_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_mock_person<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Person, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let mock_person: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            mock_person
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Person, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_mock_server<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Server, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let mock_server: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            mock_server
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Server, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_mock_player<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Player, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let mock_player: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            mock_player
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Player, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct SkillsFormulas {
        #[serde(
            rename = "calculateExp",
            serialize_with = "SkillsFormulas::__TSB__serialize_calculate_exp",
            deserialize_with = "SkillsFormulas::__TSB__deserialize_calculate_exp"
        )]
        pub calculate_exp: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "calculateSkill",
            serialize_with = "SkillsFormulas::__TSB__serialize_calculate_skill",
            deserialize_with = "SkillsFormulas::__TSB__deserialize_calculate_skill"
        )]
        pub calculate_skill: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait SkillsFormulas_Trait {
        fn set_calculate_skill(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn calculate_skill(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_calculate_exp(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn calculate_exp(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
    }
    impl SkillsFormulas_Trait for SkillsFormulas {
        fn set_calculate_skill(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.calculate_skill = value;
            Ok(())
        }
        fn calculate_skill(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.calculate_skill.clone())
        }
        fn set_calculate_exp(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.calculate_exp = value;
            Ok(())
        }
        fn calculate_exp(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.calculate_exp.clone())
        }
    }
    impl SkillsFormulas {
        #[allow(non_snake_case)]
        fn __TSB__serialize_calculate_exp<S>(
            calculate_exp: &std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let calculate_exp = calculate_exp.clone();
            let calculate_exp_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = calculate_exp(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &calculate_exp_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_calculate_skill<S>(
            calculate_skill: &std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let calculate_skill = calculate_skill.clone();
            let calculate_skill_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = calculate_skill(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &calculate_skill_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_calculate_exp<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let calculate_exp: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            calculate_exp
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_calculate_skill<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let calculate_skill: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            calculate_skill
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct SleeveCrimeTaskAliased {
        #[serde(rename = "cyclesWorked")]
        pub cycles_worked: f64,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "cyclesNeeded")]
        pub cycles_needed: f64,
        #[serde(rename = "crimeType")]
        pub crime_type: CrimeType,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait SleeveCrimeTaskAliased_Trait {
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn type_(&self) -> std::result::Result<String, JsValue>;
        fn set_crime_type(&mut self, value: CrimeType) -> std::result::Result<(), JsValue>;
        fn crime_type(&self) -> std::result::Result<CrimeType, JsValue>;
        fn set_cycles_needed(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cycles_needed(&self) -> std::result::Result<f64, JsValue>;
        fn set_cycles_worked(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cycles_worked(&self) -> std::result::Result<f64, JsValue>;
    }
    impl SleeveCrimeTaskAliased_Trait for SleeveCrimeTaskAliased {
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.type_ = value;
            Ok(())
        }
        fn type_(&self) -> std::result::Result<String, JsValue> {
            Ok(self.type_.clone())
        }
        fn set_crime_type(&mut self, value: CrimeType) -> std::result::Result<(), JsValue> {
            self.crime_type = value;
            Ok(())
        }
        fn crime_type(&self) -> std::result::Result<CrimeType, JsValue> {
            Ok(self.crime_type.clone())
        }
        fn set_cycles_needed(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cycles_needed = value;
            Ok(())
        }
        fn cycles_needed(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cycles_needed)
        }
        fn set_cycles_worked(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cycles_worked = value;
            Ok(())
        }
        fn cycles_worked(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cycles_worked)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NetscriptPortTryWriteParamsValue {
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct SleeveInfiltrateTaskAliased {
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "cyclesNeeded")]
        pub cycles_needed: f64,
        #[serde(rename = "cyclesWorked")]
        pub cycles_worked: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait SleeveInfiltrateTaskAliased_Trait {
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn type_(&self) -> std::result::Result<String, JsValue>;
        fn set_cycles_worked(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cycles_worked(&self) -> std::result::Result<f64, JsValue>;
        fn set_cycles_needed(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cycles_needed(&self) -> std::result::Result<f64, JsValue>;
    }
    impl SleeveInfiltrateTaskAliased_Trait for SleeveInfiltrateTaskAliased {
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.type_ = value;
            Ok(())
        }
        fn type_(&self) -> std::result::Result<String, JsValue> {
            Ok(self.type_.clone())
        }
        fn set_cycles_worked(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cycles_worked = value;
            Ok(())
        }
        fn cycles_worked(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cycles_worked)
        }
        fn set_cycles_needed(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cycles_needed = value;
            Ok(())
        }
        fn cycles_needed(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cycles_needed)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsSpawnParamsThreadOrOptions {
        RunOptions(RunOptions),
        F64(f64),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct RecentScript {
        #[serde(rename = "filename")]
        pub filename: String,
        #[serde(rename = "offlineRunningTime")]
        pub offline_running_time: f64,
        #[serde(rename = "ramUsage")]
        pub ram_usage: f64,
        #[serde(rename = "timeOfDeath")]
        pub time_of_death: js_sys::Date,
        #[serde(rename = "temporary")]
        pub temporary: bool,
        #[serde(rename = "onlineExpGained")]
        pub online_exp_gained: f64,
        #[serde(rename = "tailProperties")]
        pub tail_properties: RunningScriptTailProperties,
        #[serde(rename = "threads")]
        pub threads: f64,
        #[serde(rename = "logs")]
        pub logs: Vec<String>,
        #[serde(rename = "args")]
        pub args: Vec<RunningScriptArgs>,
        #[serde(rename = "onlineRunningTime")]
        pub online_running_time: f64,
        #[serde(rename = "server")]
        pub server: String,
        #[serde(rename = "pid")]
        pub pid: f64,
        #[serde(rename = "offlineMoneyMade")]
        pub offline_money_made: f64,
        #[serde(rename = "title")]
        pub title: String,
        #[serde(rename = "offlineExpGained")]
        pub offline_exp_gained: f64,
        #[serde(rename = "onlineMoneyMade")]
        pub online_money_made: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait RecentScript_Trait: RunningScript_Trait {
        fn set_time_of_death(&mut self, value: js_sys::Date) -> std::result::Result<(), JsValue>;
        fn time_of_death(&self) -> std::result::Result<js_sys::Date, JsValue>;
    }
    impl RunningScript_Trait for RecentScript {
        fn set_online_exp_gained(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.online_exp_gained = value;
            Ok(())
        }
        fn online_exp_gained(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.online_exp_gained)
        }
        fn set_temporary(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.temporary = value;
            Ok(())
        }
        fn temporary(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.temporary)
        }
        fn set_offline_exp_gained(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.offline_exp_gained = value;
            Ok(())
        }
        fn offline_exp_gained(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.offline_exp_gained)
        }
        fn set_tail_properties(
            &mut self,
            value: RunningScriptTailProperties,
        ) -> std::result::Result<(), JsValue> {
            self.tail_properties = value;
            Ok(())
        }
        fn tail_properties(&self) -> std::result::Result<RunningScriptTailProperties, JsValue> {
            Ok(self.tail_properties.clone())
        }
        fn set_filename(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.filename = value;
            Ok(())
        }
        fn filename(&self) -> std::result::Result<String, JsValue> {
            Ok(self.filename.clone())
        }
        fn set_title(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.title = value;
            Ok(())
        }
        fn title(&self) -> std::result::Result<String, JsValue> {
            Ok(self.title.clone())
        }
        fn set_threads(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.threads = value;
            Ok(())
        }
        fn threads(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.threads)
        }
        fn set_offline_running_time(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.offline_running_time = value;
            Ok(())
        }
        fn offline_running_time(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.offline_running_time)
        }
        fn set_server(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.server = value;
            Ok(())
        }
        fn server(&self) -> std::result::Result<String, JsValue> {
            Ok(self.server.clone())
        }
        fn set_logs(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue> {
            self.logs = value;
            Ok(())
        }
        fn logs(&self) -> std::result::Result<Vec<String>, JsValue> {
            Ok(self.logs.clone())
        }
        fn set_offline_money_made(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.offline_money_made = value;
            Ok(())
        }
        fn offline_money_made(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.offline_money_made)
        }
        fn set_ram_usage(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.ram_usage = value;
            Ok(())
        }
        fn ram_usage(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.ram_usage)
        }
        fn set_pid(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.pid = value;
            Ok(())
        }
        fn pid(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.pid)
        }
        fn set_online_running_time(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.online_running_time = value;
            Ok(())
        }
        fn online_running_time(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.online_running_time)
        }
        fn set_online_money_made(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.online_money_made = value;
            Ok(())
        }
        fn online_money_made(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.online_money_made)
        }
        fn set_args(&mut self, value: Vec<RunningScriptArgs>) -> std::result::Result<(), JsValue> {
            self.args = value;
            Ok(())
        }
        fn args(&self) -> std::result::Result<Vec<RunningScriptArgs>, JsValue> {
            Ok(self.args.clone())
        }
    }
    impl RecentScript_Trait for RecentScript
    where
        RecentScript: RunningScript_Trait,
    {
        fn set_time_of_death(&mut self, value: js_sys::Date) -> std::result::Result<(), JsValue> {
            self.time_of_death = value;
            Ok(())
        }
        fn time_of_death(&self) -> std::result::Result<js_sys::Date, JsValue> {
            Ok(self.time_of_death.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct WorkFormulas {
        #[serde(
            rename = "companyGains",
            serialize_with = "WorkFormulas::__TSB__serialize_company_gains",
            deserialize_with = "WorkFormulas::__TSB__deserialize_company_gains"
        )]
        pub company_gains: std::rc::Rc<
            dyn Fn(Person, String, JobName, f64) -> std::result::Result<WorkStats, JsValue>,
        >,
        #[serde(
            rename = "gymGains",
            serialize_with = "WorkFormulas::__TSB__serialize_gym_gains",
            deserialize_with = "WorkFormulas::__TSB__deserialize_gym_gains"
        )]
        pub gym_gains:
            std::rc::Rc<dyn Fn(Person, GymType, String) -> std::result::Result<WorkStats, JsValue>>,
        #[serde(
            rename = "crimeSuccessChance",
            serialize_with = "WorkFormulas::__TSB__serialize_crime_success_chance",
            deserialize_with = "WorkFormulas::__TSB__deserialize_crime_success_chance"
        )]
        pub crime_success_chance:
            std::rc::Rc<dyn Fn(Person, CrimeType) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "universityGains",
            serialize_with = "WorkFormulas::__TSB__serialize_university_gains",
            deserialize_with = "WorkFormulas::__TSB__deserialize_university_gains"
        )]
        pub university_gains: std::rc::Rc<
            dyn Fn(Person, UniversityClassType, String) -> std::result::Result<WorkStats, JsValue>,
        >,
        #[serde(
            rename = "factionGains",
            serialize_with = "WorkFormulas::__TSB__serialize_faction_gains",
            deserialize_with = "WorkFormulas::__TSB__deserialize_faction_gains"
        )]
        pub faction_gains: std::rc::Rc<
            dyn Fn(Person, FactionWorkType, f64) -> std::result::Result<WorkStats, JsValue>,
        >,
        #[serde(
            rename = "crimeGains",
            serialize_with = "WorkFormulas::__TSB__serialize_crime_gains",
            deserialize_with = "WorkFormulas::__TSB__deserialize_crime_gains"
        )]
        pub crime_gains:
            std::rc::Rc<dyn Fn(Person, CrimeType) -> std::result::Result<WorkStats, JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait WorkFormulas_Trait {
        fn set_university_gains(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    Person,
                    UniversityClassType,
                    String,
                ) -> std::result::Result<WorkStats, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn university_gains(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    Person,
                    UniversityClassType,
                    String,
                ) -> std::result::Result<WorkStats, JsValue>,
            >,
            JsValue,
        >;
        fn set_faction_gains(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(Person, FactionWorkType, f64) -> std::result::Result<WorkStats, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn faction_gains(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(Person, FactionWorkType, f64) -> std::result::Result<WorkStats, JsValue>,
            >,
            JsValue,
        >;
        fn set_crime_success_chance(
            &mut self,
            value: std::rc::Rc<dyn Fn(Person, CrimeType) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn crime_success_chance(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Person, CrimeType) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_crime_gains(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(Person, CrimeType) -> std::result::Result<WorkStats, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn crime_gains(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Person, CrimeType) -> std::result::Result<WorkStats, JsValue>>,
            JsValue,
        >;
        fn set_company_gains(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(Person, String, JobName, f64) -> std::result::Result<WorkStats, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn company_gains(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(Person, String, JobName, f64) -> std::result::Result<WorkStats, JsValue>,
            >,
            JsValue,
        >;
        fn set_gym_gains(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(Person, GymType, String) -> std::result::Result<WorkStats, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn gym_gains(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Person, GymType, String) -> std::result::Result<WorkStats, JsValue>>,
            JsValue,
        >;
    }
    impl WorkFormulas_Trait for WorkFormulas {
        fn set_university_gains(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    Person,
                    UniversityClassType,
                    String,
                ) -> std::result::Result<WorkStats, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.university_gains = value;
            Ok(())
        }
        fn university_gains(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    Person,
                    UniversityClassType,
                    String,
                ) -> std::result::Result<WorkStats, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.university_gains.clone())
        }
        fn set_faction_gains(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(Person, FactionWorkType, f64) -> std::result::Result<WorkStats, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.faction_gains = value;
            Ok(())
        }
        fn faction_gains(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(Person, FactionWorkType, f64) -> std::result::Result<WorkStats, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.faction_gains.clone())
        }
        fn set_crime_success_chance(
            &mut self,
            value: std::rc::Rc<dyn Fn(Person, CrimeType) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.crime_success_chance = value;
            Ok(())
        }
        fn crime_success_chance(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Person, CrimeType) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.crime_success_chance.clone())
        }
        fn set_crime_gains(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(Person, CrimeType) -> std::result::Result<WorkStats, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.crime_gains = value;
            Ok(())
        }
        fn crime_gains(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Person, CrimeType) -> std::result::Result<WorkStats, JsValue>>,
            JsValue,
        > {
            Ok(self.crime_gains.clone())
        }
        fn set_company_gains(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(Person, String, JobName, f64) -> std::result::Result<WorkStats, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.company_gains = value;
            Ok(())
        }
        fn company_gains(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(Person, String, JobName, f64) -> std::result::Result<WorkStats, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.company_gains.clone())
        }
        fn set_gym_gains(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(Person, GymType, String) -> std::result::Result<WorkStats, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.gym_gains = value;
            Ok(())
        }
        fn gym_gains(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Person, GymType, String) -> std::result::Result<WorkStats, JsValue>>,
            JsValue,
        > {
            Ok(self.gym_gains.clone())
        }
    }
    impl WorkFormulas {
        #[allow(non_snake_case)]
        fn __TSB__serialize_company_gains<S>(
            company_gains: &std::rc::Rc<
                dyn Fn(Person, String, JobName, f64) -> std::result::Result<WorkStats, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let company_gains = company_gains.clone();
            let company_gains_closure = Closure::wrap(Box::new(
                move |arg0: JsValue,
                      arg1: String,
                      arg2: JsValue,
                      arg3: f64|
                      -> std::result::Result<JsValue, JsValue> {
                    let result = company_gains(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        arg1,
                        ts_bindgen_rt::from_jsvalue(&arg2).map_err(ts_bindgen_rt::Error::from)?,
                        arg3,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<
                    dyn Fn(JsValue, String, JsValue, f64) -> std::result::Result<JsValue, JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &company_gains_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_gym_gains<S>(
            gym_gains: &std::rc::Rc<
                dyn Fn(Person, GymType, String) -> std::result::Result<WorkStats, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let gym_gains = gym_gains.clone();
            let gym_gains_closure = Closure::wrap(Box::new(
                move |arg0: JsValue,
                      arg1: JsValue,
                      arg2: String|
                      -> std::result::Result<JsValue, JsValue> {
                    let result = gym_gains(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(JsValue, JsValue, String) -> std::result::Result<JsValue, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &gym_gains_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_crime_success_chance<S>(
            crime_success_chance: &std::rc::Rc<
                dyn Fn(Person, CrimeType) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let crime_success_chance = crime_success_chance.clone();
            let crime_success_chance_closure = Closure::wrap(Box::new(
                move |arg0: JsValue, arg1: JsValue| -> std::result::Result<f64, JsValue> {
                    let result = crime_success_chance(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue, JsValue) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &crime_success_chance_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_university_gains<S>(
            university_gains: &std::rc::Rc<
                dyn Fn(
                    Person,
                    UniversityClassType,
                    String,
                ) -> std::result::Result<WorkStats, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let university_gains = university_gains.clone();
            let university_gains_closure = Closure::wrap(Box::new(
                move |arg0: JsValue,
                      arg1: JsValue,
                      arg2: String|
                      -> std::result::Result<JsValue, JsValue> {
                    let result = university_gains(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(JsValue, JsValue, String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &university_gains_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_faction_gains<S>(
            faction_gains: &std::rc::Rc<
                dyn Fn(Person, FactionWorkType, f64) -> std::result::Result<WorkStats, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let faction_gains = faction_gains.clone();
            let faction_gains_closure = Closure::wrap(Box::new(
                move |arg0: JsValue,
                      arg1: JsValue,
                      arg2: f64|
                      -> std::result::Result<JsValue, JsValue> {
                    let result = faction_gains(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(JsValue, JsValue, f64) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &faction_gains_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_crime_gains<S>(
            crime_gains: &std::rc::Rc<
                dyn Fn(Person, CrimeType) -> std::result::Result<WorkStats, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let crime_gains = crime_gains.clone();
            let crime_gains_closure = Closure::wrap(Box::new(
                move |arg0: JsValue, arg1: JsValue| -> std::result::Result<JsValue, JsValue> {
                    let result = crime_gains(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(JsValue, JsValue) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &crime_gains_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_company_gains<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(Person, String, JobName, f64) -> std::result::Result<WorkStats, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let company_gains: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            company_gains
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: Person, arg1: String, arg2: JobName, arg3: f64| {
                            let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                            let arg1 = JsValue::from(arg1);
                            let arg2 = ts_bindgen_rt::to_jsvalue(&arg2);
                            let arg3 = JsValue::from(arg3);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                Person,
                                String,
                                JobName,
                                f64,
                            )
                                -> std::result::Result<WorkStats, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_gym_gains<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Person, GymType, String) -> std::result::Result<WorkStats, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let gym_gains: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            gym_gains
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: Person, arg1: GymType, arg2: String| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                Person,
                                GymType,
                                String,
                            )
                                -> std::result::Result<WorkStats, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_crime_success_chance<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Person, CrimeType) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let crime_success_chance: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            crime_success_chance
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: Person, arg1: CrimeType| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(Person, CrimeType) -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_university_gains<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    Person,
                    UniversityClassType,
                    String,
                ) -> std::result::Result<WorkStats, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let university_gains: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            university_gains
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: Person, arg1: UniversityClassType, arg2: String| {
                            let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                Person,
                                UniversityClassType,
                                String,
                            )
                                -> std::result::Result<WorkStats, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_faction_gains<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(Person, FactionWorkType, f64) -> std::result::Result<WorkStats, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let faction_gains: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            faction_gains
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: Person, arg1: FactionWorkType, arg2: f64| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                Person,
                                FactionWorkType,
                                f64,
                            )
                                -> std::result::Result<WorkStats, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_crime_gains<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Person, CrimeType) -> std::result::Result<WorkStats, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let crime_gains: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            crime_gains
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: Person, arg1: CrimeType| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(Person, CrimeType) -> std::result::Result<WorkStats, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[allow(dead_code, non_camel_case_types)]
    type SleeveSupportTask = SleeveSupportTaskAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsRunParamsThreadOrOptions {
        RunOptions(RunOptions),
        F64(f64),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct InvestmentOffer {
        #[serde(rename = "round")]
        pub round: f64,
        #[serde(rename = "funds")]
        pub funds: f64,
        #[serde(rename = "shares")]
        pub shares: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait InvestmentOffer_Trait {
        fn set_funds(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn funds(&self) -> std::result::Result<f64, JsValue>;
        fn set_round(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn round(&self) -> std::result::Result<f64, JsValue>;
        fn set_shares(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn shares(&self) -> std::result::Result<f64, JsValue>;
    }
    impl InvestmentOffer_Trait for InvestmentOffer {
        fn set_funds(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.funds = value;
            Ok(())
        }
        fn funds(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.funds)
        }
        fn set_round(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.round = value;
            Ok(())
        }
        fn round(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.round)
        }
        fn set_shares(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.shares = value;
            Ok(())
        }
        fn shares(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.shares)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct AutocompleteData {
        #[serde(rename = "servers")]
        pub servers: Vec<String>,
        #[serde(rename = "txts")]
        pub txts: Vec<String>,
        #[serde(rename = "scripts")]
        pub scripts: Vec<String>,
        #[serde(
            rename = "flags",
            serialize_with = "AutocompleteData::__TSB__serialize_flags",
            deserialize_with = "AutocompleteData::__TSB__deserialize_flags"
        )]
        pub flags: std::rc::Rc<
            dyn Fn(
                Vec<AutocompleteDataFlagsParamsSchema>,
            ) -> std::result::Result<
                std::collections::HashMap<String, AutocompleteDataFlagsReturn>,
                JsValue,
            >,
        >,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait AutocompleteData_Trait {
        fn set_txts(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue>;
        fn txts(&self) -> std::result::Result<Vec<String>, JsValue>;
        fn set_servers(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue>;
        fn servers(&self) -> std::result::Result<Vec<String>, JsValue>;
        fn set_scripts(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue>;
        fn scripts(&self) -> std::result::Result<Vec<String>, JsValue>;
        fn set_flags(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    Vec<AutocompleteDataFlagsParamsSchema>,
                ) -> std::result::Result<
                    std::collections::HashMap<String, AutocompleteDataFlagsReturn>,
                    JsValue,
                >,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn flags(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    Vec<AutocompleteDataFlagsParamsSchema>,
                ) -> std::result::Result<
                    std::collections::HashMap<String, AutocompleteDataFlagsReturn>,
                    JsValue,
                >,
            >,
            JsValue,
        >;
    }
    impl AutocompleteData_Trait for AutocompleteData {
        fn set_txts(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue> {
            self.txts = value;
            Ok(())
        }
        fn txts(&self) -> std::result::Result<Vec<String>, JsValue> {
            Ok(self.txts.clone())
        }
        fn set_servers(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue> {
            self.servers = value;
            Ok(())
        }
        fn servers(&self) -> std::result::Result<Vec<String>, JsValue> {
            Ok(self.servers.clone())
        }
        fn set_scripts(&mut self, value: Vec<String>) -> std::result::Result<(), JsValue> {
            self.scripts = value;
            Ok(())
        }
        fn scripts(&self) -> std::result::Result<Vec<String>, JsValue> {
            Ok(self.scripts.clone())
        }
        fn set_flags(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    Vec<AutocompleteDataFlagsParamsSchema>,
                ) -> std::result::Result<
                    std::collections::HashMap<String, AutocompleteDataFlagsReturn>,
                    JsValue,
                >,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.flags = value;
            Ok(())
        }
        fn flags(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    Vec<AutocompleteDataFlagsParamsSchema>,
                ) -> std::result::Result<
                    std::collections::HashMap<String, AutocompleteDataFlagsReturn>,
                    JsValue,
                >,
            >,
            JsValue,
        > {
            Ok(self.flags.clone())
        }
    }
    impl AutocompleteData {
        #[allow(non_snake_case)]
        fn __TSB__serialize_flags<S>(
            flags: &std::rc::Rc<
                dyn Fn(
                    Vec<AutocompleteDataFlagsParamsSchema>,
                ) -> std::result::Result<
                    std::collections::HashMap<String, AutocompleteDataFlagsReturn>,
                    JsValue,
                >,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let flags = flags.clone();
            let flags_closure = Closure::wrap(Box::new(
                move |arg0: JsValue| -> std::result::Result<
                    std::collections::HashMap<String, AutocompleteDataFlagsReturn>,
                    JsValue,
                > {
                    let result = flags({
                        let mut arg0_vec = vec![];
                        for arg0_item in arg0.iter() {
                            arg0_vec.push({
                                let mut arg0_item_vec = vec![];
                                let arg0_item_item_0 = arg0_item.get(0);
                                arg0_item_vec.push(&arg0_item_item_0);
                                let arg0_item_item_1 = arg0_item.get(1);
                                arg0_item_vec.push(
                                    &ts_bindgen_rt::from_jsvalue(&arg0_item_item_1)
                                        .map_err(ts_bindgen_rt::Error::from)?,
                                );
                                arg0_item_vec
                            });
                        }
                        arg0_vec
                    })?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        JsValue,
                    ) -> std::result::Result<
                        std::collections::HashMap<String, AutocompleteDataFlagsReturn>,
                        JsValue,
                    >,
                >);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &flags_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_flags<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    Vec<AutocompleteDataFlagsParamsSchema>,
                ) -> std::result::Result<
                    std::collections::HashMap<String, AutocompleteDataFlagsReturn>,
                    JsValue,
                >,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let flags: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            flags
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: Vec<AutocompleteDataFlagsParamsSchema>| {
                        let arg0 = {
                            let arg0_array = js_sys::Array::new();
                            for arg0_item in arg0 {
                                arg0_array.push(&{
                                    let arg0_item_array = js_sys::Array::new();
                                    let arg0_item_item_0 = arg0_item.0;
                                    arg0_item_array.push(&JsValue::from(arg0_item_item_0));
                                    let arg0_item_item_1 = arg0_item.1;
                                    arg0_item_array
                                        .push(&ts_bindgen_rt::to_jsvalue(&arg0_item_item_1));
                                    arg0_item_array.into()
                                });
                            }
                            arg0_array.into()
                        };
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                Vec<AutocompleteDataFlagsParamsSchema>,
                            ) -> std::result::Result<
                                std::collections::HashMap<String, AutocompleteDataFlagsReturn>,
                                JsValue,
                            >,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct HacknetNodeConstants {
        #[serde(rename = "MoneyGainPerLevel")]
        pub money_gain_per_level: f64,
        #[serde(rename = "UpgradeLevelMult")]
        pub upgrade_level_mult: f64,
        #[serde(rename = "CoreBaseCost")]
        pub core_base_cost: f64,
        #[serde(rename = "RamBaseCost")]
        pub ram_base_cost: f64,
        #[serde(rename = "MaxCores")]
        pub max_cores: f64,
        #[serde(rename = "UpgradeRamMult")]
        pub upgrade_ram_mult: f64,
        #[serde(rename = "BaseCost")]
        pub base_cost: f64,
        #[serde(rename = "PurchaseNextMult")]
        pub purchase_next_mult: f64,
        #[serde(rename = "UpgradeCoreMult")]
        pub upgrade_core_mult: f64,
        #[serde(rename = "MaxRam")]
        pub max_ram: f64,
        #[serde(rename = "LevelBaseCost")]
        pub level_base_cost: f64,
        #[serde(rename = "MaxLevel")]
        pub max_level: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait HacknetNodeConstants_Trait {
        fn set_purchase_next_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn purchase_next_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_upgrade_core_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn upgrade_core_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_max_level(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn max_level(&self) -> std::result::Result<f64, JsValue>;
        fn set_ram_base_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn ram_base_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_money_gain_per_level(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn money_gain_per_level(&self) -> std::result::Result<f64, JsValue>;
        fn set_max_cores(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn max_cores(&self) -> std::result::Result<f64, JsValue>;
        fn set_level_base_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn level_base_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_max_ram(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn max_ram(&self) -> std::result::Result<f64, JsValue>;
        fn set_upgrade_ram_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn upgrade_ram_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_upgrade_level_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn upgrade_level_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_core_base_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn core_base_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_base_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn base_cost(&self) -> std::result::Result<f64, JsValue>;
    }
    impl HacknetNodeConstants_Trait for HacknetNodeConstants {
        fn set_purchase_next_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.purchase_next_mult = value;
            Ok(())
        }
        fn purchase_next_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.purchase_next_mult)
        }
        fn set_upgrade_core_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.upgrade_core_mult = value;
            Ok(())
        }
        fn upgrade_core_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.upgrade_core_mult)
        }
        fn set_max_level(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.max_level = value;
            Ok(())
        }
        fn max_level(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.max_level)
        }
        fn set_ram_base_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.ram_base_cost = value;
            Ok(())
        }
        fn ram_base_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.ram_base_cost)
        }
        fn set_money_gain_per_level(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.money_gain_per_level = value;
            Ok(())
        }
        fn money_gain_per_level(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.money_gain_per_level)
        }
        fn set_max_cores(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.max_cores = value;
            Ok(())
        }
        fn max_cores(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.max_cores)
        }
        fn set_level_base_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.level_base_cost = value;
            Ok(())
        }
        fn level_base_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.level_base_cost)
        }
        fn set_max_ram(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.max_ram = value;
            Ok(())
        }
        fn max_ram(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.max_ram)
        }
        fn set_upgrade_ram_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.upgrade_ram_mult = value;
            Ok(())
        }
        fn upgrade_ram_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.upgrade_ram_mult)
        }
        fn set_upgrade_level_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.upgrade_level_mult = value;
            Ok(())
        }
        fn upgrade_level_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.upgrade_level_mult)
        }
        fn set_core_base_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.core_base_cost = value;
            Ok(())
        }
        fn core_base_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.core_base_cost)
        }
        fn set_base_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.base_cost = value;
            Ok(())
        }
        fn base_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.base_cost)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum ProductCompetition {
        F64(f64),
        #[serde(
            serialize_with = "ts_bindgen_rt::serialize_undefined",
            deserialize_with = "ts_bindgen_rt::deserialize_undefined"
        )]
        TsBindgenRtUndefined,
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum ProductDesiredSellPrice {
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct MoneySource {
        #[serde(rename = "corporation")]
        pub corporation: f64,
        #[serde(rename = "total")]
        pub total: f64,
        #[serde(rename = "other")]
        pub other: f64,
        #[serde(rename = "hacknet_expenses")]
        pub hacknet_expenses: f64,
        #[serde(rename = "work")]
        pub work: f64,
        #[serde(rename = "codingcontract")]
        pub codingcontract: f64,
        #[serde(rename = "infiltration")]
        pub infiltration: f64,
        #[serde(rename = "gang")]
        pub gang: f64,
        #[serde(rename = "servers")]
        pub servers: f64,
        #[serde(rename = "class")]
        pub class: f64,
        #[serde(rename = "augmentations")]
        pub augmentations: f64,
        #[serde(rename = "hacking")]
        pub hacking: f64,
        #[serde(rename = "crime")]
        pub crime: f64,
        #[serde(rename = "hospitalization")]
        pub hospitalization: f64,
        #[serde(rename = "sleeves")]
        pub sleeves: f64,
        #[serde(rename = "hacknet")]
        pub hacknet: f64,
        #[serde(rename = "stock")]
        pub stock: f64,
        #[serde(rename = "casino")]
        pub casino: f64,
        #[serde(rename = "bladeburner")]
        pub bladeburner: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait MoneySource_Trait {
        fn set_casino(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn casino(&self) -> std::result::Result<f64, JsValue>;
        fn set_hospitalization(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hospitalization(&self) -> std::result::Result<f64, JsValue>;
        fn set_infiltration(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn infiltration(&self) -> std::result::Result<f64, JsValue>;
        fn set_stock(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn stock(&self) -> std::result::Result<f64, JsValue>;
        fn set_codingcontract(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn codingcontract(&self) -> std::result::Result<f64, JsValue>;
        fn set_hacknet_expenses(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hacknet_expenses(&self) -> std::result::Result<f64, JsValue>;
        fn set_servers(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn servers(&self) -> std::result::Result<f64, JsValue>;
        fn set_sleeves(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn sleeves(&self) -> std::result::Result<f64, JsValue>;
        fn set_corporation(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn corporation(&self) -> std::result::Result<f64, JsValue>;
        fn set_total(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn total(&self) -> std::result::Result<f64, JsValue>;
        fn set_gang(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn gang(&self) -> std::result::Result<f64, JsValue>;
        fn set_other(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn other(&self) -> std::result::Result<f64, JsValue>;
        fn set_class(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn class(&self) -> std::result::Result<f64, JsValue>;
        fn set_augmentations(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn augmentations(&self) -> std::result::Result<f64, JsValue>;
        fn set_bladeburner(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn bladeburner(&self) -> std::result::Result<f64, JsValue>;
        fn set_hacknet(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hacknet(&self) -> std::result::Result<f64, JsValue>;
        fn set_hacking(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hacking(&self) -> std::result::Result<f64, JsValue>;
        fn set_crime(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn crime(&self) -> std::result::Result<f64, JsValue>;
        fn set_work(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn work(&self) -> std::result::Result<f64, JsValue>;
    }
    impl MoneySource_Trait for MoneySource {
        fn set_casino(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.casino = value;
            Ok(())
        }
        fn casino(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.casino)
        }
        fn set_hospitalization(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hospitalization = value;
            Ok(())
        }
        fn hospitalization(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hospitalization)
        }
        fn set_infiltration(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.infiltration = value;
            Ok(())
        }
        fn infiltration(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.infiltration)
        }
        fn set_stock(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.stock = value;
            Ok(())
        }
        fn stock(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.stock)
        }
        fn set_codingcontract(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.codingcontract = value;
            Ok(())
        }
        fn codingcontract(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.codingcontract)
        }
        fn set_hacknet_expenses(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hacknet_expenses = value;
            Ok(())
        }
        fn hacknet_expenses(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacknet_expenses)
        }
        fn set_servers(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.servers = value;
            Ok(())
        }
        fn servers(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.servers)
        }
        fn set_sleeves(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.sleeves = value;
            Ok(())
        }
        fn sleeves(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.sleeves)
        }
        fn set_corporation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.corporation = value;
            Ok(())
        }
        fn corporation(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.corporation)
        }
        fn set_total(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.total = value;
            Ok(())
        }
        fn total(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.total)
        }
        fn set_gang(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.gang = value;
            Ok(())
        }
        fn gang(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.gang)
        }
        fn set_other(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.other = value;
            Ok(())
        }
        fn other(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.other)
        }
        fn set_class(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.class = value;
            Ok(())
        }
        fn class(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.class)
        }
        fn set_augmentations(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.augmentations = value;
            Ok(())
        }
        fn augmentations(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.augmentations)
        }
        fn set_bladeburner(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.bladeburner = value;
            Ok(())
        }
        fn bladeburner(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.bladeburner)
        }
        fn set_hacknet(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hacknet = value;
            Ok(())
        }
        fn hacknet(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacknet)
        }
        fn set_hacking(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hacking = value;
            Ok(())
        }
        fn hacking(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacking)
        }
        fn set_crime(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.crime = value;
            Ok(())
        }
        fn crime(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.crime)
        }
        fn set_work(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.work = value;
            Ok(())
        }
        fn work(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.work)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Person {
        #[serde(rename = "mults")]
        pub mults: Multipliers,
        #[serde(rename = "skills")]
        pub skills: Skills,
        #[serde(rename = "hp")]
        pub hp: Hp,
        #[serde(rename = "exp")]
        pub exp: Skills,
        #[serde(rename = "city")]
        pub city: CityName,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait Person_Trait {
        fn set_hp(&mut self, value: Hp) -> std::result::Result<(), JsValue>;
        fn hp(&self) -> std::result::Result<Hp, JsValue>;
        fn set_exp(&mut self, value: Skills) -> std::result::Result<(), JsValue>;
        fn exp(&self) -> std::result::Result<Skills, JsValue>;
        fn set_skills(&mut self, value: Skills) -> std::result::Result<(), JsValue>;
        fn skills(&self) -> std::result::Result<Skills, JsValue>;
        fn set_mults(&mut self, value: Multipliers) -> std::result::Result<(), JsValue>;
        fn mults(&self) -> std::result::Result<Multipliers, JsValue>;
        fn set_city(&mut self, value: CityName) -> std::result::Result<(), JsValue>;
        fn city(&self) -> std::result::Result<CityName, JsValue>;
    }
    impl Person_Trait for Person {
        fn set_hp(&mut self, value: Hp) -> std::result::Result<(), JsValue> {
            self.hp = value;
            Ok(())
        }
        fn hp(&self) -> std::result::Result<Hp, JsValue> {
            Ok(self.hp.clone())
        }
        fn set_exp(&mut self, value: Skills) -> std::result::Result<(), JsValue> {
            self.exp = value;
            Ok(())
        }
        fn exp(&self) -> std::result::Result<Skills, JsValue> {
            Ok(self.exp.clone())
        }
        fn set_skills(&mut self, value: Skills) -> std::result::Result<(), JsValue> {
            self.skills = value;
            Ok(())
        }
        fn skills(&self) -> std::result::Result<Skills, JsValue> {
            Ok(self.skills.clone())
        }
        fn set_mults(&mut self, value: Multipliers) -> std::result::Result<(), JsValue> {
            self.mults = value;
            Ok(())
        }
        fn mults(&self) -> std::result::Result<Multipliers, JsValue> {
            Ok(self.mults.clone())
        }
        fn set_city(&mut self, value: CityName) -> std::result::Result<(), JsValue> {
            self.city = value;
            Ok(())
        }
        fn city(&self) -> std::result::Result<CityName, JsValue> {
            Ok(self.city.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum ProductDemand {
        F64(f64),
        #[serde(
            serialize_with = "ts_bindgen_rt::serialize_undefined",
            deserialize_with = "ts_bindgen_rt::deserialize_undefined"
        )]
        TsBindgenRtUndefined,
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsGetScriptIncomeParamsArgs {
        Bool(bool),
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Material {
        #[serde(rename = "demand")]
        pub demand: MaterialDemand,
        #[serde(rename = "productionAmount")]
        pub production_amount: f64,
        #[serde(rename = "desiredSellAmount")]
        pub desired_sell_amount: MaterialDesiredSellAmount,
        #[serde(rename = "exports")]
        pub exports: Vec<Export>,
        #[serde(rename = "competition")]
        pub competition: MaterialCompetition,
        #[serde(rename = "marketPrice")]
        pub market_price: f64,
        #[serde(rename = "name")]
        pub name: CorpMaterialName,
        #[serde(rename = "quality")]
        pub quality: f64,
        #[serde(rename = "stored")]
        pub stored: f64,
        #[serde(rename = "desiredSellPrice")]
        pub desired_sell_price: MaterialDesiredSellPrice,
        #[serde(rename = "actualSellAmount")]
        pub actual_sell_amount: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait Material_Trait {
        fn set_name(&mut self, value: CorpMaterialName) -> std::result::Result<(), JsValue>;
        fn name(&self) -> std::result::Result<CorpMaterialName, JsValue>;
        fn set_actual_sell_amount(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn actual_sell_amount(&self) -> std::result::Result<f64, JsValue>;
        fn set_competition(
            &mut self,
            value: MaterialCompetition,
        ) -> std::result::Result<(), JsValue>;
        fn competition(&self) -> std::result::Result<MaterialCompetition, JsValue>;
        fn set_exports(&mut self, value: Vec<Export>) -> std::result::Result<(), JsValue>;
        fn exports(&self) -> std::result::Result<Vec<Export>, JsValue>;
        fn set_demand(&mut self, value: MaterialDemand) -> std::result::Result<(), JsValue>;
        fn demand(&self) -> std::result::Result<MaterialDemand, JsValue>;
        fn set_production_amount(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn production_amount(&self) -> std::result::Result<f64, JsValue>;
        fn set_stored(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn stored(&self) -> std::result::Result<f64, JsValue>;
        fn set_quality(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn quality(&self) -> std::result::Result<f64, JsValue>;
        fn set_desired_sell_amount(
            &mut self,
            value: MaterialDesiredSellAmount,
        ) -> std::result::Result<(), JsValue>;
        fn desired_sell_amount(&self) -> std::result::Result<MaterialDesiredSellAmount, JsValue>;
        fn set_desired_sell_price(
            &mut self,
            value: MaterialDesiredSellPrice,
        ) -> std::result::Result<(), JsValue>;
        fn desired_sell_price(&self) -> std::result::Result<MaterialDesiredSellPrice, JsValue>;
        fn set_market_price(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn market_price(&self) -> std::result::Result<f64, JsValue>;
    }
    impl Material_Trait for Material {
        fn set_name(&mut self, value: CorpMaterialName) -> std::result::Result<(), JsValue> {
            self.name = value;
            Ok(())
        }
        fn name(&self) -> std::result::Result<CorpMaterialName, JsValue> {
            Ok(self.name.clone())
        }
        fn set_actual_sell_amount(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.actual_sell_amount = value;
            Ok(())
        }
        fn actual_sell_amount(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.actual_sell_amount)
        }
        fn set_competition(
            &mut self,
            value: MaterialCompetition,
        ) -> std::result::Result<(), JsValue> {
            self.competition = value;
            Ok(())
        }
        fn competition(&self) -> std::result::Result<MaterialCompetition, JsValue> {
            Ok(self.competition.clone())
        }
        fn set_exports(&mut self, value: Vec<Export>) -> std::result::Result<(), JsValue> {
            self.exports = value;
            Ok(())
        }
        fn exports(&self) -> std::result::Result<Vec<Export>, JsValue> {
            Ok(self.exports.clone())
        }
        fn set_demand(&mut self, value: MaterialDemand) -> std::result::Result<(), JsValue> {
            self.demand = value;
            Ok(())
        }
        fn demand(&self) -> std::result::Result<MaterialDemand, JsValue> {
            Ok(self.demand.clone())
        }
        fn set_production_amount(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.production_amount = value;
            Ok(())
        }
        fn production_amount(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.production_amount)
        }
        fn set_stored(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.stored = value;
            Ok(())
        }
        fn stored(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.stored)
        }
        fn set_quality(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.quality = value;
            Ok(())
        }
        fn quality(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.quality)
        }
        fn set_desired_sell_amount(
            &mut self,
            value: MaterialDesiredSellAmount,
        ) -> std::result::Result<(), JsValue> {
            self.desired_sell_amount = value;
            Ok(())
        }
        fn desired_sell_amount(&self) -> std::result::Result<MaterialDesiredSellAmount, JsValue> {
            Ok(self.desired_sell_amount.clone())
        }
        fn set_desired_sell_price(
            &mut self,
            value: MaterialDesiredSellPrice,
        ) -> std::result::Result<(), JsValue> {
            self.desired_sell_price = value;
            Ok(())
        }
        fn desired_sell_price(&self) -> std::result::Result<MaterialDesiredSellPrice, JsValue> {
            Ok(self.desired_sell_price.clone())
        }
        fn set_market_price(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.market_price = value;
            Ok(())
        }
        fn market_price(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.market_price)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct BladeburnerGetActionEstimatedSuccessChanceReturn(pub f64, pub f64);
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct HacknetServerConstants {
        #[serde(rename = "UpgradeRamMult")]
        pub upgrade_ram_mult: f64,
        #[serde(rename = "HashesPerLevel")]
        pub hashes_per_level: f64,
        #[serde(rename = "MaxCores")]
        pub max_cores: f64,
        #[serde(rename = "MaxServers")]
        pub max_servers: f64,
        #[serde(rename = "UpgradeCoreMult")]
        pub upgrade_core_mult: f64,
        #[serde(rename = "MaxCache")]
        pub max_cache: f64,
        #[serde(rename = "BaseCost")]
        pub base_cost: f64,
        #[serde(rename = "MaxLevel")]
        pub max_level: f64,
        #[serde(rename = "RamBaseCost")]
        pub ram_base_cost: f64,
        #[serde(rename = "CoreBaseCost")]
        pub core_base_cost: f64,
        #[serde(rename = "UpgradeLevelMult")]
        pub upgrade_level_mult: f64,
        #[serde(rename = "UpgradeCacheMult")]
        pub upgrade_cache_mult: f64,
        #[serde(rename = "CacheBaseCost")]
        pub cache_base_cost: f64,
        #[serde(rename = "MaxRam")]
        pub max_ram: f64,
        #[serde(rename = "PurchaseMult")]
        pub purchase_mult: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait HacknetServerConstants_Trait {
        fn set_upgrade_core_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn upgrade_core_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_core_base_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn core_base_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_max_level(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn max_level(&self) -> std::result::Result<f64, JsValue>;
        fn set_ram_base_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn ram_base_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_max_cache(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn max_cache(&self) -> std::result::Result<f64, JsValue>;
        fn set_base_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn base_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_upgrade_level_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn upgrade_level_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_hashes_per_level(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hashes_per_level(&self) -> std::result::Result<f64, JsValue>;
        fn set_upgrade_ram_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn upgrade_ram_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_upgrade_cache_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn upgrade_cache_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_cache_base_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cache_base_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_max_ram(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn max_ram(&self) -> std::result::Result<f64, JsValue>;
        fn set_purchase_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn purchase_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_max_servers(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn max_servers(&self) -> std::result::Result<f64, JsValue>;
        fn set_max_cores(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn max_cores(&self) -> std::result::Result<f64, JsValue>;
    }
    impl HacknetServerConstants_Trait for HacknetServerConstants {
        fn set_upgrade_core_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.upgrade_core_mult = value;
            Ok(())
        }
        fn upgrade_core_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.upgrade_core_mult)
        }
        fn set_core_base_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.core_base_cost = value;
            Ok(())
        }
        fn core_base_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.core_base_cost)
        }
        fn set_max_level(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.max_level = value;
            Ok(())
        }
        fn max_level(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.max_level)
        }
        fn set_ram_base_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.ram_base_cost = value;
            Ok(())
        }
        fn ram_base_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.ram_base_cost)
        }
        fn set_max_cache(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.max_cache = value;
            Ok(())
        }
        fn max_cache(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.max_cache)
        }
        fn set_base_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.base_cost = value;
            Ok(())
        }
        fn base_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.base_cost)
        }
        fn set_upgrade_level_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.upgrade_level_mult = value;
            Ok(())
        }
        fn upgrade_level_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.upgrade_level_mult)
        }
        fn set_hashes_per_level(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hashes_per_level = value;
            Ok(())
        }
        fn hashes_per_level(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hashes_per_level)
        }
        fn set_upgrade_ram_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.upgrade_ram_mult = value;
            Ok(())
        }
        fn upgrade_ram_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.upgrade_ram_mult)
        }
        fn set_upgrade_cache_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.upgrade_cache_mult = value;
            Ok(())
        }
        fn upgrade_cache_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.upgrade_cache_mult)
        }
        fn set_cache_base_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cache_base_cost = value;
            Ok(())
        }
        fn cache_base_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cache_base_cost)
        }
        fn set_max_ram(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.max_ram = value;
            Ok(())
        }
        fn max_ram(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.max_ram)
        }
        fn set_purchase_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.purchase_mult = value;
            Ok(())
        }
        fn purchase_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.purchase_mult)
        }
        fn set_max_servers(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.max_servers = value;
            Ok(())
        }
        fn max_servers(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.max_servers)
        }
        fn set_max_cores(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.max_cores = value;
            Ok(())
        }
        fn max_cores(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.max_cores)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct CorpMaterialConstantDataCompetitionRange(pub f64, pub f64);
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Corporation {
        #[serde(
            rename = "limitMaterialProduction",
            serialize_with = "Corporation::__TSB__serialize_limit_material_production",
            deserialize_with = "Corporation::__TSB__deserialize_limit_material_production"
        )]
        pub limit_material_production:
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "getUpgradeLevel",
            serialize_with = "Corporation::__TSB__serialize_get_upgrade_level",
            deserialize_with = "Corporation::__TSB__deserialize_get_upgrade_level"
        )]
        pub get_upgrade_level: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getHireAdVertCost",
            serialize_with = "Corporation::__TSB__serialize_get_hire_ad_vert_cost",
            deserialize_with = "Corporation::__TSB__deserialize_get_hire_ad_vert_cost"
        )]
        pub get_hire_ad_vert_cost: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "exportMaterial",
            serialize_with = "Corporation::__TSB__serialize_export_material",
            deserialize_with = "Corporation::__TSB__deserialize_export_material"
        )]
        pub export_material: std::rc::Rc<
            dyn Fn(
                String,
                CityName,
                String,
                CityName,
                String,
                WarehouseApiExportMaterialParamsAmt,
            ) -> std::result::Result<(), JsValue>,
        >,
        #[serde(
            rename = "setMaterialMarketTA2",
            serialize_with = "Corporation::__TSB__serialize_set_material_market_ta2",
            deserialize_with = "Corporation::__TSB__deserialize_set_material_market_ta2"
        )]
        pub set_material_market_ta2:
            std::rc::Rc<dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "purchaseUnlock",
            serialize_with = "Corporation::__TSB__serialize_purchase_unlock",
            deserialize_with = "Corporation::__TSB__deserialize_purchase_unlock"
        )]
        pub purchase_unlock: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "buyMaterial",
            serialize_with = "Corporation::__TSB__serialize_buy_material",
            deserialize_with = "Corporation::__TSB__deserialize_buy_material"
        )]
        pub buy_material:
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "getOfficeSizeUpgradeCost",
            serialize_with = "Corporation::__TSB__serialize_get_office_size_upgrade_cost",
            deserialize_with = "Corporation::__TSB__deserialize_get_office_size_upgrade_cost"
        )]
        pub get_office_size_upgrade_cost:
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getConstants",
            serialize_with = "Corporation::__TSB__serialize_get_constants",
            deserialize_with = "Corporation::__TSB__deserialize_get_constants"
        )]
        pub get_constants: std::rc::Rc<dyn Fn() -> std::result::Result<CorpConstants, JsValue>>,
        #[serde(
            rename = "setProductMarketTA1",
            serialize_with = "Corporation::__TSB__serialize_set_product_market_ta1",
            deserialize_with = "Corporation::__TSB__deserialize_set_product_market_ta1"
        )]
        pub set_product_market_ta1:
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "sellProduct",
            serialize_with = "Corporation::__TSB__serialize_sell_product",
            deserialize_with = "Corporation::__TSB__deserialize_sell_product"
        )]
        pub sell_product: std::rc::Rc<
            dyn Fn(
                String,
                CityName,
                String,
                String,
                String,
                bool,
            ) -> std::result::Result<(), JsValue>,
        >,
        #[serde(
            rename = "getDivision",
            serialize_with = "Corporation::__TSB__serialize_get_division",
            deserialize_with = "Corporation::__TSB__deserialize_get_division"
        )]
        pub get_division: std::rc::Rc<dyn Fn(String) -> std::result::Result<Division, JsValue>>,
        #[serde(
            rename = "getMaterialData",
            serialize_with = "Corporation::__TSB__serialize_get_material_data",
            deserialize_with = "Corporation::__TSB__deserialize_get_material_data"
        )]
        pub get_material_data: std::rc::Rc<
            dyn Fn(CorpMaterialName) -> std::result::Result<CorpMaterialConstantData, JsValue>,
        >,
        #[serde(
            rename = "createCorporation",
            serialize_with = "Corporation::__TSB__serialize_create_corporation",
            deserialize_with = "Corporation::__TSB__deserialize_create_corporation"
        )]
        pub create_corporation:
            std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "sellMaterial",
            serialize_with = "Corporation::__TSB__serialize_sell_material",
            deserialize_with = "Corporation::__TSB__deserialize_sell_material"
        )]
        pub sell_material: std::rc::Rc<
            dyn Fn(String, CityName, String, String, String) -> std::result::Result<(), JsValue>,
        >,
        #[serde(
            rename = "goPublic",
            serialize_with = "Corporation::__TSB__serialize_go_public",
            deserialize_with = "Corporation::__TSB__deserialize_go_public"
        )]
        pub go_public: std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "setSmartSupplyOption",
            serialize_with = "Corporation::__TSB__serialize_set_smart_supply_option",
            deserialize_with = "Corporation::__TSB__deserialize_set_smart_supply_option"
        )]
        pub set_smart_supply_option: std::rc::Rc<
            dyn Fn(String, CityName, String, String) -> std::result::Result<(), JsValue>,
        >,
        #[serde(
            rename = "hireAdVert",
            serialize_with = "Corporation::__TSB__serialize_hire_ad_vert",
            deserialize_with = "Corporation::__TSB__deserialize_hire_ad_vert"
        )]
        pub hire_ad_vert: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "bribe",
            serialize_with = "Corporation::__TSB__serialize_bribe",
            deserialize_with = "Corporation::__TSB__deserialize_bribe"
        )]
        pub bribe: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "hireEmployee",
            serialize_with = "Corporation::__TSB__serialize_hire_employee",
            deserialize_with = "Corporation::__TSB__deserialize_hire_employee"
        )]
        pub hire_employee: std::rc::Rc<
            dyn Fn(String, CityName, CorpEmployeePosition) -> std::result::Result<bool, JsValue>,
        >,
        #[serde(
            rename = "discontinueProduct",
            serialize_with = "Corporation::__TSB__serialize_discontinue_product",
            deserialize_with = "Corporation::__TSB__deserialize_discontinue_product"
        )]
        pub discontinue_product:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "research",
            serialize_with = "Corporation::__TSB__serialize_research",
            deserialize_with = "Corporation::__TSB__deserialize_research"
        )]
        pub research: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "buyTea",
            serialize_with = "Corporation::__TSB__serialize_buy_tea",
            deserialize_with = "Corporation::__TSB__deserialize_buy_tea"
        )]
        pub buy_tea: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getUpgradeWarehouseCost",
            serialize_with = "Corporation::__TSB__serialize_get_upgrade_warehouse_cost",
            deserialize_with = "Corporation::__TSB__deserialize_get_upgrade_warehouse_cost"
        )]
        pub get_upgrade_warehouse_cost:
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "cancelExportMaterial",
            serialize_with = "Corporation::__TSB__serialize_cancel_export_material",
            deserialize_with = "Corporation::__TSB__deserialize_cancel_export_material"
        )]
        pub cancel_export_material: std::rc::Rc<
            dyn Fn(String, CityName, String, CityName, String) -> std::result::Result<(), JsValue>,
        >,
        #[serde(
            rename = "getUnlockCost",
            serialize_with = "Corporation::__TSB__serialize_get_unlock_cost",
            deserialize_with = "Corporation::__TSB__deserialize_get_unlock_cost"
        )]
        pub get_unlock_cost: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getProduct",
            serialize_with = "Corporation::__TSB__serialize_get_product",
            deserialize_with = "Corporation::__TSB__deserialize_get_product"
        )]
        pub get_product:
            std::rc::Rc<dyn Fn(String, CityName, String) -> std::result::Result<Product, JsValue>>,
        #[serde(
            rename = "makeProduct",
            serialize_with = "Corporation::__TSB__serialize_make_product",
            deserialize_with = "Corporation::__TSB__deserialize_make_product"
        )]
        pub make_product: std::rc::Rc<
            dyn Fn(String, CityName, String, f64, f64) -> std::result::Result<(), JsValue>,
        >,
        #[serde(
            rename = "getCorporation",
            serialize_with = "Corporation::__TSB__serialize_get_corporation",
            deserialize_with = "Corporation::__TSB__deserialize_get_corporation"
        )]
        pub get_corporation: std::rc::Rc<dyn Fn() -> std::result::Result<CorporationInfo, JsValue>>,
        #[serde(
            rename = "sellShares",
            serialize_with = "Corporation::__TSB__serialize_sell_shares",
            deserialize_with = "Corporation::__TSB__deserialize_sell_shares"
        )]
        pub sell_shares: std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "bulkPurchase",
            serialize_with = "Corporation::__TSB__serialize_bulk_purchase",
            deserialize_with = "Corporation::__TSB__deserialize_bulk_purchase"
        )]
        pub bulk_purchase:
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "hasWarehouse",
            serialize_with = "Corporation::__TSB__serialize_has_warehouse",
            deserialize_with = "Corporation::__TSB__deserialize_has_warehouse"
        )]
        pub has_warehouse:
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "expandCity",
            serialize_with = "Corporation::__TSB__serialize_expand_city",
            deserialize_with = "Corporation::__TSB__deserialize_expand_city"
        )]
        pub expand_city: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "expandIndustry",
            serialize_with = "Corporation::__TSB__serialize_expand_industry",
            deserialize_with = "Corporation::__TSB__deserialize_expand_industry"
        )]
        pub expand_industry:
            std::rc::Rc<dyn Fn(CorpIndustryName, String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "getWarehouse",
            serialize_with = "Corporation::__TSB__serialize_get_warehouse",
            deserialize_with = "Corporation::__TSB__deserialize_get_warehouse"
        )]
        pub get_warehouse:
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Warehouse, JsValue>>,
        #[serde(
            rename = "setProductMarketTA2",
            serialize_with = "Corporation::__TSB__serialize_set_product_market_ta2",
            deserialize_with = "Corporation::__TSB__deserialize_set_product_market_ta2"
        )]
        pub set_product_market_ta2:
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "upgradeOfficeSize",
            serialize_with = "Corporation::__TSB__serialize_upgrade_office_size",
            deserialize_with = "Corporation::__TSB__deserialize_upgrade_office_size"
        )]
        pub upgrade_office_size:
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "getBonusTime",
            serialize_with = "Corporation::__TSB__serialize_get_bonus_time",
            deserialize_with = "Corporation::__TSB__deserialize_get_bonus_time"
        )]
        pub get_bonus_time: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "setMaterialMarketTA1",
            serialize_with = "Corporation::__TSB__serialize_set_material_market_ta1",
            deserialize_with = "Corporation::__TSB__deserialize_set_material_market_ta1"
        )]
        pub set_material_market_ta1:
            std::rc::Rc<dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "hasCorporation",
            serialize_with = "Corporation::__TSB__serialize_has_corporation",
            deserialize_with = "Corporation::__TSB__deserialize_has_corporation"
        )]
        pub has_corporation: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "setAutoJobAssignment",
            serialize_with = "Corporation::__TSB__serialize_set_auto_job_assignment",
            deserialize_with = "Corporation::__TSB__deserialize_set_auto_job_assignment"
        )]
        pub set_auto_job_assignment: std::rc::Rc<
            dyn Fn(String, CityName, String, f64) -> std::result::Result<bool, JsValue>,
        >,
        #[serde(
            rename = "getOffice",
            serialize_with = "Corporation::__TSB__serialize_get_office",
            deserialize_with = "Corporation::__TSB__deserialize_get_office"
        )]
        pub get_office:
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Office, JsValue>>,
        #[serde(
            rename = "hasResearched",
            serialize_with = "Corporation::__TSB__serialize_has_researched",
            deserialize_with = "Corporation::__TSB__deserialize_has_researched"
        )]
        pub has_researched:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "levelUpgrade",
            serialize_with = "Corporation::__TSB__serialize_level_upgrade",
            deserialize_with = "Corporation::__TSB__deserialize_level_upgrade"
        )]
        pub level_upgrade: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "acceptInvestmentOffer",
            serialize_with = "Corporation::__TSB__serialize_accept_investment_offer",
            deserialize_with = "Corporation::__TSB__deserialize_accept_investment_offer"
        )]
        pub accept_investment_offer: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "purchaseWarehouse",
            serialize_with = "Corporation::__TSB__serialize_purchase_warehouse",
            deserialize_with = "Corporation::__TSB__deserialize_purchase_warehouse"
        )]
        pub purchase_warehouse:
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "upgradeWarehouse",
            serialize_with = "Corporation::__TSB__serialize_upgrade_warehouse",
            deserialize_with = "Corporation::__TSB__deserialize_upgrade_warehouse"
        )]
        pub upgrade_warehouse:
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "issueNewShares",
            serialize_with = "Corporation::__TSB__serialize_issue_new_shares",
            deserialize_with = "Corporation::__TSB__deserialize_issue_new_shares"
        )]
        pub issue_new_shares: std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getInvestmentOffer",
            serialize_with = "Corporation::__TSB__serialize_get_investment_offer",
            deserialize_with = "Corporation::__TSB__deserialize_get_investment_offer"
        )]
        pub get_investment_offer:
            std::rc::Rc<dyn Fn() -> std::result::Result<InvestmentOffer, JsValue>>,
        #[serde(
            rename = "getResearchCost",
            serialize_with = "Corporation::__TSB__serialize_get_research_cost",
            deserialize_with = "Corporation::__TSB__deserialize_get_research_cost"
        )]
        pub get_research_cost:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "throwParty",
            serialize_with = "Corporation::__TSB__serialize_throw_party",
            deserialize_with = "Corporation::__TSB__deserialize_throw_party"
        )]
        pub throw_party:
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getHireAdVertCount",
            serialize_with = "Corporation::__TSB__serialize_get_hire_ad_vert_count",
            deserialize_with = "Corporation::__TSB__deserialize_get_hire_ad_vert_count"
        )]
        pub get_hire_ad_vert_count:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "hasUnlock",
            serialize_with = "Corporation::__TSB__serialize_has_unlock",
            deserialize_with = "Corporation::__TSB__deserialize_has_unlock"
        )]
        pub has_unlock: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getMaterial",
            serialize_with = "Corporation::__TSB__serialize_get_material",
            deserialize_with = "Corporation::__TSB__deserialize_get_material"
        )]
        pub get_material:
            std::rc::Rc<dyn Fn(String, CityName, String) -> std::result::Result<Material, JsValue>>,
        #[serde(
            rename = "getIndustryData",
            serialize_with = "Corporation::__TSB__serialize_get_industry_data",
            deserialize_with = "Corporation::__TSB__deserialize_get_industry_data"
        )]
        pub get_industry_data:
            std::rc::Rc<dyn Fn(CorpIndustryName) -> std::result::Result<CorpIndustryData, JsValue>>,
        #[serde(
            rename = "getUpgradeLevelCost",
            serialize_with = "Corporation::__TSB__serialize_get_upgrade_level_cost",
            deserialize_with = "Corporation::__TSB__deserialize_get_upgrade_level_cost"
        )]
        pub get_upgrade_level_cost:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "limitProductProduction",
            serialize_with = "Corporation::__TSB__serialize_limit_product_production",
            deserialize_with = "Corporation::__TSB__deserialize_limit_product_production"
        )]
        pub limit_product_production:
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "issueDividends",
            serialize_with = "Corporation::__TSB__serialize_issue_dividends",
            deserialize_with = "Corporation::__TSB__deserialize_issue_dividends"
        )]
        pub issue_dividends: std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "setSmartSupply",
            serialize_with = "Corporation::__TSB__serialize_set_smart_supply",
            deserialize_with = "Corporation::__TSB__deserialize_set_smart_supply"
        )]
        pub set_smart_supply:
            std::rc::Rc<dyn Fn(String, CityName, bool) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "buyBackShares",
            serialize_with = "Corporation::__TSB__serialize_buy_back_shares",
            deserialize_with = "Corporation::__TSB__deserialize_buy_back_shares"
        )]
        pub buy_back_shares: std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait Corporation_Trait: WarehouseApi_Trait + OfficeApi_Trait {
        fn set_has_corporation(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn has_corporation(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_create_corporation(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn create_corporation(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_bonus_time(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_bonus_time(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_purchase_unlock(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn purchase_unlock(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_issue_new_shares(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn issue_new_shares(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_upgrade_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_upgrade_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_division(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<Division, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_division(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Division, JsValue>>,
            JsValue,
        >;
        fn set_get_unlock_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_unlock_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_upgrade_level_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_upgrade_level_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_go_public(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn go_public(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_constants(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<CorpConstants, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_constants(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<CorpConstants, JsValue>>,
            JsValue,
        >;
        fn set_buy_back_shares(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn buy_back_shares(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_has_unlock(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn has_unlock(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_corporation(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<CorporationInfo, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_corporation(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<CorporationInfo, JsValue>>,
            JsValue,
        >;
        fn set_expand_city(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn expand_city(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_expand_industry(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(CorpIndustryName, String) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn expand_industry(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CorpIndustryName, String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_sell_shares(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn sell_shares(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_issue_dividends(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn issue_dividends(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_accept_investment_offer(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn accept_investment_offer(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_get_industry_data(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(CorpIndustryName) -> std::result::Result<CorpIndustryData, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_industry_data(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CorpIndustryName) -> std::result::Result<CorpIndustryData, JsValue>>,
            JsValue,
        >;
        fn set_get_investment_offer(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<InvestmentOffer, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_investment_offer(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<InvestmentOffer, JsValue>>,
            JsValue,
        >;
        fn set_bribe(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn bribe(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_material_data(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(CorpMaterialName) -> std::result::Result<CorpMaterialConstantData, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_material_data(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(CorpMaterialName) -> std::result::Result<CorpMaterialConstantData, JsValue>,
            >,
            JsValue,
        >;
        fn set_level_upgrade(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn level_upgrade(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
    }
    impl WarehouseApi_Trait for Corporation {
        fn set_limit_product_production(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.limit_product_production = value;
            Ok(())
        }
        fn limit_product_production(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.limit_product_production.clone())
        }
        fn set_set_material_market_ta2(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.set_material_market_ta2 = value;
            Ok(())
        }
        fn set_material_market_ta2(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.set_material_market_ta2.clone())
        }
        fn set_get_upgrade_warehouse_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_upgrade_warehouse_cost = value;
            Ok(())
        }
        fn get_upgrade_warehouse_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_upgrade_warehouse_cost.clone())
        }
        fn set_limit_material_production(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.limit_material_production = value;
            Ok(())
        }
        fn limit_material_production(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.limit_material_production.clone())
        }
        fn set_set_product_market_ta1(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_product_market_ta1 = value;
            Ok(())
        }
        fn set_product_market_ta1(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.set_product_market_ta1.clone())
        }
        fn set_has_warehouse(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.has_warehouse = value;
            Ok(())
        }
        fn has_warehouse(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.has_warehouse.clone())
        }
        fn set_export_material(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                    WarehouseApiExportMaterialParamsAmt,
                ) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.export_material = value;
            Ok(())
        }
        fn export_material(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                    WarehouseApiExportMaterialParamsAmt,
                ) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        > {
            Ok(self.export_material.clone())
        }
        fn set_purchase_warehouse(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.purchase_warehouse = value;
            Ok(())
        }
        fn purchase_warehouse(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.purchase_warehouse.clone())
        }
        fn set_bulk_purchase(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.bulk_purchase = value;
            Ok(())
        }
        fn bulk_purchase(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.bulk_purchase.clone())
        }
        fn set_make_product(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, f64, f64) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.make_product = value;
            Ok(())
        }
        fn make_product(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, CityName, String, f64, f64) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        > {
            Ok(self.make_product.clone())
        }
        fn set_get_material(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String) -> std::result::Result<Material, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_material = value;
            Ok(())
        }
        fn get_material(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String) -> std::result::Result<Material, JsValue>>,
            JsValue,
        > {
            Ok(self.get_material.clone())
        }
        fn set_buy_material(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.buy_material = value;
            Ok(())
        }
        fn buy_material(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.buy_material.clone())
        }
        fn set_cancel_export_material(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.cancel_export_material = value;
            Ok(())
        }
        fn cancel_export_material(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        > {
            Ok(self.cancel_export_material.clone())
        }
        fn set_set_smart_supply(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName, bool) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_smart_supply = value;
            Ok(())
        }
        fn set_smart_supply(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.set_smart_supply.clone())
        }
        fn set_discontinue_product(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.discontinue_product = value;
            Ok(())
        }
        fn discontinue_product(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.discontinue_product.clone())
        }
        fn set_set_product_market_ta2(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_product_market_ta2 = value;
            Ok(())
        }
        fn set_product_market_ta2(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.set_product_market_ta2.clone())
        }
        fn set_get_warehouse(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Warehouse, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_warehouse = value;
            Ok(())
        }
        fn get_warehouse(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Warehouse, JsValue>>,
            JsValue,
        > {
            Ok(self.get_warehouse.clone())
        }
        fn set_set_material_market_ta1(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.set_material_market_ta1 = value;
            Ok(())
        }
        fn set_material_market_ta1(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.set_material_market_ta1.clone())
        }
        fn set_sell_product(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                    bool,
                ) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.sell_product = value;
            Ok(())
        }
        fn sell_product(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                    bool,
                ) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        > {
            Ok(self.sell_product.clone())
        }
        fn set_set_smart_supply_option(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, String) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.set_smart_supply_option = value;
            Ok(())
        }
        fn set_smart_supply_option(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, CityName, String, String) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        > {
            Ok(self.set_smart_supply_option.clone())
        }
        fn set_sell_material(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.sell_material = value;
            Ok(())
        }
        fn sell_material(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        > {
            Ok(self.sell_material.clone())
        }
        fn set_get_product(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String) -> std::result::Result<Product, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_product = value;
            Ok(())
        }
        fn get_product(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String) -> std::result::Result<Product, JsValue>>,
            JsValue,
        > {
            Ok(self.get_product.clone())
        }
        fn set_upgrade_warehouse(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.upgrade_warehouse = value;
            Ok(())
        }
        fn upgrade_warehouse(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.upgrade_warehouse.clone())
        }
    }
    impl OfficeApi_Trait for Corporation {
        fn set_throw_party(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.throw_party = value;
            Ok(())
        }
        fn throw_party(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.throw_party.clone())
        }
        fn set_get_research_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_research_cost = value;
            Ok(())
        }
        fn get_research_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_research_cost.clone())
        }
        fn set_hire_employee(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    CorpEmployeePosition,
                ) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.hire_employee = value;
            Ok(())
        }
        fn hire_employee(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    CorpEmployeePosition,
                ) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.hire_employee.clone())
        }
        fn set_buy_tea(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.buy_tea = value;
            Ok(())
        }
        fn buy_tea(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.buy_tea.clone())
        }
        fn set_get_hire_ad_vert_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_hire_ad_vert_cost = value;
            Ok(())
        }
        fn get_hire_ad_vert_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_hire_ad_vert_cost.clone())
        }
        fn set_get_office_size_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_office_size_upgrade_cost = value;
            Ok(())
        }
        fn get_office_size_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_office_size_upgrade_cost.clone())
        }
        fn set_upgrade_office_size(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.upgrade_office_size = value;
            Ok(())
        }
        fn upgrade_office_size(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.upgrade_office_size.clone())
        }
        fn set_get_office(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Office, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_office = value;
            Ok(())
        }
        fn get_office(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Office, JsValue>>,
            JsValue,
        > {
            Ok(self.get_office.clone())
        }
        fn set_set_auto_job_assignment(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.set_auto_job_assignment = value;
            Ok(())
        }
        fn set_auto_job_assignment(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.set_auto_job_assignment.clone())
        }
        fn set_get_hire_ad_vert_count(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_hire_ad_vert_count = value;
            Ok(())
        }
        fn get_hire_ad_vert_count(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_hire_ad_vert_count.clone())
        }
        fn set_hire_ad_vert(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.hire_ad_vert = value;
            Ok(())
        }
        fn hire_ad_vert(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.hire_ad_vert.clone())
        }
        fn set_has_researched(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.has_researched = value;
            Ok(())
        }
        fn has_researched(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.has_researched.clone())
        }
        fn set_research(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.research = value;
            Ok(())
        }
        fn research(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.research.clone())
        }
    }
    impl Corporation_Trait for Corporation
    where
        Corporation: WarehouseApi_Trait + OfficeApi_Trait,
    {
        fn set_has_corporation(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.has_corporation = value;
            Ok(())
        }
        fn has_corporation(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.has_corporation.clone())
        }
        fn set_create_corporation(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.create_corporation = value;
            Ok(())
        }
        fn create_corporation(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.create_corporation.clone())
        }
        fn set_get_bonus_time(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_bonus_time = value;
            Ok(())
        }
        fn get_bonus_time(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_bonus_time.clone())
        }
        fn set_purchase_unlock(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.purchase_unlock = value;
            Ok(())
        }
        fn purchase_unlock(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.purchase_unlock.clone())
        }
        fn set_issue_new_shares(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.issue_new_shares = value;
            Ok(())
        }
        fn issue_new_shares(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.issue_new_shares.clone())
        }
        fn set_get_upgrade_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_upgrade_level = value;
            Ok(())
        }
        fn get_upgrade_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_upgrade_level.clone())
        }
        fn set_get_division(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<Division, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_division = value;
            Ok(())
        }
        fn get_division(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Division, JsValue>>,
            JsValue,
        > {
            Ok(self.get_division.clone())
        }
        fn set_get_unlock_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_unlock_cost = value;
            Ok(())
        }
        fn get_unlock_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_unlock_cost.clone())
        }
        fn set_get_upgrade_level_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_upgrade_level_cost = value;
            Ok(())
        }
        fn get_upgrade_level_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_upgrade_level_cost.clone())
        }
        fn set_go_public(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.go_public = value;
            Ok(())
        }
        fn go_public(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.go_public.clone())
        }
        fn set_get_constants(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<CorpConstants, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_constants = value;
            Ok(())
        }
        fn get_constants(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<CorpConstants, JsValue>>,
            JsValue,
        > {
            Ok(self.get_constants.clone())
        }
        fn set_buy_back_shares(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.buy_back_shares = value;
            Ok(())
        }
        fn buy_back_shares(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.buy_back_shares.clone())
        }
        fn set_has_unlock(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.has_unlock = value;
            Ok(())
        }
        fn has_unlock(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.has_unlock.clone())
        }
        fn set_get_corporation(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<CorporationInfo, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_corporation = value;
            Ok(())
        }
        fn get_corporation(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<CorporationInfo, JsValue>>,
            JsValue,
        > {
            Ok(self.get_corporation.clone())
        }
        fn set_expand_city(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.expand_city = value;
            Ok(())
        }
        fn expand_city(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.expand_city.clone())
        }
        fn set_expand_industry(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(CorpIndustryName, String) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.expand_industry = value;
            Ok(())
        }
        fn expand_industry(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CorpIndustryName, String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.expand_industry.clone())
        }
        fn set_sell_shares(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.sell_shares = value;
            Ok(())
        }
        fn sell_shares(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.sell_shares.clone())
        }
        fn set_issue_dividends(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.issue_dividends = value;
            Ok(())
        }
        fn issue_dividends(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.issue_dividends.clone())
        }
        fn set_accept_investment_offer(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.accept_investment_offer = value;
            Ok(())
        }
        fn accept_investment_offer(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.accept_investment_offer.clone())
        }
        fn set_get_industry_data(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(CorpIndustryName) -> std::result::Result<CorpIndustryData, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_industry_data = value;
            Ok(())
        }
        fn get_industry_data(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CorpIndustryName) -> std::result::Result<CorpIndustryData, JsValue>>,
            JsValue,
        > {
            Ok(self.get_industry_data.clone())
        }
        fn set_get_investment_offer(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<InvestmentOffer, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_investment_offer = value;
            Ok(())
        }
        fn get_investment_offer(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<InvestmentOffer, JsValue>>,
            JsValue,
        > {
            Ok(self.get_investment_offer.clone())
        }
        fn set_bribe(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.bribe = value;
            Ok(())
        }
        fn bribe(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.bribe.clone())
        }
        fn set_get_material_data(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(CorpMaterialName) -> std::result::Result<CorpMaterialConstantData, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_material_data = value;
            Ok(())
        }
        fn get_material_data(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(CorpMaterialName) -> std::result::Result<CorpMaterialConstantData, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.get_material_data.clone())
        }
        fn set_level_upgrade(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.level_upgrade = value;
            Ok(())
        }
        fn level_upgrade(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.level_upgrade.clone())
        }
    }
    impl Corporation {
        #[allow(non_snake_case)]
        fn __TSB__serialize_limit_material_production<S>(
            limit_material_production: &std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let limit_material_production = limit_material_production.clone();
            let limit_material_production_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: f64|
                      -> std::result::Result<(), JsValue> {
                    let result = limit_material_production(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, String, f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &limit_material_production_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_upgrade_level<S>(
            get_upgrade_level: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_upgrade_level = get_upgrade_level.clone();
            let get_upgrade_level_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_upgrade_level(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_upgrade_level_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_hire_ad_vert_cost<S>(
            get_hire_ad_vert_cost: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_hire_ad_vert_cost = get_hire_ad_vert_cost.clone();
            let get_hire_ad_vert_cost_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_hire_ad_vert_cost(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_hire_ad_vert_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_export_material<S>(
            export_material: &std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                    WarehouseApiExportMaterialParamsAmt,
                ) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let export_material = export_material.clone();
            let export_material_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: JsValue,
                      arg4: String,
                      arg5: JsValue|
                      -> std::result::Result<(), JsValue> {
                    let result = export_material(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        ts_bindgen_rt::from_jsvalue(&arg3).map_err(ts_bindgen_rt::Error::from)?,
                        arg4,
                        ts_bindgen_rt::from_jsvalue(&arg5).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        String,
                        JsValue,
                        String,
                        JsValue,
                        String,
                        JsValue,
                    ) -> std::result::Result<(), JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &export_material_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_material_market_ta2<S>(
            set_material_market_ta2: &std::rc::Rc<
                dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_material_market_ta2 = set_material_market_ta2.clone();
            let set_material_market_ta2_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: bool|
                      -> std::result::Result<(), JsValue> {
                    let result = set_material_market_ta2(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, String, bool) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_material_market_ta2_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_purchase_unlock<S>(
            purchase_unlock: &std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let purchase_unlock = purchase_unlock.clone();
            let purchase_unlock_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<(), JsValue> {
                    let result = purchase_unlock(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &purchase_unlock_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_buy_material<S>(
            buy_material: &std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let buy_material = buy_material.clone();
            let buy_material_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: f64|
                      -> std::result::Result<(), JsValue> {
                    let result = buy_material(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, String, f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &buy_material_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_office_size_upgrade_cost<S>(
            get_office_size_upgrade_cost: &std::rc::Rc<
                dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_office_size_upgrade_cost = get_office_size_upgrade_cost.clone();
            let get_office_size_upgrade_cost_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: f64|
                      -> std::result::Result<f64, JsValue> {
                    let result = get_office_size_upgrade_cost(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_office_size_upgrade_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_constants<S>(
            get_constants: &std::rc::Rc<dyn Fn() -> std::result::Result<CorpConstants, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_constants = get_constants.clone();
            let get_constants_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_constants()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_constants_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_product_market_ta1<S>(
            set_product_market_ta1: &std::rc::Rc<
                dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_product_market_ta1 = set_product_market_ta1.clone();
            let set_product_market_ta1_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String, arg2: bool| -> std::result::Result<(), JsValue> {
                    let result = set_product_market_ta1(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_product_market_ta1_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_sell_product<S>(
            sell_product: &std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                    bool,
                ) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let sell_product = sell_product.clone();
            let sell_product_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: String,
                      arg4: String,
                      arg5: bool|
                      -> std::result::Result<(), JsValue> {
                    let result = sell_product(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                        arg4,
                        arg5,
                    )?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        String,
                        JsValue,
                        String,
                        String,
                        String,
                        bool,
                    ) -> std::result::Result<(), JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &sell_product_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_division<S>(
            get_division: &std::rc::Rc<dyn Fn(String) -> std::result::Result<Division, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_division = get_division.clone();
            let get_division_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<JsValue, JsValue> {
                    let result = get_division(arg0)?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_division_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_material_data<S>(
            get_material_data: &std::rc::Rc<
                dyn Fn(CorpMaterialName) -> std::result::Result<CorpMaterialConstantData, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_material_data = get_material_data.clone();
            let get_material_data_closure = Closure::wrap(Box::new(
                move |arg0: JsValue| -> std::result::Result<JsValue, JsValue> {
                    let result = get_material_data(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(JsValue) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_material_data_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_create_corporation<S>(
            create_corporation: &std::rc::Rc<
                dyn Fn(String, bool) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let create_corporation = create_corporation.clone();
            let create_corporation_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: bool| -> std::result::Result<bool, JsValue> {
                    let result = create_corporation(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &create_corporation_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_sell_material<S>(
            sell_material: &std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let sell_material = sell_material.clone();
            let sell_material_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: String,
                      arg4: String|
                      -> std::result::Result<(), JsValue> {
                    let result = sell_material(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                        arg4,
                    )?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        String,
                        JsValue,
                        String,
                        String,
                        String,
                    ) -> std::result::Result<(), JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &sell_material_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_go_public<S>(
            go_public: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let go_public = go_public.clone();
            let go_public_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<bool, JsValue> {
                    let result = go_public(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<bool, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &go_public_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_smart_supply_option<S>(
            set_smart_supply_option: &std::rc::Rc<
                dyn Fn(String, CityName, String, String) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_smart_supply_option = set_smart_supply_option.clone();
            let set_smart_supply_option_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: String|
                      -> std::result::Result<(), JsValue> {
                    let result = set_smart_supply_option(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                    )?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(String, JsValue, String, String) -> std::result::Result<(), JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_smart_supply_option_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_hire_ad_vert<S>(
            hire_ad_vert: &std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hire_ad_vert = hire_ad_vert.clone();
            let hire_ad_vert_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<(), JsValue> {
                    let result = hire_ad_vert(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &hire_ad_vert_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_bribe<S>(
            bribe: &std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let bribe = bribe.clone();
            let bribe_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: f64| -> std::result::Result<bool, JsValue> {
                    let result = bribe(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &bribe_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_hire_employee<S>(
            hire_employee: &std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    CorpEmployeePosition,
                ) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hire_employee = hire_employee.clone();
            let hire_employee_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: JsValue|
                      -> std::result::Result<bool, JsValue> {
                    let result = hire_employee(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg2).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, JsValue) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &hire_employee_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_discontinue_product<S>(
            discontinue_product: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let discontinue_product = discontinue_product.clone();
            let discontinue_product_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<(), JsValue> {
                    let result = discontinue_product(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &discontinue_product_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_research<S>(
            research: &std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let research = research.clone();
            let research_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<(), JsValue> {
                    let result = research(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<(), JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &research_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_buy_tea<S>(
            buy_tea: &std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let buy_tea = buy_tea.clone();
            let buy_tea_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: JsValue| -> std::result::Result<bool, JsValue> {
                    let result = buy_tea(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue) -> std::result::Result<bool, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &buy_tea_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_upgrade_warehouse_cost<S>(
            get_upgrade_warehouse_cost: &std::rc::Rc<
                dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_upgrade_warehouse_cost = get_upgrade_warehouse_cost.clone();
            let get_upgrade_warehouse_cost_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: f64|
                      -> std::result::Result<f64, JsValue> {
                    let result = get_upgrade_warehouse_cost(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_upgrade_warehouse_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_cancel_export_material<S>(
            cancel_export_material: &std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let cancel_export_material = cancel_export_material.clone();
            let cancel_export_material_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: JsValue,
                      arg4: String|
                      -> std::result::Result<(), JsValue> {
                    let result = cancel_export_material(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        ts_bindgen_rt::from_jsvalue(&arg3).map_err(ts_bindgen_rt::Error::from)?,
                        arg4,
                    )?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        String,
                        JsValue,
                        String,
                        JsValue,
                        String,
                    ) -> std::result::Result<(), JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &cancel_export_material_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_unlock_cost<S>(
            get_unlock_cost: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_unlock_cost = get_unlock_cost.clone();
            let get_unlock_cost_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_unlock_cost(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_unlock_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_product<S>(
            get_product: &std::rc::Rc<
                dyn Fn(String, CityName, String) -> std::result::Result<Product, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_product = get_product.clone();
            let get_product_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String|
                      -> std::result::Result<JsValue, JsValue> {
                    let result = get_product(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(String, JsValue, String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_product_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_make_product<S>(
            make_product: &std::rc::Rc<
                dyn Fn(String, CityName, String, f64, f64) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let make_product = make_product.clone();
            let make_product_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: f64,
                      arg4: f64|
                      -> std::result::Result<(), JsValue> {
                    let result = make_product(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                        arg4,
                    )?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(String, JsValue, String, f64, f64) -> std::result::Result<(), JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &make_product_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_corporation<S>(
            get_corporation: &std::rc::Rc<
                dyn Fn() -> std::result::Result<CorporationInfo, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_corporation = get_corporation.clone();
            let get_corporation_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_corporation()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_corporation_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_sell_shares<S>(
            sell_shares: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let sell_shares = sell_shares.clone();
            let sell_shares_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<(), JsValue> {
                    let result = sell_shares(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &sell_shares_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_bulk_purchase<S>(
            bulk_purchase: &std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let bulk_purchase = bulk_purchase.clone();
            let bulk_purchase_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: f64|
                      -> std::result::Result<(), JsValue> {
                    let result = bulk_purchase(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, String, f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &bulk_purchase_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_has_warehouse<S>(
            has_warehouse: &std::rc::Rc<
                dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let has_warehouse = has_warehouse.clone();
            let has_warehouse_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: JsValue| -> std::result::Result<bool, JsValue> {
                    let result = has_warehouse(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &has_warehouse_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_expand_city<S>(
            expand_city: &std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let expand_city = expand_city.clone();
            let expand_city_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: JsValue| -> std::result::Result<(), JsValue> {
                    let result = expand_city(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &expand_city_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_expand_industry<S>(
            expand_industry: &std::rc::Rc<
                dyn Fn(CorpIndustryName, String) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let expand_industry = expand_industry.clone();
            let expand_industry_closure = Closure::wrap(Box::new(
                move |arg0: JsValue, arg1: String| -> std::result::Result<(), JsValue> {
                    let result = expand_industry(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        arg1,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue, String) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &expand_industry_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_warehouse<S>(
            get_warehouse: &std::rc::Rc<
                dyn Fn(String, CityName) -> std::result::Result<Warehouse, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_warehouse = get_warehouse.clone();
            let get_warehouse_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: JsValue| -> std::result::Result<JsValue, JsValue> {
                    let result = get_warehouse(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(String, JsValue) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_warehouse_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_product_market_ta2<S>(
            set_product_market_ta2: &std::rc::Rc<
                dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_product_market_ta2 = set_product_market_ta2.clone();
            let set_product_market_ta2_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String, arg2: bool| -> std::result::Result<(), JsValue> {
                    let result = set_product_market_ta2(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_product_market_ta2_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_upgrade_office_size<S>(
            upgrade_office_size: &std::rc::Rc<
                dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let upgrade_office_size = upgrade_office_size.clone();
            let upgrade_office_size_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: JsValue, arg2: f64| -> std::result::Result<(), JsValue> {
                    let result = upgrade_office_size(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &upgrade_office_size_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_bonus_time<S>(
            get_bonus_time: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_bonus_time = get_bonus_time.clone();
            let get_bonus_time_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_bonus_time()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_bonus_time_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_material_market_ta1<S>(
            set_material_market_ta1: &std::rc::Rc<
                dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_material_market_ta1 = set_material_market_ta1.clone();
            let set_material_market_ta1_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: bool|
                      -> std::result::Result<(), JsValue> {
                    let result = set_material_market_ta1(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, String, bool) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_material_market_ta1_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_has_corporation<S>(
            has_corporation: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let has_corporation = has_corporation.clone();
            let has_corporation_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = has_corporation()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &has_corporation_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_auto_job_assignment<S>(
            set_auto_job_assignment: &std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_auto_job_assignment = set_auto_job_assignment.clone();
            let set_auto_job_assignment_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: f64|
                      -> std::result::Result<bool, JsValue> {
                    let result = set_auto_job_assignment(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, String, f64) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_auto_job_assignment_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_office<S>(
            get_office: &std::rc::Rc<
                dyn Fn(String, CityName) -> std::result::Result<Office, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_office = get_office.clone();
            let get_office_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: JsValue| -> std::result::Result<JsValue, JsValue> {
                    let result = get_office(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(String, JsValue) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_office_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_has_researched<S>(
            has_researched: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let has_researched = has_researched.clone();
            let has_researched_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<bool, JsValue> {
                    let result = has_researched(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &has_researched_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_level_upgrade<S>(
            level_upgrade: &std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let level_upgrade = level_upgrade.clone();
            let level_upgrade_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<(), JsValue> {
                    let result = level_upgrade(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &level_upgrade_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_accept_investment_offer<S>(
            accept_investment_offer: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let accept_investment_offer = accept_investment_offer.clone();
            let accept_investment_offer_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = accept_investment_offer()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &accept_investment_offer_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_purchase_warehouse<S>(
            purchase_warehouse: &std::rc::Rc<
                dyn Fn(String, CityName) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let purchase_warehouse = purchase_warehouse.clone();
            let purchase_warehouse_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: JsValue| -> std::result::Result<(), JsValue> {
                    let result = purchase_warehouse(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &purchase_warehouse_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_upgrade_warehouse<S>(
            upgrade_warehouse: &std::rc::Rc<
                dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let upgrade_warehouse = upgrade_warehouse.clone();
            let upgrade_warehouse_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: JsValue, arg2: f64| -> std::result::Result<(), JsValue> {
                    let result = upgrade_warehouse(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &upgrade_warehouse_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_issue_new_shares<S>(
            issue_new_shares: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let issue_new_shares = issue_new_shares.clone();
            let issue_new_shares_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<f64, JsValue> {
                    let result = issue_new_shares(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &issue_new_shares_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_investment_offer<S>(
            get_investment_offer: &std::rc::Rc<
                dyn Fn() -> std::result::Result<InvestmentOffer, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_investment_offer = get_investment_offer.clone();
            let get_investment_offer_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_investment_offer()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_investment_offer_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_research_cost<S>(
            get_research_cost: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_research_cost = get_research_cost.clone();
            let get_research_cost_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<f64, JsValue> {
                    let result = get_research_cost(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_research_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_throw_party<S>(
            throw_party: &std::rc::Rc<
                dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let throw_party = throw_party.clone();
            let throw_party_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: f64|
                      -> std::result::Result<f64, JsValue> {
                    let result = throw_party(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &throw_party_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_hire_ad_vert_count<S>(
            get_hire_ad_vert_count: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_hire_ad_vert_count = get_hire_ad_vert_count.clone();
            let get_hire_ad_vert_count_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_hire_ad_vert_count(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_hire_ad_vert_count_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_has_unlock<S>(
            has_unlock: &std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let has_unlock = has_unlock.clone();
            let has_unlock_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<bool, JsValue> {
                    let result = has_unlock(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &has_unlock_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_material<S>(
            get_material: &std::rc::Rc<
                dyn Fn(String, CityName, String) -> std::result::Result<Material, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_material = get_material.clone();
            let get_material_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String|
                      -> std::result::Result<JsValue, JsValue> {
                    let result = get_material(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(String, JsValue, String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_material_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_industry_data<S>(
            get_industry_data: &std::rc::Rc<
                dyn Fn(CorpIndustryName) -> std::result::Result<CorpIndustryData, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_industry_data = get_industry_data.clone();
            let get_industry_data_closure = Closure::wrap(Box::new(
                move |arg0: JsValue| -> std::result::Result<JsValue, JsValue> {
                    let result = get_industry_data(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(JsValue) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_industry_data_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_upgrade_level_cost<S>(
            get_upgrade_level_cost: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_upgrade_level_cost = get_upgrade_level_cost.clone();
            let get_upgrade_level_cost_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_upgrade_level_cost(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_upgrade_level_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_limit_product_production<S>(
            limit_product_production: &std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let limit_product_production = limit_product_production.clone();
            let limit_product_production_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: f64|
                      -> std::result::Result<(), JsValue> {
                    let result = limit_product_production(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, String, f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &limit_product_production_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_issue_dividends<S>(
            issue_dividends: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let issue_dividends = issue_dividends.clone();
            let issue_dividends_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<(), JsValue> {
                    let result = issue_dividends(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &issue_dividends_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_smart_supply<S>(
            set_smart_supply: &std::rc::Rc<
                dyn Fn(String, CityName, bool) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_smart_supply = set_smart_supply.clone();
            let set_smart_supply_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: bool|
                      -> std::result::Result<(), JsValue> {
                    let result = set_smart_supply(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, bool) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_smart_supply_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_buy_back_shares<S>(
            buy_back_shares: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let buy_back_shares = buy_back_shares.clone();
            let buy_back_shares_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<(), JsValue> {
                    let result = buy_back_shares(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &buy_back_shares_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_limit_material_production<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let limit_material_production: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            limit_material_production
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: String, arg3: f64| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                f64,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_upgrade_level<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_upgrade_level: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_upgrade_level
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_hire_ad_vert_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_hire_ad_vert_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_hire_ad_vert_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_export_material<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                    WarehouseApiExportMaterialParamsAmt,
                ) -> std::result::Result<(), JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let export_material: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            export_material
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String,
                              arg1: CityName,
                              arg2: String,
                              arg3: CityName,
                              arg4: String,
                              arg5: WarehouseApiExportMaterialParamsAmt| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = ts_bindgen_rt::to_jsvalue(&arg3);
                            let arg4 = JsValue::from(arg4);
                            let arg5 = ts_bindgen_rt::to_jsvalue(&arg5);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            _Args.push(&arg4);
                            _Args.push(&arg5);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                CityName,
                                String,
                                WarehouseApiExportMaterialParamsAmt,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_material_market_ta2<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_material_market_ta2: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_material_market_ta2
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: String, arg3: bool| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                bool,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_purchase_unlock<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let purchase_unlock: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            purchase_unlock
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_buy_material<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let buy_material: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            buy_material
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: String, arg3: f64| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                f64,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_office_size_upgrade_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_office_size_upgrade_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_office_size_upgrade_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_constants<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<CorpConstants, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_constants: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_constants
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<CorpConstants, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_product_market_ta1<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_product_market_ta1: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_product_market_ta1
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String, arg2: bool| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_sell_product<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                    bool,
                ) -> std::result::Result<(), JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let sell_product: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            sell_product
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String,
                              arg1: CityName,
                              arg2: String,
                              arg3: String,
                              arg4: String,
                              arg5: bool| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let arg4 = JsValue::from(arg4);
                            let arg5 = JsValue::from(arg5);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            _Args.push(&arg4);
                            _Args.push(&arg5);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                String,
                                String,
                                bool,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_division<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Division, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_division: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_division
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<Division, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_material_data<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(CorpMaterialName) -> std::result::Result<CorpMaterialConstantData, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_material_data: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_material_data
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: CorpMaterialName| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                CorpMaterialName,
                            )
                                -> std::result::Result<CorpMaterialConstantData, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_create_corporation<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let create_corporation: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            create_corporation
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: bool| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_sell_material<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let sell_material: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            sell_material
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String,
                              arg1: CityName,
                              arg2: String,
                              arg3: String,
                              arg4: String| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let arg4 = JsValue::from(arg4);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            _Args.push(&arg4);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                String,
                                String,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_go_public<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let go_public: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            go_public
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_smart_supply_option<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, CityName, String, String) -> std::result::Result<(), JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_smart_supply_option: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_smart_supply_option
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: String, arg3: String| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                String,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hire_ad_vert<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hire_ad_vert: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            hire_ad_vert
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_bribe<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let bribe: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            bribe
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hire_employee<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    CorpEmployeePosition,
                ) -> std::result::Result<bool, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hire_employee: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            hire_employee
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: CorpEmployeePosition| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = ts_bindgen_rt::to_jsvalue(&arg2);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                CorpEmployeePosition,
                            )
                                -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_discontinue_product<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let discontinue_product: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            discontinue_product
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_research<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let research: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            research
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_buy_tea<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let buy_tea: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            buy_tea
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_upgrade_warehouse_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_upgrade_warehouse_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_upgrade_warehouse_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_cancel_export_material<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let cancel_export_material: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            cancel_export_material
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String,
                              arg1: CityName,
                              arg2: String,
                              arg3: CityName,
                              arg4: String| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = ts_bindgen_rt::to_jsvalue(&arg3);
                            let arg4 = JsValue::from(arg4);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            _Args.push(&arg4);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                CityName,
                                String,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_unlock_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_unlock_cost: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_unlock_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_product<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String) -> std::result::Result<Product, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_product: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_product
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName, arg2: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                            )
                                -> std::result::Result<Product, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_make_product<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, CityName, String, f64, f64) -> std::result::Result<(), JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let make_product: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            make_product
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: String, arg3: f64, arg4: f64| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let arg4 = JsValue::from(arg4);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            _Args.push(&arg4);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                f64,
                                f64,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_corporation<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<CorporationInfo, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_corporation: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_corporation
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<CorporationInfo, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_sell_shares<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let sell_shares: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            sell_shares
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_bulk_purchase<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let bulk_purchase: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            bulk_purchase
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: String, arg3: f64| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                f64,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_has_warehouse<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let has_warehouse: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            has_warehouse
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_expand_city<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let expand_city: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            expand_city
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_expand_industry<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CorpIndustryName, String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let expand_industry: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            expand_industry
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: CorpIndustryName, arg1: String| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(CorpIndustryName, String) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_warehouse<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Warehouse, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_warehouse: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_warehouse
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName) -> std::result::Result<Warehouse, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_product_market_ta2<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_product_market_ta2: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_product_market_ta2
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String, arg2: bool| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_upgrade_office_size<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let upgrade_office_size: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            upgrade_office_size
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_bonus_time<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_bonus_time: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_bonus_time
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_material_market_ta1<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_material_market_ta1: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_material_market_ta1
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: String, arg3: bool| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                bool,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_has_corporation<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let has_corporation: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            has_corporation
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_auto_job_assignment<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<bool, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_auto_job_assignment: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_auto_job_assignment
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: String, arg3: f64| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                f64,
                            )
                                -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_office<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Office, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_office: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_office
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName) -> std::result::Result<Office, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_has_researched<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let has_researched: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            has_researched
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_level_upgrade<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let level_upgrade: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            level_upgrade
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_accept_investment_offer<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let accept_investment_offer: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            accept_investment_offer
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_purchase_warehouse<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let purchase_warehouse: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            purchase_warehouse
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_upgrade_warehouse<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let upgrade_warehouse: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            upgrade_warehouse
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_issue_new_shares<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let issue_new_shares: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            issue_new_shares
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_investment_offer<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<InvestmentOffer, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_investment_offer: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_investment_offer
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<InvestmentOffer, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_research_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_research_cost: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_research_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_throw_party<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let throw_party: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            throw_party
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_hire_ad_vert_count<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_hire_ad_vert_count: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_hire_ad_vert_count
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_has_unlock<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let has_unlock: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            has_unlock
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_material<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String) -> std::result::Result<Material, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_material: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_material
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName, arg2: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                            )
                                -> std::result::Result<Material, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_industry_data<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CorpIndustryName) -> std::result::Result<CorpIndustryData, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_industry_data: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_industry_data
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: CorpIndustryName| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                CorpIndustryName,
                            )
                                -> std::result::Result<CorpIndustryData, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_upgrade_level_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_upgrade_level_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_upgrade_level_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_limit_product_production<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let limit_product_production: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            limit_product_production
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: String, arg3: f64| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                f64,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_issue_dividends<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let issue_dividends: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            issue_dividends
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_smart_supply<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, bool) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_smart_supply: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_smart_supply
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName, arg2: bool| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName, bool) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_buy_back_shares<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let buy_back_shares: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            buy_back_shares
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct BladeburnerCurAction {
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "type")]
        pub type_: String,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait BladeburnerCurAction_Trait {
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn name(&self) -> std::result::Result<String, JsValue>;
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn type_(&self) -> std::result::Result<String, JsValue>;
    }
    impl BladeburnerCurAction_Trait for BladeburnerCurAction {
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.name = value;
            Ok(())
        }
        fn name(&self) -> std::result::Result<String, JsValue> {
            Ok(self.name.clone())
        }
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.type_ = value;
            Ok(())
        }
        fn type_(&self) -> std::result::Result<String, JsValue> {
            Ok(self.type_.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsGetRunningScriptReturn {
        RunningScript(RunningScript),
        TsBindgenRtNull,
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsSpawnParamsArgs {
        Bool(bool),
        F64(f64),
        String(String),
    }
    #[wasm_bindgen]
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum JobName {
        Software0 = "Software Engineering Intern",
        Software1 = "Junior Software Engineer",
        Software2 = "Senior Software Engineer",
        Software3 = "Lead Software Developer",
        Software4 = "Head of Software",
        Software5 = "Head of Engineering",
        Software6 = "Vice President of Technology",
        Software7 = "Chief Technology Officer",
        It0 = "IT Intern",
        It1 = "IT Analyst",
        It2 = "IT Manager",
        It3 = "Systems Administrator",
        SecurityEng = "Security Engineer",
        NetworkEng0 = "Network Engineer",
        NetworkEng1 = "Network Administrator",
        Business0 = "Business Intern",
        Business1 = "Business Analyst",
        Business2 = "Business Manager",
        Business3 = "Operations Manager",
        Business4 = "Chief Financial Officer",
        Business5 = "Chief Executive Officer",
        Security0 = "Police Officer",
        Security1 = "Police Chief",
        Security2 = "Security Guard",
        Security3 = "Security Officer",
        Security4 = "Security Supervisor",
        Security5 = "Head of Security",
        Agent0 = "Field Agent",
        Agent1 = "Secret Agent",
        Agent2 = "Special Operative",
        Waiter = "Waiter",
        Employee = "Employee",
        SoftwareConsult0 = "Software Consultant",
        SoftwareConsult1 = "Senior Software Consultant",
        BusinessConsult0 = "Business Consultant",
        BusinessConsult1 = "Senior Business Consultant",
        WaiterPt = "Part-time Waiter",
        EmployeePt = "Part-time Employee",
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct CompanyPositionInfo {
        #[serde(rename = "nextPosition")]
        pub next_position: CompanyPositionInfoNextPosition,
        #[serde(rename = "name")]
        pub name: JobName,
        #[serde(rename = "requiredSkills")]
        pub required_skills: Skills,
        #[serde(rename = "requiredReputation")]
        pub required_reputation: f64,
        #[serde(rename = "salary")]
        pub salary: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait CompanyPositionInfo_Trait {
        fn set_next_position(
            &mut self,
            value: CompanyPositionInfoNextPosition,
        ) -> std::result::Result<(), JsValue>;
        fn next_position(&self) -> std::result::Result<CompanyPositionInfoNextPosition, JsValue>;
        fn set_salary(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn salary(&self) -> std::result::Result<f64, JsValue>;
        fn set_required_reputation(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn required_reputation(&self) -> std::result::Result<f64, JsValue>;
        fn set_required_skills(&mut self, value: Skills) -> std::result::Result<(), JsValue>;
        fn required_skills(&self) -> std::result::Result<Skills, JsValue>;
        fn set_name(&mut self, value: JobName) -> std::result::Result<(), JsValue>;
        fn name(&self) -> std::result::Result<JobName, JsValue>;
    }
    impl CompanyPositionInfo_Trait for CompanyPositionInfo {
        fn set_next_position(
            &mut self,
            value: CompanyPositionInfoNextPosition,
        ) -> std::result::Result<(), JsValue> {
            self.next_position = value;
            Ok(())
        }
        fn next_position(&self) -> std::result::Result<CompanyPositionInfoNextPosition, JsValue> {
            Ok(self.next_position.clone())
        }
        fn set_salary(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.salary = value;
            Ok(())
        }
        fn salary(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.salary)
        }
        fn set_required_reputation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.required_reputation = value;
            Ok(())
        }
        fn required_reputation(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.required_reputation)
        }
        fn set_required_skills(&mut self, value: Skills) -> std::result::Result<(), JsValue> {
            self.required_skills = value;
            Ok(())
        }
        fn required_skills(&self) -> std::result::Result<Skills, JsValue> {
            Ok(self.required_skills.clone())
        }
        fn set_name(&mut self, value: JobName) -> std::result::Result<(), JsValue> {
            self.name = value;
            Ok(())
        }
        fn name(&self) -> std::result::Result<JobName, JsValue> {
            Ok(self.name.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Product {
        #[serde(rename = "stats")]
        pub stats: ProductStats,
        #[serde(rename = "desiredSellAmount")]
        pub desired_sell_amount: ProductDesiredSellAmount,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "competition")]
        pub competition: ProductCompetition,
        #[serde(rename = "effectiveRating")]
        pub effective_rating: f64,
        #[serde(rename = "actualSellAmount")]
        pub actual_sell_amount: f64,
        #[serde(rename = "stored")]
        pub stored: f64,
        #[serde(rename = "productionAmount")]
        pub production_amount: f64,
        #[serde(rename = "desiredSellPrice")]
        pub desired_sell_price: ProductDesiredSellPrice,
        #[serde(rename = "productionCost")]
        pub production_cost: f64,
        #[serde(rename = "rating")]
        pub rating: f64,
        #[serde(rename = "demand")]
        pub demand: ProductDemand,
        #[serde(rename = "developmentProgress")]
        pub development_progress: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait Product_Trait {
        fn set_production_amount(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn production_amount(&self) -> std::result::Result<f64, JsValue>;
        fn set_actual_sell_amount(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn actual_sell_amount(&self) -> std::result::Result<f64, JsValue>;
        fn set_development_progress(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn development_progress(&self) -> std::result::Result<f64, JsValue>;
        fn set_stored(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn stored(&self) -> std::result::Result<f64, JsValue>;
        fn set_rating(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn rating(&self) -> std::result::Result<f64, JsValue>;
        fn set_production_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn production_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_stats(&mut self, value: ProductStats) -> std::result::Result<(), JsValue>;
        fn stats(&self) -> std::result::Result<ProductStats, JsValue>;
        fn set_desired_sell_price(
            &mut self,
            value: ProductDesiredSellPrice,
        ) -> std::result::Result<(), JsValue>;
        fn desired_sell_price(&self) -> std::result::Result<ProductDesiredSellPrice, JsValue>;
        fn set_desired_sell_amount(
            &mut self,
            value: ProductDesiredSellAmount,
        ) -> std::result::Result<(), JsValue>;
        fn desired_sell_amount(&self) -> std::result::Result<ProductDesiredSellAmount, JsValue>;
        fn set_demand(&mut self, value: ProductDemand) -> std::result::Result<(), JsValue>;
        fn demand(&self) -> std::result::Result<ProductDemand, JsValue>;
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn name(&self) -> std::result::Result<String, JsValue>;
        fn set_competition(
            &mut self,
            value: ProductCompetition,
        ) -> std::result::Result<(), JsValue>;
        fn competition(&self) -> std::result::Result<ProductCompetition, JsValue>;
        fn set_effective_rating(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn effective_rating(&self) -> std::result::Result<f64, JsValue>;
    }
    impl Product_Trait for Product {
        fn set_production_amount(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.production_amount = value;
            Ok(())
        }
        fn production_amount(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.production_amount)
        }
        fn set_actual_sell_amount(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.actual_sell_amount = value;
            Ok(())
        }
        fn actual_sell_amount(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.actual_sell_amount)
        }
        fn set_development_progress(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.development_progress = value;
            Ok(())
        }
        fn development_progress(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.development_progress)
        }
        fn set_stored(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.stored = value;
            Ok(())
        }
        fn stored(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.stored)
        }
        fn set_rating(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.rating = value;
            Ok(())
        }
        fn rating(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.rating)
        }
        fn set_production_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.production_cost = value;
            Ok(())
        }
        fn production_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.production_cost)
        }
        fn set_stats(&mut self, value: ProductStats) -> std::result::Result<(), JsValue> {
            self.stats = value;
            Ok(())
        }
        fn stats(&self) -> std::result::Result<ProductStats, JsValue> {
            Ok(self.stats.clone())
        }
        fn set_desired_sell_price(
            &mut self,
            value: ProductDesiredSellPrice,
        ) -> std::result::Result<(), JsValue> {
            self.desired_sell_price = value;
            Ok(())
        }
        fn desired_sell_price(&self) -> std::result::Result<ProductDesiredSellPrice, JsValue> {
            Ok(self.desired_sell_price.clone())
        }
        fn set_desired_sell_amount(
            &mut self,
            value: ProductDesiredSellAmount,
        ) -> std::result::Result<(), JsValue> {
            self.desired_sell_amount = value;
            Ok(())
        }
        fn desired_sell_amount(&self) -> std::result::Result<ProductDesiredSellAmount, JsValue> {
            Ok(self.desired_sell_amount.clone())
        }
        fn set_demand(&mut self, value: ProductDemand) -> std::result::Result<(), JsValue> {
            self.demand = value;
            Ok(())
        }
        fn demand(&self) -> std::result::Result<ProductDemand, JsValue> {
            Ok(self.demand.clone())
        }
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.name = value;
            Ok(())
        }
        fn name(&self) -> std::result::Result<String, JsValue> {
            Ok(self.name.clone())
        }
        fn set_competition(
            &mut self,
            value: ProductCompetition,
        ) -> std::result::Result<(), JsValue> {
            self.competition = value;
            Ok(())
        }
        fn competition(&self) -> std::result::Result<ProductCompetition, JsValue> {
            Ok(self.competition.clone())
        }
        fn set_effective_rating(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.effective_rating = value;
            Ok(())
        }
        fn effective_rating(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.effective_rating)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Office {
        #[serde(rename = "maxMorale")]
        pub max_morale: f64,
        #[serde(rename = "totalExperience")]
        pub total_experience: f64,
        #[serde(rename = "city")]
        pub city: CityName,
        #[serde(rename = "maxEnergy")]
        pub max_energy: f64,
        #[serde(rename = "avgMorale")]
        pub avg_morale: f64,
        #[serde(rename = "employeeProductionByJob")]
        pub employee_production_by_job: std::collections::HashMap<String, f64>,
        #[serde(rename = "avgEnergy")]
        pub avg_energy: f64,
        #[serde(rename = "numEmployees")]
        pub num_employees: f64,
        #[serde(rename = "size")]
        pub size: f64,
        #[serde(rename = "employeeJobs")]
        pub employee_jobs: std::collections::HashMap<String, f64>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait Office_Trait {
        fn set_employee_production_by_job(
            &mut self,
            value: std::collections::HashMap<String, f64>,
        ) -> std::result::Result<(), JsValue>;
        fn employee_production_by_job(
            &self,
        ) -> std::result::Result<std::collections::HashMap<String, f64>, JsValue>;
        fn set_employee_jobs(
            &mut self,
            value: std::collections::HashMap<String, f64>,
        ) -> std::result::Result<(), JsValue>;
        fn employee_jobs(
            &self,
        ) -> std::result::Result<std::collections::HashMap<String, f64>, JsValue>;
        fn set_total_experience(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn total_experience(&self) -> std::result::Result<f64, JsValue>;
        fn set_city(&mut self, value: CityName) -> std::result::Result<(), JsValue>;
        fn city(&self) -> std::result::Result<CityName, JsValue>;
        fn set_num_employees(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn num_employees(&self) -> std::result::Result<f64, JsValue>;
        fn set_max_energy(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn max_energy(&self) -> std::result::Result<f64, JsValue>;
        fn set_size(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn size(&self) -> std::result::Result<f64, JsValue>;
        fn set_max_morale(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn max_morale(&self) -> std::result::Result<f64, JsValue>;
        fn set_avg_morale(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn avg_morale(&self) -> std::result::Result<f64, JsValue>;
        fn set_avg_energy(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn avg_energy(&self) -> std::result::Result<f64, JsValue>;
    }
    impl Office_Trait for Office {
        fn set_employee_production_by_job(
            &mut self,
            value: std::collections::HashMap<String, f64>,
        ) -> std::result::Result<(), JsValue> {
            self.employee_production_by_job = value;
            Ok(())
        }
        fn employee_production_by_job(
            &self,
        ) -> std::result::Result<std::collections::HashMap<String, f64>, JsValue> {
            Ok(self.employee_production_by_job.clone())
        }
        fn set_employee_jobs(
            &mut self,
            value: std::collections::HashMap<String, f64>,
        ) -> std::result::Result<(), JsValue> {
            self.employee_jobs = value;
            Ok(())
        }
        fn employee_jobs(
            &self,
        ) -> std::result::Result<std::collections::HashMap<String, f64>, JsValue> {
            Ok(self.employee_jobs.clone())
        }
        fn set_total_experience(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.total_experience = value;
            Ok(())
        }
        fn total_experience(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.total_experience)
        }
        fn set_city(&mut self, value: CityName) -> std::result::Result<(), JsValue> {
            self.city = value;
            Ok(())
        }
        fn city(&self) -> std::result::Result<CityName, JsValue> {
            Ok(self.city.clone())
        }
        fn set_num_employees(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.num_employees = value;
            Ok(())
        }
        fn num_employees(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.num_employees)
        }
        fn set_max_energy(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.max_energy = value;
            Ok(())
        }
        fn max_energy(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.max_energy)
        }
        fn set_size(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.size = value;
            Ok(())
        }
        fn size(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.size)
        }
        fn set_max_morale(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.max_morale = value;
            Ok(())
        }
        fn max_morale(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.max_morale)
        }
        fn set_avg_morale(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.avg_morale = value;
            Ok(())
        }
        fn avg_morale(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.avg_morale)
        }
        fn set_avg_energy(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.avg_energy = value;
            Ok(())
        }
        fn avg_energy(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.avg_energy)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct NsEnumsAliased {
        #[serde(rename = "FactionWorkType")]
        pub faction_work_type: FactionWorkType,
        #[serde(rename = "JobName")]
        pub job_name: JobName,
        #[serde(rename = "ToastVariant")]
        pub toast_variant: ToastVariant,
        #[serde(rename = "GymType")]
        pub gym_type: GymType,
        #[serde(rename = "CityName")]
        pub city_name: CityName,
        #[serde(rename = "UniversityClassType")]
        pub university_class_type: UniversityClassType,
        #[serde(rename = "LocationName")]
        pub location_name: LocationName,
        #[serde(rename = "CrimeType")]
        pub crime_type: CrimeType,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait NsEnumsAliased_Trait {
        fn set_gym_type(&mut self, value: GymType) -> std::result::Result<(), JsValue>;
        fn gym_type(&self) -> std::result::Result<GymType, JsValue>;
        fn set_location_name(&mut self, value: LocationName) -> std::result::Result<(), JsValue>;
        fn location_name(&self) -> std::result::Result<LocationName, JsValue>;
        fn set_university_class_type(
            &mut self,
            value: UniversityClassType,
        ) -> std::result::Result<(), JsValue>;
        fn university_class_type(&self) -> std::result::Result<UniversityClassType, JsValue>;
        fn set_crime_type(&mut self, value: CrimeType) -> std::result::Result<(), JsValue>;
        fn crime_type(&self) -> std::result::Result<CrimeType, JsValue>;
        fn set_faction_work_type(
            &mut self,
            value: FactionWorkType,
        ) -> std::result::Result<(), JsValue>;
        fn faction_work_type(&self) -> std::result::Result<FactionWorkType, JsValue>;
        fn set_job_name(&mut self, value: JobName) -> std::result::Result<(), JsValue>;
        fn job_name(&self) -> std::result::Result<JobName, JsValue>;
        fn set_city_name(&mut self, value: CityName) -> std::result::Result<(), JsValue>;
        fn city_name(&self) -> std::result::Result<CityName, JsValue>;
        fn set_toast_variant(&mut self, value: ToastVariant) -> std::result::Result<(), JsValue>;
        fn toast_variant(&self) -> std::result::Result<ToastVariant, JsValue>;
    }
    impl NsEnumsAliased_Trait for NsEnumsAliased {
        fn set_gym_type(&mut self, value: GymType) -> std::result::Result<(), JsValue> {
            self.gym_type = value;
            Ok(())
        }
        fn gym_type(&self) -> std::result::Result<GymType, JsValue> {
            Ok(self.gym_type.clone())
        }
        fn set_location_name(&mut self, value: LocationName) -> std::result::Result<(), JsValue> {
            self.location_name = value;
            Ok(())
        }
        fn location_name(&self) -> std::result::Result<LocationName, JsValue> {
            Ok(self.location_name.clone())
        }
        fn set_university_class_type(
            &mut self,
            value: UniversityClassType,
        ) -> std::result::Result<(), JsValue> {
            self.university_class_type = value;
            Ok(())
        }
        fn university_class_type(&self) -> std::result::Result<UniversityClassType, JsValue> {
            Ok(self.university_class_type.clone())
        }
        fn set_crime_type(&mut self, value: CrimeType) -> std::result::Result<(), JsValue> {
            self.crime_type = value;
            Ok(())
        }
        fn crime_type(&self) -> std::result::Result<CrimeType, JsValue> {
            Ok(self.crime_type.clone())
        }
        fn set_faction_work_type(
            &mut self,
            value: FactionWorkType,
        ) -> std::result::Result<(), JsValue> {
            self.faction_work_type = value;
            Ok(())
        }
        fn faction_work_type(&self) -> std::result::Result<FactionWorkType, JsValue> {
            Ok(self.faction_work_type.clone())
        }
        fn set_job_name(&mut self, value: JobName) -> std::result::Result<(), JsValue> {
            self.job_name = value;
            Ok(())
        }
        fn job_name(&self) -> std::result::Result<JobName, JsValue> {
            Ok(self.job_name.clone())
        }
        fn set_city_name(&mut self, value: CityName) -> std::result::Result<(), JsValue> {
            self.city_name = value;
            Ok(())
        }
        fn city_name(&self) -> std::result::Result<CityName, JsValue> {
            Ok(self.city_name.clone())
        }
        fn set_toast_variant(&mut self, value: ToastVariant) -> std::result::Result<(), JsValue> {
            self.toast_variant = value;
            Ok(())
        }
        fn toast_variant(&self) -> std::result::Result<ToastVariant, JsValue> {
            Ok(self.toast_variant.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct SleeveBladeburnerTaskAliased {
        #[serde(rename = "actionName")]
        pub action_name: String,
        #[serde(rename = "actionType")]
        pub action_type: SleeveBladeburnerTaskAliasedActionType,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "cyclesWorked")]
        pub cycles_worked: f64,
        #[serde(rename = "cyclesNeeded")]
        pub cycles_needed: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait SleeveBladeburnerTaskAliased_Trait {
        fn set_cycles_worked(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cycles_worked(&self) -> std::result::Result<f64, JsValue>;
        fn set_action_type(
            &mut self,
            value: SleeveBladeburnerTaskAliasedActionType,
        ) -> std::result::Result<(), JsValue>;
        fn action_type(
            &self,
        ) -> std::result::Result<SleeveBladeburnerTaskAliasedActionType, JsValue>;
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn type_(&self) -> std::result::Result<String, JsValue>;
        fn set_action_name(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn action_name(&self) -> std::result::Result<String, JsValue>;
        fn set_cycles_needed(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cycles_needed(&self) -> std::result::Result<f64, JsValue>;
    }
    impl SleeveBladeburnerTaskAliased_Trait for SleeveBladeburnerTaskAliased {
        fn set_cycles_worked(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cycles_worked = value;
            Ok(())
        }
        fn cycles_worked(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cycles_worked)
        }
        fn set_action_type(
            &mut self,
            value: SleeveBladeburnerTaskAliasedActionType,
        ) -> std::result::Result<(), JsValue> {
            self.action_type = value;
            Ok(())
        }
        fn action_type(
            &self,
        ) -> std::result::Result<SleeveBladeburnerTaskAliasedActionType, JsValue> {
            Ok(self.action_type.clone())
        }
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.type_ = value;
            Ok(())
        }
        fn type_(&self) -> std::result::Result<String, JsValue> {
            Ok(self.type_.clone())
        }
        fn set_action_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.action_name = value;
            Ok(())
        }
        fn action_name(&self) -> std::result::Result<String, JsValue> {
            Ok(self.action_name.clone())
        }
        fn set_cycles_needed(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cycles_needed = value;
            Ok(())
        }
        fn cycles_needed(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cycles_needed)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsFlagsParamsSchemaTuple1 {
        VecOfString(Vec<String>),
        Bool(bool),
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum CorpEmployeePositionAliased {
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct WorkStats {
        #[serde(rename = "intExp")]
        pub int_exp: f64,
        #[serde(rename = "dexExp")]
        pub dex_exp: f64,
        #[serde(rename = "defExp")]
        pub def_exp: f64,
        #[serde(rename = "reputation")]
        pub reputation: f64,
        #[serde(rename = "chaExp")]
        pub cha_exp: f64,
        #[serde(rename = "strExp")]
        pub str_exp: f64,
        #[serde(rename = "agiExp")]
        pub agi_exp: f64,
        #[serde(rename = "money")]
        pub money: f64,
        #[serde(rename = "hackExp")]
        pub hack_exp: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait WorkStats_Trait {
        fn set_agi_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn agi_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn money(&self) -> std::result::Result<f64, JsValue>;
        fn set_cha_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cha_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_dex_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn dex_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_def_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn def_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_int_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn int_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_reputation(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn reputation(&self) -> std::result::Result<f64, JsValue>;
        fn set_hack_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hack_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_str_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn str_exp(&self) -> std::result::Result<f64, JsValue>;
    }
    impl WorkStats_Trait for WorkStats {
        fn set_agi_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.agi_exp = value;
            Ok(())
        }
        fn agi_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.agi_exp)
        }
        fn set_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.money = value;
            Ok(())
        }
        fn money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.money)
        }
        fn set_cha_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cha_exp = value;
            Ok(())
        }
        fn cha_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cha_exp)
        }
        fn set_dex_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.dex_exp = value;
            Ok(())
        }
        fn dex_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.dex_exp)
        }
        fn set_def_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.def_exp = value;
            Ok(())
        }
        fn def_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.def_exp)
        }
        fn set_int_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.int_exp = value;
            Ok(())
        }
        fn int_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.int_exp)
        }
        fn set_reputation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.reputation = value;
            Ok(())
        }
        fn reputation(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.reputation)
        }
        fn set_hack_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hack_exp = value;
            Ok(())
        }
        fn hack_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hack_exp)
        }
        fn set_str_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.str_exp = value;
            Ok(())
        }
        fn str_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.str_exp)
        }
    }
    #[allow(dead_code, non_camel_case_types)]
    type SleeveFactionTask = SleeveFactionTaskAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum CorpUpgradeNameAliased {
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum RunningScriptArgs {
        Bool(bool),
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsWritePortParamsData {
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsExecParamsArgs {
        Bool(bool),
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct CodingContract {
        #[serde(
            rename = "attempt",
            serialize_with = "CodingContract::__TSB__serialize_attempt",
            deserialize_with = "CodingContract::__TSB__deserialize_attempt"
        )]
        pub attempt: std::rc::Rc<
            dyn Fn(
                CodingContractAttemptParamsAnswer,
                String,
                String,
            ) -> std::result::Result<String, JsValue>,
        >,
        #[serde(
            rename = "getData",
            serialize_with = "CodingContract::__TSB__serialize_get_data",
            deserialize_with = "CodingContract::__TSB__deserialize_get_data"
        )]
        pub get_data:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<CodingContractData, JsValue>>,
        #[serde(
            rename = "createDummyContract",
            serialize_with = "CodingContract::__TSB__serialize_create_dummy_contract",
            deserialize_with = "CodingContract::__TSB__deserialize_create_dummy_contract"
        )]
        pub create_dummy_contract: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "getContractType",
            serialize_with = "CodingContract::__TSB__serialize_get_contract_type",
            deserialize_with = "CodingContract::__TSB__deserialize_get_contract_type"
        )]
        pub get_contract_type:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<String, JsValue>>,
        #[serde(
            rename = "getDescription",
            serialize_with = "CodingContract::__TSB__serialize_get_description",
            deserialize_with = "CodingContract::__TSB__deserialize_get_description"
        )]
        pub get_description:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<String, JsValue>>,
        #[serde(
            rename = "getContractTypes",
            serialize_with = "CodingContract::__TSB__serialize_get_contract_types",
            deserialize_with = "CodingContract::__TSB__deserialize_get_contract_types"
        )]
        pub get_contract_types: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "getNumTriesRemaining",
            serialize_with = "CodingContract::__TSB__serialize_get_num_tries_remaining",
            deserialize_with = "CodingContract::__TSB__deserialize_get_num_tries_remaining"
        )]
        pub get_num_tries_remaining:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait CodingContract_Trait {
        fn set_get_data(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<CodingContractData, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_data(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<CodingContractData, JsValue>>,
            JsValue,
        >;
        fn set_get_description(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_description(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<String, JsValue>>,
            JsValue,
        >;
        fn set_create_dummy_contract(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn create_dummy_contract(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_get_num_tries_remaining(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_num_tries_remaining(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_attempt(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    CodingContractAttemptParamsAnswer,
                    String,
                    String,
                ) -> std::result::Result<String, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn attempt(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    CodingContractAttemptParamsAnswer,
                    String,
                    String,
                ) -> std::result::Result<String, JsValue>,
            >,
            JsValue,
        >;
        fn set_get_contract_types(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_contract_types(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_get_contract_type(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_contract_type(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<String, JsValue>>,
            JsValue,
        >;
    }
    impl CodingContract_Trait for CodingContract {
        fn set_get_data(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<CodingContractData, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_data = value;
            Ok(())
        }
        fn get_data(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<CodingContractData, JsValue>>,
            JsValue,
        > {
            Ok(self.get_data.clone())
        }
        fn set_get_description(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_description = value;
            Ok(())
        }
        fn get_description(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<String, JsValue>>,
            JsValue,
        > {
            Ok(self.get_description.clone())
        }
        fn set_create_dummy_contract(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.create_dummy_contract = value;
            Ok(())
        }
        fn create_dummy_contract(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.create_dummy_contract.clone())
        }
        fn set_get_num_tries_remaining(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_num_tries_remaining = value;
            Ok(())
        }
        fn get_num_tries_remaining(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_num_tries_remaining.clone())
        }
        fn set_attempt(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    CodingContractAttemptParamsAnswer,
                    String,
                    String,
                ) -> std::result::Result<String, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.attempt = value;
            Ok(())
        }
        fn attempt(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    CodingContractAttemptParamsAnswer,
                    String,
                    String,
                ) -> std::result::Result<String, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.attempt.clone())
        }
        fn set_get_contract_types(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_contract_types = value;
            Ok(())
        }
        fn get_contract_types(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_contract_types.clone())
        }
        fn set_get_contract_type(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_contract_type = value;
            Ok(())
        }
        fn get_contract_type(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<String, JsValue>>,
            JsValue,
        > {
            Ok(self.get_contract_type.clone())
        }
    }
    impl CodingContract {
        #[allow(non_snake_case)]
        fn __TSB__serialize_attempt<S>(
            attempt: &std::rc::Rc<
                dyn Fn(
                    CodingContractAttemptParamsAnswer,
                    String,
                    String,
                ) -> std::result::Result<String, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let attempt = attempt.clone();
            let attempt_closure = Closure::wrap(Box::new(
                move |arg0: JsValue,
                      arg1: String,
                      arg2: String|
                      -> std::result::Result<String, JsValue> {
                    let result = attempt(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        arg1,
                        arg2,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue, String, String) -> std::result::Result<String, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &attempt_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_data<S>(
            get_data: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<CodingContractData, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_data = get_data.clone();
            let get_data_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: String|
                      -> std::result::Result<CodingContractData, JsValue> {
                    let result = get_data(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<CodingContractData, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &get_data_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_create_dummy_contract<S>(
            create_dummy_contract: &std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let create_dummy_contract = create_dummy_contract.clone();
            let create_dummy_contract_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<(), JsValue> {
                    let result = create_dummy_contract(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &create_dummy_contract_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_contract_type<S>(
            get_contract_type: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<String, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_contract_type = get_contract_type.clone();
            let get_contract_type_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<String, JsValue> {
                    let result = get_contract_type(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<String, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_contract_type_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_description<S>(
            get_description: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<String, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_description = get_description.clone();
            let get_description_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<String, JsValue> {
                    let result = get_description(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<String, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_description_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_contract_types<S>(
            get_contract_types: &std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_contract_types = get_contract_types.clone();
            let get_contract_types_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_contract_types()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_contract_types_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_num_tries_remaining<S>(
            get_num_tries_remaining: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_num_tries_remaining = get_num_tries_remaining.clone();
            let get_num_tries_remaining_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<f64, JsValue> {
                    let result = get_num_tries_remaining(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_num_tries_remaining_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_attempt<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    CodingContractAttemptParamsAnswer,
                    String,
                    String,
                ) -> std::result::Result<String, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let attempt: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            attempt
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: CodingContractAttemptParamsAnswer,
                              arg1: String,
                              arg2: String| {
                            let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                            let arg1 = JsValue::from(arg1);
                            let arg2 = JsValue::from(arg2);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                CodingContractAttemptParamsAnswer,
                                String,
                                String,
                            )
                                -> std::result::Result<String, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_data<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<CodingContractData, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_data: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_data
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret)
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                String,
                            )
                                -> std::result::Result<CodingContractData, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_create_dummy_contract<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let create_dummy_contract: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            create_dummy_contract
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_contract_type<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<String, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_contract_type: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_contract_type
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, String) -> std::result::Result<String, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_description<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<String, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_description: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_description
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, String) -> std::result::Result<String, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_contract_types<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_contract_types: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_contract_types
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_num_tries_remaining<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_num_tries_remaining: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_num_tries_remaining
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[allow(dead_code, non_camel_case_types)]
    type PortData = PortDataAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum PortDataAliased {
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct SleeveSynchroTaskAliased {
        #[serde(rename = "type")]
        pub type_: String,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait SleeveSynchroTaskAliased_Trait {
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn type_(&self) -> std::result::Result<String, JsValue>;
    }
    impl SleeveSynchroTaskAliased_Trait for SleeveSynchroTaskAliased {
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.type_ = value;
            Ok(())
        }
        fn type_(&self) -> std::result::Result<String, JsValue> {
            Ok(self.type_.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct NodeStats {
        #[serde(rename = "cache")]
        pub cache: Option<f64>,
        #[serde(rename = "level")]
        pub level: f64,
        #[serde(rename = "totalProduction")]
        pub total_production: f64,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "hashCapacity")]
        pub hash_capacity: Option<f64>,
        #[serde(rename = "production")]
        pub production: f64,
        #[serde(rename = "cores")]
        pub cores: f64,
        #[serde(rename = "ram")]
        pub ram: f64,
        #[serde(rename = "ramUsed")]
        pub ram_used: Option<f64>,
        #[serde(rename = "timeOnline")]
        pub time_online: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait NodeStats_Trait {
        fn set_cores(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cores(&self) -> std::result::Result<f64, JsValue>;
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn name(&self) -> std::result::Result<String, JsValue>;
        fn set_time_online(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn time_online(&self) -> std::result::Result<f64, JsValue>;
        fn set_hash_capacity(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn hash_capacity(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_level(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn level(&self) -> std::result::Result<f64, JsValue>;
        fn set_cache(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn cache(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_production(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn production(&self) -> std::result::Result<f64, JsValue>;
        fn set_ram(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn ram(&self) -> std::result::Result<f64, JsValue>;
        fn set_total_production(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn total_production(&self) -> std::result::Result<f64, JsValue>;
        fn set_ram_used(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn ram_used(&self) -> std::result::Result<Option<f64>, JsValue>;
    }
    impl NodeStats_Trait for NodeStats {
        fn set_cores(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cores = value;
            Ok(())
        }
        fn cores(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cores)
        }
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.name = value;
            Ok(())
        }
        fn name(&self) -> std::result::Result<String, JsValue> {
            Ok(self.name.clone())
        }
        fn set_time_online(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.time_online = value;
            Ok(())
        }
        fn time_online(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.time_online)
        }
        fn set_hash_capacity(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.hash_capacity = value;
            Ok(())
        }
        fn hash_capacity(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.hash_capacity.clone())
        }
        fn set_level(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.level = value;
            Ok(())
        }
        fn level(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.level)
        }
        fn set_cache(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.cache = value;
            Ok(())
        }
        fn cache(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.cache.clone())
        }
        fn set_production(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.production = value;
            Ok(())
        }
        fn production(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.production)
        }
        fn set_ram(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.ram = value;
            Ok(())
        }
        fn ram(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.ram)
        }
        fn set_total_production(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.total_production = value;
            Ok(())
        }
        fn total_production(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.total_production)
        }
        fn set_ram_used(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.ram_used = value;
            Ok(())
        }
        fn ram_used(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.ram_used.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct SleeveClassTaskAliased {
        #[serde(rename = "classType")]
        pub class_type: SleeveClassTaskAliasedClassType,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "location")]
        pub location: LocationName,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait SleeveClassTaskAliased_Trait {
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn type_(&self) -> std::result::Result<String, JsValue>;
        fn set_location(&mut self, value: LocationName) -> std::result::Result<(), JsValue>;
        fn location(&self) -> std::result::Result<LocationName, JsValue>;
        fn set_class_type(
            &mut self,
            value: SleeveClassTaskAliasedClassType,
        ) -> std::result::Result<(), JsValue>;
        fn class_type(&self) -> std::result::Result<SleeveClassTaskAliasedClassType, JsValue>;
    }
    impl SleeveClassTaskAliased_Trait for SleeveClassTaskAliased {
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.type_ = value;
            Ok(())
        }
        fn type_(&self) -> std::result::Result<String, JsValue> {
            Ok(self.type_.clone())
        }
        fn set_location(&mut self, value: LocationName) -> std::result::Result<(), JsValue> {
            self.location = value;
            Ok(())
        }
        fn location(&self) -> std::result::Result<LocationName, JsValue> {
            Ok(self.location.clone())
        }
        fn set_class_type(
            &mut self,
            value: SleeveClassTaskAliasedClassType,
        ) -> std::result::Result<(), JsValue> {
            self.class_type = value;
            Ok(())
        }
        fn class_type(&self) -> std::result::Result<SleeveClassTaskAliasedClassType, JsValue> {
            Ok(self.class_type.clone())
        }
    }
    #[allow(dead_code, non_camel_case_types)]
    type CorpResearchName = CorpResearchNameAliased;
    #[allow(dead_code, non_camel_case_types)]
    type SleeveCompanyTask = SleeveCompanyTaskAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum CorpStateNameAliased {
        String(String),
    }
    #[allow(dead_code, non_camel_case_types)]
    pub type SleeveTask = SleeveTaskAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct HacknetMultipliers {
        #[serde(rename = "coreCost")]
        pub core_cost: f64,
        #[serde(rename = "levelCost")]
        pub level_cost: f64,
        #[serde(rename = "ramCost")]
        pub ram_cost: f64,
        #[serde(rename = "purchaseCost")]
        pub purchase_cost: f64,
        #[serde(rename = "production")]
        pub production: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait HacknetMultipliers_Trait {
        fn set_core_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn core_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_production(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn production(&self) -> std::result::Result<f64, JsValue>;
        fn set_level_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn level_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_ram_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn ram_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_purchase_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn purchase_cost(&self) -> std::result::Result<f64, JsValue>;
    }
    impl HacknetMultipliers_Trait for HacknetMultipliers {
        fn set_core_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.core_cost = value;
            Ok(())
        }
        fn core_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.core_cost)
        }
        fn set_production(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.production = value;
            Ok(())
        }
        fn production(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.production)
        }
        fn set_level_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.level_cost = value;
            Ok(())
        }
        fn level_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.level_cost)
        }
        fn set_ram_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.ram_cost = value;
            Ok(())
        }
        fn ram_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.ram_cost)
        }
        fn set_purchase_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.purchase_cost = value;
            Ok(())
        }
        fn purchase_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.purchase_cost)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct HacknetServersFormulas {
        #[serde(
            rename = "hashGainRate",
            serialize_with = "HacknetServersFormulas::__TSB__serialize_hash_gain_rate",
            deserialize_with = "HacknetServersFormulas::__TSB__deserialize_hash_gain_rate"
        )]
        pub hash_gain_rate:
            std::rc::Rc<dyn Fn(f64, f64, f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "levelUpgradeCost",
            serialize_with = "HacknetServersFormulas::__TSB__serialize_level_upgrade_cost",
            deserialize_with = "HacknetServersFormulas::__TSB__deserialize_level_upgrade_cost"
        )]
        pub level_upgrade_cost:
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "coreUpgradeCost",
            serialize_with = "HacknetServersFormulas::__TSB__serialize_core_upgrade_cost",
            deserialize_with = "HacknetServersFormulas::__TSB__deserialize_core_upgrade_cost"
        )]
        pub core_upgrade_cost:
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "cacheUpgradeCost",
            serialize_with = "HacknetServersFormulas::__TSB__serialize_cache_upgrade_cost",
            deserialize_with = "HacknetServersFormulas::__TSB__deserialize_cache_upgrade_cost"
        )]
        pub cache_upgrade_cost: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "constants",
            serialize_with = "HacknetServersFormulas::__TSB__serialize_constants",
            deserialize_with = "HacknetServersFormulas::__TSB__deserialize_constants"
        )]
        pub constants:
            std::rc::Rc<dyn Fn() -> std::result::Result<HacknetServerConstants, JsValue>>,
        #[serde(
            rename = "ramUpgradeCost",
            serialize_with = "HacknetServersFormulas::__TSB__serialize_ram_upgrade_cost",
            deserialize_with = "HacknetServersFormulas::__TSB__deserialize_ram_upgrade_cost"
        )]
        pub ram_upgrade_cost:
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "hashUpgradeCost",
            serialize_with = "HacknetServersFormulas::__TSB__serialize_hash_upgrade_cost",
            deserialize_with = "HacknetServersFormulas::__TSB__deserialize_hash_upgrade_cost"
        )]
        pub hash_upgrade_cost: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "hacknetServerCost",
            serialize_with = "HacknetServersFormulas::__TSB__serialize_hacknet_server_cost",
            deserialize_with = "HacknetServersFormulas::__TSB__deserialize_hacknet_server_cost"
        )]
        pub hacknet_server_cost: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait HacknetServersFormulas_Trait {
        fn set_hacknet_server_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn hacknet_server_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_level_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn level_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_hash_gain_rate(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(f64, f64, f64, f64, f64) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn hash_gain_rate(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_core_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn core_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_cache_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn cache_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_constants(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<HacknetServerConstants, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn constants(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<HacknetServerConstants, JsValue>>,
            JsValue,
        >;
        fn set_ram_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn ram_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_hash_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn hash_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
    }
    impl HacknetServersFormulas_Trait for HacknetServersFormulas {
        fn set_hacknet_server_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.hacknet_server_cost = value;
            Ok(())
        }
        fn hacknet_server_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.hacknet_server_cost.clone())
        }
        fn set_level_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.level_upgrade_cost = value;
            Ok(())
        }
        fn level_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.level_upgrade_cost.clone())
        }
        fn set_hash_gain_rate(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(f64, f64, f64, f64, f64) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.hash_gain_rate = value;
            Ok(())
        }
        fn hash_gain_rate(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.hash_gain_rate.clone())
        }
        fn set_core_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.core_upgrade_cost = value;
            Ok(())
        }
        fn core_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.core_upgrade_cost.clone())
        }
        fn set_cache_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.cache_upgrade_cost = value;
            Ok(())
        }
        fn cache_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.cache_upgrade_cost.clone())
        }
        fn set_constants(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<HacknetServerConstants, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.constants = value;
            Ok(())
        }
        fn constants(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<HacknetServerConstants, JsValue>>,
            JsValue,
        > {
            Ok(self.constants.clone())
        }
        fn set_ram_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.ram_upgrade_cost = value;
            Ok(())
        }
        fn ram_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.ram_upgrade_cost.clone())
        }
        fn set_hash_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.hash_upgrade_cost = value;
            Ok(())
        }
        fn hash_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.hash_upgrade_cost.clone())
        }
    }
    impl HacknetServersFormulas {
        #[allow(non_snake_case)]
        fn __TSB__serialize_hash_gain_rate<S>(
            hash_gain_rate: &std::rc::Rc<
                dyn Fn(f64, f64, f64, f64, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hash_gain_rate = hash_gain_rate.clone();
            let hash_gain_rate_closure = Closure::wrap(Box::new(
                move |arg0: f64,
                      arg1: f64,
                      arg2: f64,
                      arg3: f64,
                      arg4: f64|
                      -> std::result::Result<f64, JsValue> {
                    let result = hash_gain_rate(arg0, arg1, arg2, arg3, arg4)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64, f64, f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &hash_gain_rate_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_level_upgrade_cost<S>(
            level_upgrade_cost: &std::rc::Rc<
                dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let level_upgrade_cost = level_upgrade_cost.clone();
            let level_upgrade_cost_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64, arg2: f64| -> std::result::Result<f64, JsValue> {
                    let result = level_upgrade_cost(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &level_upgrade_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_core_upgrade_cost<S>(
            core_upgrade_cost: &std::rc::Rc<
                dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let core_upgrade_cost = core_upgrade_cost.clone();
            let core_upgrade_cost_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64, arg2: f64| -> std::result::Result<f64, JsValue> {
                    let result = core_upgrade_cost(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &core_upgrade_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_cache_upgrade_cost<S>(
            cache_upgrade_cost: &std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let cache_upgrade_cost = cache_upgrade_cost.clone();
            let cache_upgrade_cost_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = cache_upgrade_cost(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &cache_upgrade_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_constants<S>(
            constants: &std::rc::Rc<
                dyn Fn() -> std::result::Result<HacknetServerConstants, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let constants = constants.clone();
            let constants_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = constants()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &constants_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_ram_upgrade_cost<S>(
            ram_upgrade_cost: &std::rc::Rc<
                dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let ram_upgrade_cost = ram_upgrade_cost.clone();
            let ram_upgrade_cost_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64, arg2: f64| -> std::result::Result<f64, JsValue> {
                    let result = ram_upgrade_cost(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &ram_upgrade_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_hash_upgrade_cost<S>(
            hash_upgrade_cost: &std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hash_upgrade_cost = hash_upgrade_cost.clone();
            let hash_upgrade_cost_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = hash_upgrade_cost(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &hash_upgrade_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_hacknet_server_cost<S>(
            hacknet_server_cost: &std::rc::Rc<
                dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hacknet_server_cost = hacknet_server_cost.clone();
            let hacknet_server_cost_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = hacknet_server_cost(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &hacknet_server_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hash_gain_rate<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hash_gain_rate: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            hash_gain_rate
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: f64, arg1: f64, arg2: f64, arg3: f64, arg4: f64| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = JsValue::from(arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let arg4 = JsValue::from(arg4);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            _Args.push(&arg4);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(f64, f64, f64, f64, f64) -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_level_upgrade_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let level_upgrade_cost: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            level_upgrade_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_core_upgrade_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let core_upgrade_cost: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            core_upgrade_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_cache_upgrade_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let cache_upgrade_cost: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            cache_upgrade_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_constants<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<HacknetServerConstants, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let constants: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            constants
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn() -> std::result::Result<HacknetServerConstants, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_ram_upgrade_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let ram_upgrade_cost: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            ram_upgrade_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hash_upgrade_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hash_upgrade_cost: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            hash_upgrade_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hacknet_server_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hacknet_server_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            hacknet_server_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[allow(dead_code, non_camel_case_types)]
    type ScriptArg = ScriptArgAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct IndustryData {
        #[serde(rename = "type")]
        pub type_: CorpIndustryName,
        #[serde(rename = "cost")]
        pub cost: f64,
        #[serde(rename = "makesMaterials")]
        pub makes_materials: bool,
        #[serde(rename = "productType")]
        pub product_type: Option<String>,
        #[serde(rename = "producedMaterials")]
        pub produced_materials: Option<Vec<String>>,
        #[serde(rename = "makesProducts")]
        pub makes_products: bool,
        #[serde(rename = "requiredMaterials")]
        pub required_materials: std::collections::HashMap<String, f64>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait IndustryData_Trait {
        fn set_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_required_materials(
            &mut self,
            value: std::collections::HashMap<String, f64>,
        ) -> std::result::Result<(), JsValue>;
        fn required_materials(
            &self,
        ) -> std::result::Result<std::collections::HashMap<String, f64>, JsValue>;
        fn set_makes_products(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn makes_products(&self) -> std::result::Result<bool, JsValue>;
        fn set_type_(&mut self, value: CorpIndustryName) -> std::result::Result<(), JsValue>;
        fn type_(&self) -> std::result::Result<CorpIndustryName, JsValue>;
        fn set_makes_materials(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn makes_materials(&self) -> std::result::Result<bool, JsValue>;
        fn set_product_type(&mut self, value: Option<String>) -> std::result::Result<(), JsValue>;
        fn product_type(&self) -> std::result::Result<Option<String>, JsValue>;
        fn set_produced_materials(
            &mut self,
            value: Option<Vec<String>>,
        ) -> std::result::Result<(), JsValue>;
        fn produced_materials(&self) -> std::result::Result<Option<Vec<String>>, JsValue>;
    }
    impl IndustryData_Trait for IndustryData {
        fn set_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cost = value;
            Ok(())
        }
        fn cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cost)
        }
        fn set_required_materials(
            &mut self,
            value: std::collections::HashMap<String, f64>,
        ) -> std::result::Result<(), JsValue> {
            self.required_materials = value;
            Ok(())
        }
        fn required_materials(
            &self,
        ) -> std::result::Result<std::collections::HashMap<String, f64>, JsValue> {
            Ok(self.required_materials.clone())
        }
        fn set_makes_products(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.makes_products = value;
            Ok(())
        }
        fn makes_products(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.makes_products)
        }
        fn set_type_(&mut self, value: CorpIndustryName) -> std::result::Result<(), JsValue> {
            self.type_ = value;
            Ok(())
        }
        fn type_(&self) -> std::result::Result<CorpIndustryName, JsValue> {
            Ok(self.type_.clone())
        }
        fn set_makes_materials(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.makes_materials = value;
            Ok(())
        }
        fn makes_materials(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.makes_materials)
        }
        fn set_product_type(&mut self, value: Option<String>) -> std::result::Result<(), JsValue> {
            self.product_type = value;
            Ok(())
        }
        fn product_type(&self) -> std::result::Result<Option<String>, JsValue> {
            Ok(self.product_type.clone())
        }
        fn set_produced_materials(
            &mut self,
            value: Option<Vec<String>>,
        ) -> std::result::Result<(), JsValue> {
            self.produced_materials = value;
            Ok(())
        }
        fn produced_materials(&self) -> std::result::Result<Option<Vec<String>>, JsValue> {
            Ok(self.produced_materials.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Singularity {
        #[serde(
            rename = "getFactionRep",
            serialize_with = "Singularity::__TSB__serialize_get_faction_rep",
            deserialize_with = "Singularity::__TSB__deserialize_get_faction_rep"
        )]
        pub get_faction_rep: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getOwnedAugmentations",
            serialize_with = "Singularity::__TSB__serialize_get_owned_augmentations",
            deserialize_with = "Singularity::__TSB__deserialize_get_owned_augmentations"
        )]
        pub get_owned_augmentations:
            std::rc::Rc<dyn Fn(bool) -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "getAugmentationsFromFaction",
            serialize_with = "Singularity::__TSB__serialize_get_augmentations_from_faction",
            deserialize_with = "Singularity::__TSB__deserialize_get_augmentations_from_faction"
        )]
        pub get_augmentations_from_faction:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "getDarkwebProgramCost",
            serialize_with = "Singularity::__TSB__serialize_get_darkweb_program_cost",
            deserialize_with = "Singularity::__TSB__deserialize_get_darkweb_program_cost"
        )]
        pub get_darkweb_program_cost:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "exportGame",
            serialize_with = "Singularity::__TSB__serialize_export_game",
            deserialize_with = "Singularity::__TSB__deserialize_export_game"
        )]
        pub export_game: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "purchaseAugmentation",
            serialize_with = "Singularity::__TSB__serialize_purchase_augmentation",
            deserialize_with = "Singularity::__TSB__deserialize_purchase_augmentation"
        )]
        pub purchase_augmentation:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getCurrentWork",
            serialize_with = "Singularity::__TSB__serialize_get_current_work",
            deserialize_with = "Singularity::__TSB__deserialize_get_current_work"
        )]
        pub get_current_work:
            std::rc::Rc<dyn Fn() -> std::result::Result<SingularityGetCurrentWorkReturn, JsValue>>,
        #[serde(
            rename = "getCompanyRep",
            serialize_with = "Singularity::__TSB__serialize_get_company_rep",
            deserialize_with = "Singularity::__TSB__deserialize_get_company_rep"
        )]
        pub get_company_rep: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "purchaseProgram",
            serialize_with = "Singularity::__TSB__serialize_purchase_program",
            deserialize_with = "Singularity::__TSB__deserialize_purchase_program"
        )]
        pub purchase_program: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "quitJob",
            serialize_with = "Singularity::__TSB__serialize_quit_job",
            deserialize_with = "Singularity::__TSB__deserialize_quit_job"
        )]
        pub quit_job: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "gymWorkout",
            serialize_with = "Singularity::__TSB__serialize_gym_workout",
            deserialize_with = "Singularity::__TSB__deserialize_gym_workout"
        )]
        pub gym_workout:
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getFactionFavor",
            serialize_with = "Singularity::__TSB__serialize_get_faction_favor",
            deserialize_with = "Singularity::__TSB__deserialize_get_faction_favor"
        )]
        pub get_faction_favor: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getAugmentationPrereq",
            serialize_with = "Singularity::__TSB__serialize_get_augmentation_prereq",
            deserialize_with = "Singularity::__TSB__deserialize_get_augmentation_prereq"
        )]
        pub get_augmentation_prereq:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "getFactionFavorGain",
            serialize_with = "Singularity::__TSB__serialize_get_faction_favor_gain",
            deserialize_with = "Singularity::__TSB__deserialize_get_faction_favor_gain"
        )]
        pub get_faction_favor_gain:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "universityCourse",
            serialize_with = "Singularity::__TSB__serialize_university_course",
            deserialize_with = "Singularity::__TSB__deserialize_university_course"
        )]
        pub university_course:
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "manualHack",
            serialize_with = "Singularity::__TSB__serialize_manual_hack",
            deserialize_with = "Singularity::__TSB__deserialize_manual_hack"
        )]
        pub manual_hack: std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
        #[serde(
            rename = "exportGameBonus",
            serialize_with = "Singularity::__TSB__serialize_export_game_bonus",
            deserialize_with = "Singularity::__TSB__deserialize_export_game_bonus"
        )]
        pub export_game_bonus: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "setFocus",
            serialize_with = "Singularity::__TSB__serialize_set_focus",
            deserialize_with = "Singularity::__TSB__deserialize_set_focus"
        )]
        pub set_focus: std::rc::Rc<dyn Fn(bool) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getCompanyFavor",
            serialize_with = "Singularity::__TSB__serialize_get_company_favor",
            deserialize_with = "Singularity::__TSB__deserialize_get_company_favor"
        )]
        pub get_company_favor: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "installBackdoor",
            serialize_with = "Singularity::__TSB__serialize_install_backdoor",
            deserialize_with = "Singularity::__TSB__deserialize_install_backdoor"
        )]
        pub install_backdoor:
            std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
        #[serde(
            rename = "getCrimeStats",
            serialize_with = "Singularity::__TSB__serialize_get_crime_stats",
            deserialize_with = "Singularity::__TSB__deserialize_get_crime_stats"
        )]
        pub get_crime_stats:
            std::rc::Rc<dyn Fn(CrimeType) -> std::result::Result<CrimeStats, JsValue>>,
        #[serde(
            rename = "getDarkwebPrograms",
            serialize_with = "Singularity::__TSB__serialize_get_darkweb_programs",
            deserialize_with = "Singularity::__TSB__deserialize_get_darkweb_programs"
        )]
        pub get_darkweb_programs:
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "stopAction",
            serialize_with = "Singularity::__TSB__serialize_stop_action",
            deserialize_with = "Singularity::__TSB__deserialize_stop_action"
        )]
        pub stop_action: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "connect",
            serialize_with = "Singularity::__TSB__serialize_connect",
            deserialize_with = "Singularity::__TSB__deserialize_connect"
        )]
        pub connect: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getAugmentationStats",
            serialize_with = "Singularity::__TSB__serialize_get_augmentation_stats",
            deserialize_with = "Singularity::__TSB__deserialize_get_augmentation_stats"
        )]
        pub get_augmentation_stats:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Multipliers, JsValue>>,
        #[serde(
            rename = "checkFactionInvitations",
            serialize_with = "Singularity::__TSB__serialize_check_faction_invitations",
            deserialize_with = "Singularity::__TSB__deserialize_check_faction_invitations"
        )]
        pub check_faction_invitations:
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "getAugmentationRepReq",
            serialize_with = "Singularity::__TSB__serialize_get_augmentation_rep_req",
            deserialize_with = "Singularity::__TSB__deserialize_get_augmentation_rep_req"
        )]
        pub get_augmentation_rep_req:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "commitCrime",
            serialize_with = "Singularity::__TSB__serialize_commit_crime",
            deserialize_with = "Singularity::__TSB__deserialize_commit_crime"
        )]
        pub commit_crime: std::rc::Rc<dyn Fn(CrimeType, bool) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "isBusy",
            serialize_with = "Singularity::__TSB__serialize_is_busy",
            deserialize_with = "Singularity::__TSB__deserialize_is_busy"
        )]
        pub is_busy: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "upgradeHomeCores",
            serialize_with = "Singularity::__TSB__serialize_upgrade_home_cores",
            deserialize_with = "Singularity::__TSB__deserialize_upgrade_home_cores"
        )]
        pub upgrade_home_cores: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getAugmentationPrice",
            serialize_with = "Singularity::__TSB__serialize_get_augmentation_price",
            deserialize_with = "Singularity::__TSB__deserialize_get_augmentation_price"
        )]
        pub get_augmentation_price:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getCurrentServer",
            serialize_with = "Singularity::__TSB__serialize_get_current_server",
            deserialize_with = "Singularity::__TSB__deserialize_get_current_server"
        )]
        pub get_current_server: std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
        #[serde(
            rename = "upgradeHomeRam",
            serialize_with = "Singularity::__TSB__serialize_upgrade_home_ram",
            deserialize_with = "Singularity::__TSB__deserialize_upgrade_home_ram"
        )]
        pub upgrade_home_ram: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "installAugmentations",
            serialize_with = "Singularity::__TSB__serialize_install_augmentations",
            deserialize_with = "Singularity::__TSB__deserialize_install_augmentations"
        )]
        pub install_augmentations: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "goToLocation",
            serialize_with = "Singularity::__TSB__serialize_go_to_location",
            deserialize_with = "Singularity::__TSB__deserialize_go_to_location"
        )]
        pub go_to_location: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "softReset",
            serialize_with = "Singularity::__TSB__serialize_soft_reset",
            deserialize_with = "Singularity::__TSB__deserialize_soft_reset"
        )]
        pub soft_reset: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "getCompanyFavorGain",
            serialize_with = "Singularity::__TSB__serialize_get_company_favor_gain",
            deserialize_with = "Singularity::__TSB__deserialize_get_company_favor_gain"
        )]
        pub get_company_favor_gain:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "applyToCompany",
            serialize_with = "Singularity::__TSB__serialize_apply_to_company",
            deserialize_with = "Singularity::__TSB__deserialize_apply_to_company"
        )]
        pub apply_to_company:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getCompanyPositions",
            serialize_with = "Singularity::__TSB__serialize_get_company_positions",
            deserialize_with = "Singularity::__TSB__deserialize_get_company_positions"
        )]
        pub get_company_positions:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<JobName>, JsValue>>,
        #[serde(
            rename = "getUpgradeHomeCoresCost",
            serialize_with = "Singularity::__TSB__serialize_get_upgrade_home_cores_cost",
            deserialize_with = "Singularity::__TSB__deserialize_get_upgrade_home_cores_cost"
        )]
        pub get_upgrade_home_cores_cost: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getUpgradeHomeRamCost",
            serialize_with = "Singularity::__TSB__serialize_get_upgrade_home_ram_cost",
            deserialize_with = "Singularity::__TSB__deserialize_get_upgrade_home_ram_cost"
        )]
        pub get_upgrade_home_ram_cost: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getCompanyPositionInfo",
            serialize_with = "Singularity::__TSB__serialize_get_company_position_info",
            deserialize_with = "Singularity::__TSB__deserialize_get_company_position_info"
        )]
        pub get_company_position_info: std::rc::Rc<
            dyn Fn(String, JobName) -> std::result::Result<CompanyPositionInfo, JsValue>,
        >,
        #[serde(
            rename = "travelToCity",
            serialize_with = "Singularity::__TSB__serialize_travel_to_city",
            deserialize_with = "Singularity::__TSB__deserialize_travel_to_city"
        )]
        pub travel_to_city: std::rc::Rc<dyn Fn(CityName) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "hospitalize",
            serialize_with = "Singularity::__TSB__serialize_hospitalize",
            deserialize_with = "Singularity::__TSB__deserialize_hospitalize"
        )]
        pub hospitalize: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "workForFaction",
            serialize_with = "Singularity::__TSB__serialize_work_for_faction",
            deserialize_with = "Singularity::__TSB__deserialize_work_for_faction"
        )]
        pub work_for_faction: std::rc::Rc<
            dyn Fn(String, FactionWorkType, bool) -> std::result::Result<bool, JsValue>,
        >,
        #[serde(
            rename = "getCrimeChance",
            serialize_with = "Singularity::__TSB__serialize_get_crime_chance",
            deserialize_with = "Singularity::__TSB__deserialize_get_crime_chance"
        )]
        pub get_crime_chance: std::rc::Rc<dyn Fn(CrimeType) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "purchaseTor",
            serialize_with = "Singularity::__TSB__serialize_purchase_tor",
            deserialize_with = "Singularity::__TSB__deserialize_purchase_tor"
        )]
        pub purchase_tor: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "destroyW0r1dD43m0n",
            serialize_with = "Singularity::__TSB__serialize_destroy_w0r1d_d43m0n",
            deserialize_with = "Singularity::__TSB__deserialize_destroy_w0r1d_d43m0n"
        )]
        pub destroy_w0r1d_d43m0n:
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "createProgram",
            serialize_with = "Singularity::__TSB__serialize_create_program",
            deserialize_with = "Singularity::__TSB__deserialize_create_program"
        )]
        pub create_program: std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "isFocused",
            serialize_with = "Singularity::__TSB__serialize_is_focused",
            deserialize_with = "Singularity::__TSB__deserialize_is_focused"
        )]
        pub is_focused: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "workForCompany",
            serialize_with = "Singularity::__TSB__serialize_work_for_company",
            deserialize_with = "Singularity::__TSB__deserialize_work_for_company"
        )]
        pub work_for_company:
            std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "b1tflum3",
            serialize_with = "Singularity::__TSB__serialize_b1tflum3",
            deserialize_with = "Singularity::__TSB__deserialize_b1tflum3"
        )]
        pub b1tflum3: std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "joinFaction",
            serialize_with = "Singularity::__TSB__serialize_join_faction",
            deserialize_with = "Singularity::__TSB__deserialize_join_faction"
        )]
        pub join_faction: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getAugmentationBasePrice",
            serialize_with = "Singularity::__TSB__serialize_get_augmentation_base_price",
            deserialize_with = "Singularity::__TSB__deserialize_get_augmentation_base_price"
        )]
        pub get_augmentation_base_price:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getOwnedSourceFiles",
            serialize_with = "Singularity::__TSB__serialize_get_owned_source_files",
            deserialize_with = "Singularity::__TSB__deserialize_get_owned_source_files"
        )]
        pub get_owned_source_files:
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<SourceFileLvl>, JsValue>>,
        #[serde(
            rename = "donateToFaction",
            serialize_with = "Singularity::__TSB__serialize_donate_to_faction",
            deserialize_with = "Singularity::__TSB__deserialize_donate_to_faction"
        )]
        pub donate_to_faction:
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait Singularity_Trait {
        fn set_quit_job(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn quit_job(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_get_company_favor(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_company_favor(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_is_focused(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn is_focused(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_purchase_augmentation(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn purchase_augmentation(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_work_for_faction(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, FactionWorkType, bool) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn work_for_faction(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, FactionWorkType, bool) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        >;
        fn set_stop_action(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn stop_action(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_purchase_program(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn purchase_program(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_crime_chance(
            &mut self,
            value: std::rc::Rc<dyn Fn(CrimeType) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_crime_chance(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CrimeType) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_gym_workout(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn gym_workout(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_company_rep(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_company_rep(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_upgrade_home_ram(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn upgrade_home_ram(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_apply_to_company(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn apply_to_company(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_darkweb_programs(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_darkweb_programs(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_export_game_bonus(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn export_game_bonus(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_get_upgrade_home_cores_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_upgrade_home_cores_cost(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_connect(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn connect(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_company_positions(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<JobName>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_company_positions(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<JobName>, JsValue>>,
            JsValue,
        >;
        fn set_work_for_company(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn work_for_company(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_augmentation_price(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_augmentation_price(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_b1tflum3(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn b1tflum3(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_get_upgrade_home_ram_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_upgrade_home_ram_cost(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_commit_crime(
            &mut self,
            value: std::rc::Rc<dyn Fn(CrimeType, bool) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn commit_crime(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CrimeType, bool) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_soft_reset(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn soft_reset(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_get_augmentations_from_faction(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_augmentations_from_faction(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_join_faction(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn join_faction(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_company_position_info(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, JobName) -> std::result::Result<CompanyPositionInfo, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_company_position_info(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, JobName) -> std::result::Result<CompanyPositionInfo, JsValue>,
            >,
            JsValue,
        >;
        fn set_install_augmentations(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn install_augmentations(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_get_augmentation_stats(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<Multipliers, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_augmentation_stats(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Multipliers, JsValue>>,
            JsValue,
        >;
        fn set_travel_to_city(
            &mut self,
            value: std::rc::Rc<dyn Fn(CityName) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn travel_to_city(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CityName) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_augmentation_base_price(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_augmentation_base_price(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_purchase_tor(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn purchase_tor(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_create_program(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn create_program(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_darkweb_program_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_darkweb_program_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_destroy_w0r1d_d43m0n(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn destroy_w0r1d_d43m0n(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_hospitalize(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn hospitalize(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, JsValue>;
        fn set_check_faction_invitations(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn check_faction_invitations(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_go_to_location(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn go_to_location(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_install_backdoor(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn install_backdoor(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
            JsValue,
        >;
        fn set_university_course(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn university_course(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_owned_source_files(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<SourceFileLvl>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_owned_source_files(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<SourceFileLvl>, JsValue>>,
            JsValue,
        >;
        fn set_get_owned_augmentations(
            &mut self,
            value: std::rc::Rc<dyn Fn(bool) -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_owned_augmentations(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(bool) -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_donate_to_faction(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn donate_to_faction(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_faction_favor(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_faction_favor(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_augmentation_rep_req(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_augmentation_rep_req(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_is_busy(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn is_busy(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_set_focus(
            &mut self,
            value: std::rc::Rc<dyn Fn(bool) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_focus(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(bool) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_export_game(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn export_game(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, JsValue>;
        fn set_upgrade_home_cores(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn upgrade_home_cores(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_get_company_favor_gain(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_company_favor_gain(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_current_work(
            &mut self,
            value: std::rc::Rc<
                dyn Fn() -> std::result::Result<SingularityGetCurrentWorkReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_current_work(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<SingularityGetCurrentWorkReturn, JsValue>>,
            JsValue,
        >;
        fn set_get_augmentation_prereq(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_augmentation_prereq(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_get_faction_rep(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_faction_rep(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_faction_favor_gain(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_faction_favor_gain(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_current_server(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_current_server(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
            JsValue,
        >;
        fn set_manual_hack(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn manual_hack(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
            JsValue,
        >;
        fn set_get_crime_stats(
            &mut self,
            value: std::rc::Rc<dyn Fn(CrimeType) -> std::result::Result<CrimeStats, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_crime_stats(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CrimeType) -> std::result::Result<CrimeStats, JsValue>>,
            JsValue,
        >;
    }
    impl Singularity_Trait for Singularity {
        fn set_quit_job(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.quit_job = value;
            Ok(())
        }
        fn quit_job(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.quit_job.clone())
        }
        fn set_get_company_favor(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_company_favor = value;
            Ok(())
        }
        fn get_company_favor(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_company_favor.clone())
        }
        fn set_is_focused(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.is_focused = value;
            Ok(())
        }
        fn is_focused(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.is_focused.clone())
        }
        fn set_purchase_augmentation(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.purchase_augmentation = value;
            Ok(())
        }
        fn purchase_augmentation(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.purchase_augmentation.clone())
        }
        fn set_work_for_faction(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, FactionWorkType, bool) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.work_for_faction = value;
            Ok(())
        }
        fn work_for_faction(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, FactionWorkType, bool) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.work_for_faction.clone())
        }
        fn set_stop_action(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.stop_action = value;
            Ok(())
        }
        fn stop_action(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.stop_action.clone())
        }
        fn set_purchase_program(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.purchase_program = value;
            Ok(())
        }
        fn purchase_program(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.purchase_program.clone())
        }
        fn set_get_crime_chance(
            &mut self,
            value: std::rc::Rc<dyn Fn(CrimeType) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_crime_chance = value;
            Ok(())
        }
        fn get_crime_chance(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CrimeType) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_crime_chance.clone())
        }
        fn set_gym_workout(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.gym_workout = value;
            Ok(())
        }
        fn gym_workout(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.gym_workout.clone())
        }
        fn set_get_company_rep(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_company_rep = value;
            Ok(())
        }
        fn get_company_rep(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_company_rep.clone())
        }
        fn set_upgrade_home_ram(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.upgrade_home_ram = value;
            Ok(())
        }
        fn upgrade_home_ram(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.upgrade_home_ram.clone())
        }
        fn set_apply_to_company(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.apply_to_company = value;
            Ok(())
        }
        fn apply_to_company(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.apply_to_company.clone())
        }
        fn set_get_darkweb_programs(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_darkweb_programs = value;
            Ok(())
        }
        fn get_darkweb_programs(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_darkweb_programs.clone())
        }
        fn set_export_game_bonus(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.export_game_bonus = value;
            Ok(())
        }
        fn export_game_bonus(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.export_game_bonus.clone())
        }
        fn set_get_upgrade_home_cores_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_upgrade_home_cores_cost = value;
            Ok(())
        }
        fn get_upgrade_home_cores_cost(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_upgrade_home_cores_cost.clone())
        }
        fn set_connect(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.connect = value;
            Ok(())
        }
        fn connect(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.connect.clone())
        }
        fn set_get_company_positions(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<JobName>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_company_positions = value;
            Ok(())
        }
        fn get_company_positions(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<JobName>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_company_positions.clone())
        }
        fn set_work_for_company(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.work_for_company = value;
            Ok(())
        }
        fn work_for_company(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.work_for_company.clone())
        }
        fn set_get_augmentation_price(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_augmentation_price = value;
            Ok(())
        }
        fn get_augmentation_price(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_augmentation_price.clone())
        }
        fn set_b1tflum3(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.b1tflum3 = value;
            Ok(())
        }
        fn b1tflum3(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.b1tflum3.clone())
        }
        fn set_get_upgrade_home_ram_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_upgrade_home_ram_cost = value;
            Ok(())
        }
        fn get_upgrade_home_ram_cost(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_upgrade_home_ram_cost.clone())
        }
        fn set_commit_crime(
            &mut self,
            value: std::rc::Rc<dyn Fn(CrimeType, bool) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.commit_crime = value;
            Ok(())
        }
        fn commit_crime(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CrimeType, bool) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.commit_crime.clone())
        }
        fn set_soft_reset(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.soft_reset = value;
            Ok(())
        }
        fn soft_reset(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.soft_reset.clone())
        }
        fn set_get_augmentations_from_faction(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_augmentations_from_faction = value;
            Ok(())
        }
        fn get_augmentations_from_faction(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_augmentations_from_faction.clone())
        }
        fn set_join_faction(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.join_faction = value;
            Ok(())
        }
        fn join_faction(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.join_faction.clone())
        }
        fn set_get_company_position_info(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, JobName) -> std::result::Result<CompanyPositionInfo, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_company_position_info = value;
            Ok(())
        }
        fn get_company_position_info(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, JobName) -> std::result::Result<CompanyPositionInfo, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.get_company_position_info.clone())
        }
        fn set_install_augmentations(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.install_augmentations = value;
            Ok(())
        }
        fn install_augmentations(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.install_augmentations.clone())
        }
        fn set_get_augmentation_stats(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<Multipliers, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_augmentation_stats = value;
            Ok(())
        }
        fn get_augmentation_stats(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Multipliers, JsValue>>,
            JsValue,
        > {
            Ok(self.get_augmentation_stats.clone())
        }
        fn set_travel_to_city(
            &mut self,
            value: std::rc::Rc<dyn Fn(CityName) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.travel_to_city = value;
            Ok(())
        }
        fn travel_to_city(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CityName) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.travel_to_city.clone())
        }
        fn set_get_augmentation_base_price(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_augmentation_base_price = value;
            Ok(())
        }
        fn get_augmentation_base_price(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_augmentation_base_price.clone())
        }
        fn set_purchase_tor(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.purchase_tor = value;
            Ok(())
        }
        fn purchase_tor(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.purchase_tor.clone())
        }
        fn set_create_program(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.create_program = value;
            Ok(())
        }
        fn create_program(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.create_program.clone())
        }
        fn set_get_darkweb_program_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_darkweb_program_cost = value;
            Ok(())
        }
        fn get_darkweb_program_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_darkweb_program_cost.clone())
        }
        fn set_destroy_w0r1d_d43m0n(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.destroy_w0r1d_d43m0n = value;
            Ok(())
        }
        fn destroy_w0r1d_d43m0n(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.destroy_w0r1d_d43m0n.clone())
        }
        fn set_hospitalize(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.hospitalize = value;
            Ok(())
        }
        fn hospitalize(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, JsValue>
        {
            Ok(self.hospitalize.clone())
        }
        fn set_check_faction_invitations(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.check_faction_invitations = value;
            Ok(())
        }
        fn check_faction_invitations(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.check_faction_invitations.clone())
        }
        fn set_go_to_location(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.go_to_location = value;
            Ok(())
        }
        fn go_to_location(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.go_to_location.clone())
        }
        fn set_install_backdoor(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.install_backdoor = value;
            Ok(())
        }
        fn install_backdoor(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
            JsValue,
        > {
            Ok(self.install_backdoor.clone())
        }
        fn set_university_course(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.university_course = value;
            Ok(())
        }
        fn university_course(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.university_course.clone())
        }
        fn set_get_owned_source_files(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<SourceFileLvl>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_owned_source_files = value;
            Ok(())
        }
        fn get_owned_source_files(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<SourceFileLvl>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_owned_source_files.clone())
        }
        fn set_get_owned_augmentations(
            &mut self,
            value: std::rc::Rc<dyn Fn(bool) -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_owned_augmentations = value;
            Ok(())
        }
        fn get_owned_augmentations(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(bool) -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_owned_augmentations.clone())
        }
        fn set_donate_to_faction(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.donate_to_faction = value;
            Ok(())
        }
        fn donate_to_faction(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.donate_to_faction.clone())
        }
        fn set_get_faction_favor(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_faction_favor = value;
            Ok(())
        }
        fn get_faction_favor(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_faction_favor.clone())
        }
        fn set_get_augmentation_rep_req(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_augmentation_rep_req = value;
            Ok(())
        }
        fn get_augmentation_rep_req(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_augmentation_rep_req.clone())
        }
        fn set_is_busy(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.is_busy = value;
            Ok(())
        }
        fn is_busy(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.is_busy.clone())
        }
        fn set_set_focus(
            &mut self,
            value: std::rc::Rc<dyn Fn(bool) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_focus = value;
            Ok(())
        }
        fn set_focus(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(bool) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.set_focus.clone())
        }
        fn set_export_game(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.export_game = value;
            Ok(())
        }
        fn export_game(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, JsValue>
        {
            Ok(self.export_game.clone())
        }
        fn set_upgrade_home_cores(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.upgrade_home_cores = value;
            Ok(())
        }
        fn upgrade_home_cores(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.upgrade_home_cores.clone())
        }
        fn set_get_company_favor_gain(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_company_favor_gain = value;
            Ok(())
        }
        fn get_company_favor_gain(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_company_favor_gain.clone())
        }
        fn set_get_current_work(
            &mut self,
            value: std::rc::Rc<
                dyn Fn() -> std::result::Result<SingularityGetCurrentWorkReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_current_work = value;
            Ok(())
        }
        fn get_current_work(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<SingularityGetCurrentWorkReturn, JsValue>>,
            JsValue,
        > {
            Ok(self.get_current_work.clone())
        }
        fn set_get_augmentation_prereq(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_augmentation_prereq = value;
            Ok(())
        }
        fn get_augmentation_prereq(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_augmentation_prereq.clone())
        }
        fn set_get_faction_rep(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_faction_rep = value;
            Ok(())
        }
        fn get_faction_rep(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_faction_rep.clone())
        }
        fn set_get_faction_favor_gain(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_faction_favor_gain = value;
            Ok(())
        }
        fn get_faction_favor_gain(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_faction_favor_gain.clone())
        }
        fn set_get_current_server(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_current_server = value;
            Ok(())
        }
        fn get_current_server(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
            JsValue,
        > {
            Ok(self.get_current_server.clone())
        }
        fn set_manual_hack(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.manual_hack = value;
            Ok(())
        }
        fn manual_hack(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
            JsValue,
        > {
            Ok(self.manual_hack.clone())
        }
        fn set_get_crime_stats(
            &mut self,
            value: std::rc::Rc<dyn Fn(CrimeType) -> std::result::Result<CrimeStats, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_crime_stats = value;
            Ok(())
        }
        fn get_crime_stats(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CrimeType) -> std::result::Result<CrimeStats, JsValue>>,
            JsValue,
        > {
            Ok(self.get_crime_stats.clone())
        }
    }
    impl Singularity {
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_faction_rep<S>(
            get_faction_rep: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_faction_rep = get_faction_rep.clone();
            let get_faction_rep_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_faction_rep(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_faction_rep_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_owned_augmentations<S>(
            get_owned_augmentations: &std::rc::Rc<
                dyn Fn(bool) -> std::result::Result<Vec<String>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_owned_augmentations = get_owned_augmentations.clone();
            let get_owned_augmentations_closure = Closure::wrap(Box::new(
                move |arg0: bool| -> std::result::Result<JsValue, JsValue> {
                    let result = get_owned_augmentations(arg0)?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                },
            )
                as Box<dyn Fn(bool) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_owned_augmentations_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_augmentations_from_faction<S>(
            get_augmentations_from_faction: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_augmentations_from_faction = get_augmentations_from_faction.clone();
            let get_augmentations_from_faction_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<JsValue, JsValue> {
                    let result = get_augmentations_from_faction(arg0)?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_augmentations_from_faction_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_darkweb_program_cost<S>(
            get_darkweb_program_cost: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_darkweb_program_cost = get_darkweb_program_cost.clone();
            let get_darkweb_program_cost_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_darkweb_program_cost(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_darkweb_program_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_export_game<S>(
            export_game: &std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let export_game = export_game.clone();
            let export_game_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<(), JsValue> {
                    let result = export_game()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &export_game_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_purchase_augmentation<S>(
            purchase_augmentation: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let purchase_augmentation = purchase_augmentation.clone();
            let purchase_augmentation_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<bool, JsValue> {
                    let result = purchase_augmentation(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &purchase_augmentation_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_current_work<S>(
            get_current_work: &std::rc::Rc<
                dyn Fn() -> std::result::Result<SingularityGetCurrentWorkReturn, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_current_work = get_current_work.clone();
            let get_current_work_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_current_work()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_current_work_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_company_rep<S>(
            get_company_rep: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_company_rep = get_company_rep.clone();
            let get_company_rep_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_company_rep(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_company_rep_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_purchase_program<S>(
            purchase_program: &std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let purchase_program = purchase_program.clone();
            let purchase_program_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<bool, JsValue> {
                    let result = purchase_program(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &purchase_program_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_quit_job<S>(
            quit_job: &std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let quit_job = quit_job.clone();
            let quit_job_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<(), JsValue> {
                    let result = quit_job(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<(), JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &quit_job_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_gym_workout<S>(
            gym_workout: &std::rc::Rc<
                dyn Fn(String, String, bool) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let gym_workout = gym_workout.clone();
            let gym_workout_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: String,
                      arg2: bool|
                      -> std::result::Result<bool, JsValue> {
                    let result = gym_workout(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String, bool) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &gym_workout_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_faction_favor<S>(
            get_faction_favor: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_faction_favor = get_faction_favor.clone();
            let get_faction_favor_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_faction_favor(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_faction_favor_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_augmentation_prereq<S>(
            get_augmentation_prereq: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_augmentation_prereq = get_augmentation_prereq.clone();
            let get_augmentation_prereq_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<JsValue, JsValue> {
                    let result = get_augmentation_prereq(arg0)?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_augmentation_prereq_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_faction_favor_gain<S>(
            get_faction_favor_gain: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_faction_favor_gain = get_faction_favor_gain.clone();
            let get_faction_favor_gain_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_faction_favor_gain(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_faction_favor_gain_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_university_course<S>(
            university_course: &std::rc::Rc<
                dyn Fn(String, String, bool) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let university_course = university_course.clone();
            let university_course_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: String,
                      arg2: bool|
                      -> std::result::Result<bool, JsValue> {
                    let result = university_course(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String, bool) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &university_course_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_manual_hack<S>(
            manual_hack: &std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let manual_hack = manual_hack.clone();
            let manual_hack_closure = Closure::wrap(Box::new(
                move || -> std::result::Result<js_sys::Promise, JsValue> {
                    let result = manual_hack()?;
                    Ok(result)
                },
            )
                as Box<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &manual_hack_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_export_game_bonus<S>(
            export_game_bonus: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let export_game_bonus = export_game_bonus.clone();
            let export_game_bonus_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = export_game_bonus()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &export_game_bonus_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_focus<S>(
            set_focus: &std::rc::Rc<dyn Fn(bool) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_focus = set_focus.clone();
            let set_focus_closure = Closure::wrap(Box::new(
                move |arg0: bool| -> std::result::Result<bool, JsValue> {
                    let result = set_focus(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(bool) -> std::result::Result<bool, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &set_focus_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_company_favor<S>(
            get_company_favor: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_company_favor = get_company_favor.clone();
            let get_company_favor_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_company_favor(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_company_favor_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_install_backdoor<S>(
            install_backdoor: &std::rc::Rc<
                dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let install_backdoor = install_backdoor.clone();
            let install_backdoor_closure = Closure::wrap(Box::new(
                move || -> std::result::Result<js_sys::Promise, JsValue> {
                    let result = install_backdoor()?;
                    Ok(result)
                },
            )
                as Box<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &install_backdoor_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_crime_stats<S>(
            get_crime_stats: &std::rc::Rc<
                dyn Fn(CrimeType) -> std::result::Result<CrimeStats, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_crime_stats = get_crime_stats.clone();
            let get_crime_stats_closure = Closure::wrap(Box::new(
                move |arg0: JsValue| -> std::result::Result<JsValue, JsValue> {
                    let result = get_crime_stats(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(JsValue) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_crime_stats_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_darkweb_programs<S>(
            get_darkweb_programs: &std::rc::Rc<
                dyn Fn() -> std::result::Result<Vec<String>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_darkweb_programs = get_darkweb_programs.clone();
            let get_darkweb_programs_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_darkweb_programs()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_darkweb_programs_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_stop_action<S>(
            stop_action: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let stop_action = stop_action.clone();
            let stop_action_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = stop_action()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &stop_action_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_connect<S>(
            connect: &std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let connect = connect.clone();
            let connect_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<bool, JsValue> {
                    let result = connect(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<bool, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &connect_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_augmentation_stats<S>(
            get_augmentation_stats: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<Multipliers, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_augmentation_stats = get_augmentation_stats.clone();
            let get_augmentation_stats_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<JsValue, JsValue> {
                    let result = get_augmentation_stats(arg0)?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_augmentation_stats_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_check_faction_invitations<S>(
            check_faction_invitations: &std::rc::Rc<
                dyn Fn() -> std::result::Result<Vec<String>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let check_faction_invitations = check_faction_invitations.clone();
            let check_faction_invitations_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = check_faction_invitations()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &check_faction_invitations_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_augmentation_rep_req<S>(
            get_augmentation_rep_req: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_augmentation_rep_req = get_augmentation_rep_req.clone();
            let get_augmentation_rep_req_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_augmentation_rep_req(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_augmentation_rep_req_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_commit_crime<S>(
            commit_crime: &std::rc::Rc<
                dyn Fn(CrimeType, bool) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let commit_crime = commit_crime.clone();
            let commit_crime_closure = Closure::wrap(Box::new(
                move |arg0: JsValue, arg1: bool| -> std::result::Result<f64, JsValue> {
                    let result = commit_crime(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        arg1,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue, bool) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &commit_crime_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_is_busy<S>(
            is_busy: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let is_busy = is_busy.clone();
            let is_busy_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = is_busy()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &is_busy_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_upgrade_home_cores<S>(
            upgrade_home_cores: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let upgrade_home_cores = upgrade_home_cores.clone();
            let upgrade_home_cores_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = upgrade_home_cores()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &upgrade_home_cores_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_augmentation_price<S>(
            get_augmentation_price: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_augmentation_price = get_augmentation_price.clone();
            let get_augmentation_price_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_augmentation_price(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_augmentation_price_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_current_server<S>(
            get_current_server: &std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_current_server = get_current_server.clone();
            let get_current_server_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<String, JsValue> {
                    let result = get_current_server()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<String, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_current_server_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_upgrade_home_ram<S>(
            upgrade_home_ram: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let upgrade_home_ram = upgrade_home_ram.clone();
            let upgrade_home_ram_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = upgrade_home_ram()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &upgrade_home_ram_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_install_augmentations<S>(
            install_augmentations: &std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let install_augmentations = install_augmentations.clone();
            let install_augmentations_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<(), JsValue> {
                    let result = install_augmentations(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &install_augmentations_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_go_to_location<S>(
            go_to_location: &std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let go_to_location = go_to_location.clone();
            let go_to_location_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<bool, JsValue> {
                    let result = go_to_location(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &go_to_location_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_soft_reset<S>(
            soft_reset: &std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let soft_reset = soft_reset.clone();
            let soft_reset_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<(), JsValue> {
                    let result = soft_reset(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &soft_reset_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_company_favor_gain<S>(
            get_company_favor_gain: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_company_favor_gain = get_company_favor_gain.clone();
            let get_company_favor_gain_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_company_favor_gain(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_company_favor_gain_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_apply_to_company<S>(
            apply_to_company: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let apply_to_company = apply_to_company.clone();
            let apply_to_company_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<bool, JsValue> {
                    let result = apply_to_company(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &apply_to_company_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_company_positions<S>(
            get_company_positions: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<Vec<JobName>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_company_positions = get_company_positions.clone();
            let get_company_positions_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<JsValue, JsValue> {
                    let result = get_company_positions(arg0)?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(
                                &ts_bindgen_rt::to_jsvalue(&result_item)
                                    .map_err(ts_bindgen_rt::Error::from)?,
                            );
                        }
                        result_array.into()
                    })
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_company_positions_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_upgrade_home_cores_cost<S>(
            get_upgrade_home_cores_cost: &std::rc::Rc<
                dyn Fn() -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_upgrade_home_cores_cost = get_upgrade_home_cores_cost.clone();
            let get_upgrade_home_cores_cost_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_upgrade_home_cores_cost()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_upgrade_home_cores_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_upgrade_home_ram_cost<S>(
            get_upgrade_home_ram_cost: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_upgrade_home_ram_cost = get_upgrade_home_ram_cost.clone();
            let get_upgrade_home_ram_cost_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_upgrade_home_ram_cost()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_upgrade_home_ram_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_company_position_info<S>(
            get_company_position_info: &std::rc::Rc<
                dyn Fn(String, JobName) -> std::result::Result<CompanyPositionInfo, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_company_position_info = get_company_position_info.clone();
            let get_company_position_info_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: JsValue| -> std::result::Result<JsValue, JsValue> {
                    let result = get_company_position_info(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(String, JsValue) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_company_position_info_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_travel_to_city<S>(
            travel_to_city: &std::rc::Rc<dyn Fn(CityName) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let travel_to_city = travel_to_city.clone();
            let travel_to_city_closure = Closure::wrap(Box::new(
                move |arg0: JsValue| -> std::result::Result<bool, JsValue> {
                    let result = travel_to_city(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &travel_to_city_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_hospitalize<S>(
            hospitalize: &std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hospitalize = hospitalize.clone();
            let hospitalize_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<(), JsValue> {
                    let result = hospitalize()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &hospitalize_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_work_for_faction<S>(
            work_for_faction: &std::rc::Rc<
                dyn Fn(String, FactionWorkType, bool) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let work_for_faction = work_for_faction.clone();
            let work_for_faction_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: bool|
                      -> std::result::Result<bool, JsValue> {
                    let result = work_for_faction(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, bool) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &work_for_faction_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_crime_chance<S>(
            get_crime_chance: &std::rc::Rc<dyn Fn(CrimeType) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_crime_chance = get_crime_chance.clone();
            let get_crime_chance_closure = Closure::wrap(Box::new(
                move |arg0: JsValue| -> std::result::Result<f64, JsValue> {
                    let result = get_crime_chance(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_crime_chance_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_purchase_tor<S>(
            purchase_tor: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let purchase_tor = purchase_tor.clone();
            let purchase_tor_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = purchase_tor()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &purchase_tor_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_destroy_w0r1d_d43m0n<S>(
            destroy_w0r1d_d43m0n: &std::rc::Rc<
                dyn Fn(f64, String) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let destroy_w0r1d_d43m0n = destroy_w0r1d_d43m0n.clone();
            let destroy_w0r1d_d43m0n_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: String| -> std::result::Result<(), JsValue> {
                    let result = destroy_w0r1d_d43m0n(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, String) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &destroy_w0r1d_d43m0n_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_create_program<S>(
            create_program: &std::rc::Rc<
                dyn Fn(String, bool) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let create_program = create_program.clone();
            let create_program_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: bool| -> std::result::Result<bool, JsValue> {
                    let result = create_program(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &create_program_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_is_focused<S>(
            is_focused: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let is_focused = is_focused.clone();
            let is_focused_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = is_focused()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &is_focused_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_work_for_company<S>(
            work_for_company: &std::rc::Rc<
                dyn Fn(String, bool) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let work_for_company = work_for_company.clone();
            let work_for_company_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: bool| -> std::result::Result<bool, JsValue> {
                    let result = work_for_company(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &work_for_company_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_b1tflum3<S>(
            b1tflum3: &std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let b1tflum3 = b1tflum3.clone();
            let b1tflum3_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: String| -> std::result::Result<(), JsValue> {
                    let result = b1tflum3(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, String) -> std::result::Result<(), JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &b1tflum3_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_join_faction<S>(
            join_faction: &std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let join_faction = join_faction.clone();
            let join_faction_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<bool, JsValue> {
                    let result = join_faction(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &join_faction_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_augmentation_base_price<S>(
            get_augmentation_base_price: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_augmentation_base_price = get_augmentation_base_price.clone();
            let get_augmentation_base_price_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_augmentation_base_price(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_augmentation_base_price_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_owned_source_files<S>(
            get_owned_source_files: &std::rc::Rc<
                dyn Fn() -> std::result::Result<Vec<SourceFileLvl>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_owned_source_files = get_owned_source_files.clone();
            let get_owned_source_files_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_owned_source_files()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(
                                &ts_bindgen_rt::to_jsvalue(&result_item)
                                    .map_err(ts_bindgen_rt::Error::from)?,
                            );
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_owned_source_files_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_donate_to_faction<S>(
            donate_to_faction: &std::rc::Rc<
                dyn Fn(String, f64) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let donate_to_faction = donate_to_faction.clone();
            let donate_to_faction_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: f64| -> std::result::Result<bool, JsValue> {
                    let result = donate_to_faction(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &donate_to_faction_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_faction_rep<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_faction_rep: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_faction_rep
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_owned_augmentations<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(bool) -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_owned_augmentations: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_owned_augmentations
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: bool| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn(bool) -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_augmentations_from_faction<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_augmentations_from_faction: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_augmentations_from_faction
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_darkweb_program_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_darkweb_program_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_darkweb_program_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_export_game<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let export_game: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            export_game
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_purchase_augmentation<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let purchase_augmentation: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            purchase_augmentation
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_current_work<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<SingularityGetCurrentWorkReturn, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_current_work: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_current_work
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn()
                                -> std::result::Result<SingularityGetCurrentWorkReturn, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_company_rep<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_company_rep: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_company_rep
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_purchase_program<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let purchase_program: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            purchase_program
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_quit_job<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let quit_job: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            quit_job
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_gym_workout<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let gym_workout: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            gym_workout
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String, arg2: bool| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, String, bool) -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_faction_favor<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_faction_favor: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_faction_favor
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_augmentation_prereq<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_augmentation_prereq: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_augmentation_prereq
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_faction_favor_gain<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_faction_favor_gain: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_faction_favor_gain
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_university_course<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let university_course: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            university_course
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String, arg2: bool| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, String, bool) -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_manual_hack<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let manual_hack: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            manual_hack
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_export_game_bonus<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let export_game_bonus: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            export_game_bonus
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_focus<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(bool) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_focus: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_focus
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: bool| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(bool) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_company_favor<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_company_favor: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_company_favor
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_install_backdoor<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let install_backdoor: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            install_backdoor
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_crime_stats<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CrimeType) -> std::result::Result<CrimeStats, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_crime_stats: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_crime_stats
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: CrimeType| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(CrimeType) -> std::result::Result<CrimeStats, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_darkweb_programs<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_darkweb_programs: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_darkweb_programs
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_stop_action<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let stop_action: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            stop_action
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_connect<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let connect: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            connect
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_augmentation_stats<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Multipliers, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_augmentation_stats: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_augmentation_stats
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<Multipliers, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_check_faction_invitations<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let check_faction_invitations: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            check_faction_invitations
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_augmentation_rep_req<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_augmentation_rep_req: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_augmentation_rep_req
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_commit_crime<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CrimeType, bool) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let commit_crime: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            commit_crime
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: CrimeType, arg1: bool| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(CrimeType, bool) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_is_busy<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let is_busy: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            is_busy
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_upgrade_home_cores<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let upgrade_home_cores: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            upgrade_home_cores
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_augmentation_price<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_augmentation_price: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_augmentation_price
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_current_server<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_current_server: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_current_server
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_upgrade_home_ram<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let upgrade_home_ram: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            upgrade_home_ram
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_install_augmentations<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let install_augmentations: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            install_augmentations
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_go_to_location<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let go_to_location: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            go_to_location
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_soft_reset<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let soft_reset: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            soft_reset
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_company_favor_gain<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_company_favor_gain: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_company_favor_gain
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_apply_to_company<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let apply_to_company: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            apply_to_company
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_company_positions<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<JobName>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_company_positions: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_company_positions
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<JobName>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_upgrade_home_cores_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_upgrade_home_cores_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_upgrade_home_cores_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_upgrade_home_ram_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_upgrade_home_ram_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_upgrade_home_ram_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_company_position_info<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, JobName) -> std::result::Result<CompanyPositionInfo, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_company_position_info: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_company_position_info
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: JobName| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                JobName,
                            )
                                -> std::result::Result<CompanyPositionInfo, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_travel_to_city<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CityName) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let travel_to_city: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            travel_to_city
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: CityName| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(CityName) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hospitalize<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hospitalize: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            hospitalize
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_work_for_faction<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, FactionWorkType, bool) -> std::result::Result<bool, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let work_for_faction: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            work_for_faction
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: FactionWorkType, arg2: bool| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                FactionWorkType,
                                bool,
                            )
                                -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_crime_chance<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(CrimeType) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_crime_chance: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_crime_chance
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: CrimeType| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(CrimeType) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_purchase_tor<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let purchase_tor: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            purchase_tor
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_destroy_w0r1d_d43m0n<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let destroy_w0r1d_d43m0n: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            destroy_w0r1d_d43m0n
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_create_program<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let create_program: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            create_program
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: bool| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_is_focused<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let is_focused: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            is_focused
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_work_for_company<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let work_for_company: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            work_for_company
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: bool| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_b1tflum3<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let b1tflum3: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            b1tflum3
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_join_faction<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let join_faction: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            join_faction
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_augmentation_base_price<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_augmentation_base_price: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_augmentation_base_price
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_owned_source_files<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<SourceFileLvl>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_owned_source_files: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_owned_source_files
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<SourceFileLvl>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_donate_to_faction<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let donate_to_faction: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            donate_to_faction
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct GangGenInfo {
        #[serde(rename = "wantedLevelGainRate")]
        pub wanted_level_gain_rate: f64,
        #[serde(rename = "isHacking")]
        pub is_hacking: bool,
        #[serde(rename = "territoryWarfareEngaged")]
        pub territory_warfare_engaged: bool,
        #[serde(rename = "power")]
        pub power: f64,
        #[serde(rename = "respectGainRate")]
        pub respect_gain_rate: f64,
        #[serde(rename = "territory")]
        pub territory: f64,
        #[serde(rename = "respect")]
        pub respect: f64,
        #[serde(rename = "wantedLevel")]
        pub wanted_level: f64,
        #[serde(rename = "moneyGainRate")]
        pub money_gain_rate: f64,
        #[serde(rename = "faction")]
        pub faction: String,
        #[serde(rename = "wantedPenalty")]
        pub wanted_penalty: f64,
        #[serde(rename = "territoryClashChance")]
        pub territory_clash_chance: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait GangGenInfo_Trait {
        fn set_territory(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn territory(&self) -> std::result::Result<f64, JsValue>;
        fn set_is_hacking(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn is_hacking(&self) -> std::result::Result<bool, JsValue>;
        fn set_power(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn power(&self) -> std::result::Result<f64, JsValue>;
        fn set_wanted_penalty(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn wanted_penalty(&self) -> std::result::Result<f64, JsValue>;
        fn set_wanted_level(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn wanted_level(&self) -> std::result::Result<f64, JsValue>;
        fn set_territory_clash_chance(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn territory_clash_chance(&self) -> std::result::Result<f64, JsValue>;
        fn set_respect(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn respect(&self) -> std::result::Result<f64, JsValue>;
        fn set_money_gain_rate(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn money_gain_rate(&self) -> std::result::Result<f64, JsValue>;
        fn set_faction(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn faction(&self) -> std::result::Result<String, JsValue>;
        fn set_territory_warfare_engaged(
            &mut self,
            value: bool,
        ) -> std::result::Result<(), JsValue>;
        fn territory_warfare_engaged(&self) -> std::result::Result<bool, JsValue>;
        fn set_wanted_level_gain_rate(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn wanted_level_gain_rate(&self) -> std::result::Result<f64, JsValue>;
        fn set_respect_gain_rate(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn respect_gain_rate(&self) -> std::result::Result<f64, JsValue>;
    }
    impl GangGenInfo_Trait for GangGenInfo {
        fn set_territory(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.territory = value;
            Ok(())
        }
        fn territory(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.territory)
        }
        fn set_is_hacking(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.is_hacking = value;
            Ok(())
        }
        fn is_hacking(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.is_hacking)
        }
        fn set_power(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.power = value;
            Ok(())
        }
        fn power(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.power)
        }
        fn set_wanted_penalty(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.wanted_penalty = value;
            Ok(())
        }
        fn wanted_penalty(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.wanted_penalty)
        }
        fn set_wanted_level(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.wanted_level = value;
            Ok(())
        }
        fn wanted_level(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.wanted_level)
        }
        fn set_territory_clash_chance(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.territory_clash_chance = value;
            Ok(())
        }
        fn territory_clash_chance(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.territory_clash_chance)
        }
        fn set_respect(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.respect = value;
            Ok(())
        }
        fn respect(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.respect)
        }
        fn set_money_gain_rate(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.money_gain_rate = value;
            Ok(())
        }
        fn money_gain_rate(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.money_gain_rate)
        }
        fn set_faction(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.faction = value;
            Ok(())
        }
        fn faction(&self) -> std::result::Result<String, JsValue> {
            Ok(self.faction.clone())
        }
        fn set_territory_warfare_engaged(
            &mut self,
            value: bool,
        ) -> std::result::Result<(), JsValue> {
            self.territory_warfare_engaged = value;
            Ok(())
        }
        fn territory_warfare_engaged(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.territory_warfare_engaged)
        }
        fn set_wanted_level_gain_rate(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.wanted_level_gain_rate = value;
            Ok(())
        }
        fn wanted_level_gain_rate(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.wanted_level_gain_rate)
        }
        fn set_respect_gain_rate(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.respect_gain_rate = value;
            Ok(())
        }
        fn respect_gain_rate(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.respect_gain_rate)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Export {
        #[serde(rename = "city")]
        pub city: CityName,
        #[serde(rename = "amount")]
        pub amount: String,
        #[serde(rename = "division")]
        pub division: String,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait Export_Trait {
        fn set_city(&mut self, value: CityName) -> std::result::Result<(), JsValue>;
        fn city(&self) -> std::result::Result<CityName, JsValue>;
        fn set_division(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn division(&self) -> std::result::Result<String, JsValue>;
        fn set_amount(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn amount(&self) -> std::result::Result<String, JsValue>;
    }
    impl Export_Trait for Export {
        fn set_city(&mut self, value: CityName) -> std::result::Result<(), JsValue> {
            self.city = value;
            Ok(())
        }
        fn city(&self) -> std::result::Result<CityName, JsValue> {
            Ok(self.city.clone())
        }
        fn set_division(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.division = value;
            Ok(())
        }
        fn division(&self) -> std::result::Result<String, JsValue> {
            Ok(self.division.clone())
        }
        fn set_amount(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.amount = value;
            Ok(())
        }
        fn amount(&self) -> std::result::Result<String, JsValue> {
            Ok(self.amount.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum CodingContractAttemptParamsAnswer {
        VecOfJsValue(Vec<JsValue>),
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum AutocompleteDataFlagsParamsSchemaTuple1 {
        VecOfString(Vec<String>),
        Bool(bool),
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsTryWritePortParamsData {
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum SleeveTaskAliased {
        SleeveBladeburnerTask(SleeveBladeburnerTask),
        SleeveCrimeTask(SleeveCrimeTask),
        SleeveInfiltrateTask(SleeveInfiltrateTask),
        SleeveFactionTask(SleeveFactionTask),
        SleeveClassTask(SleeveClassTask),
        SleeveCompanyTask(SleeveCompanyTask),
        SleeveSynchroTask(SleeveSynchroTask),
        SleeveSupportTask(SleeveSupportTask),
        SleeveRecoveryTask(SleeveRecoveryTask),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum RunningScriptTailProperties {
        TailProperties(TailProperties),
        TsBindgenRtNull,
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct CorpMaterialConstantData {
        #[serde(rename = "competitionRange")]
        pub competition_range: CorpMaterialConstantDataCompetitionRange,
        #[serde(rename = "competitionBase")]
        pub competition_base: f64,
        #[serde(rename = "baseCost")]
        pub base_cost: f64,
        #[serde(rename = "baseMarkup")]
        pub base_markup: f64,
        #[serde(rename = "size")]
        pub size: f64,
        #[serde(rename = "demandBase")]
        pub demand_base: f64,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "demandRange")]
        pub demand_range: CorpMaterialConstantDataDemandRange,
        #[serde(rename = "maxVolatility")]
        pub max_volatility: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait CorpMaterialConstantData_Trait {
        fn set_competition_base(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn competition_base(&self) -> std::result::Result<f64, JsValue>;
        fn set_max_volatility(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn max_volatility(&self) -> std::result::Result<f64, JsValue>;
        fn set_base_markup(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn base_markup(&self) -> std::result::Result<f64, JsValue>;
        fn set_base_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn base_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_demand_base(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn demand_base(&self) -> std::result::Result<f64, JsValue>;
        fn set_demand_range(
            &mut self,
            value: CorpMaterialConstantDataDemandRange,
        ) -> std::result::Result<(), JsValue>;
        fn demand_range(&self)
            -> std::result::Result<CorpMaterialConstantDataDemandRange, JsValue>;
        fn set_competition_range(
            &mut self,
            value: CorpMaterialConstantDataCompetitionRange,
        ) -> std::result::Result<(), JsValue>;
        fn competition_range(
            &self,
        ) -> std::result::Result<CorpMaterialConstantDataCompetitionRange, JsValue>;
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn name(&self) -> std::result::Result<String, JsValue>;
        fn set_size(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn size(&self) -> std::result::Result<f64, JsValue>;
    }
    impl CorpMaterialConstantData_Trait for CorpMaterialConstantData {
        fn set_competition_base(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.competition_base = value;
            Ok(())
        }
        fn competition_base(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.competition_base)
        }
        fn set_max_volatility(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.max_volatility = value;
            Ok(())
        }
        fn max_volatility(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.max_volatility)
        }
        fn set_base_markup(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.base_markup = value;
            Ok(())
        }
        fn base_markup(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.base_markup)
        }
        fn set_base_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.base_cost = value;
            Ok(())
        }
        fn base_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.base_cost)
        }
        fn set_demand_base(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.demand_base = value;
            Ok(())
        }
        fn demand_base(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.demand_base)
        }
        fn set_demand_range(
            &mut self,
            value: CorpMaterialConstantDataDemandRange,
        ) -> std::result::Result<(), JsValue> {
            self.demand_range = value;
            Ok(())
        }
        fn demand_range(
            &self,
        ) -> std::result::Result<CorpMaterialConstantDataDemandRange, JsValue> {
            Ok(self.demand_range.clone())
        }
        fn set_competition_range(
            &mut self,
            value: CorpMaterialConstantDataCompetitionRange,
        ) -> std::result::Result<(), JsValue> {
            self.competition_range = value;
            Ok(())
        }
        fn competition_range(
            &self,
        ) -> std::result::Result<CorpMaterialConstantDataCompetitionRange, JsValue> {
            Ok(self.competition_range.clone())
        }
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.name = value;
            Ok(())
        }
        fn name(&self) -> std::result::Result<String, JsValue> {
            Ok(self.name.clone())
        }
        fn set_size(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.size = value;
            Ok(())
        }
        fn size(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.size)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum MaterialDesiredSellPrice {
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Gang {
        #[serde(
            rename = "ascendMember",
            serialize_with = "Gang::__TSB__serialize_ascend_member",
            deserialize_with = "Gang::__TSB__deserialize_ascend_member"
        )]
        pub ascend_member:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<GangAscendMemberReturn, JsValue>>,
        #[serde(
            rename = "getMemberNames",
            serialize_with = "Gang::__TSB__serialize_get_member_names",
            deserialize_with = "Gang::__TSB__deserialize_get_member_names"
        )]
        pub get_member_names: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "getChanceToWinClash",
            serialize_with = "Gang::__TSB__serialize_get_chance_to_win_clash",
            deserialize_with = "Gang::__TSB__deserialize_get_chance_to_win_clash"
        )]
        pub get_chance_to_win_clash:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "setMemberTask",
            serialize_with = "Gang::__TSB__serialize_set_member_task",
            deserialize_with = "Gang::__TSB__deserialize_set_member_task"
        )]
        pub set_member_task:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getBonusTime",
            serialize_with = "Gang::__TSB__serialize_get_bonus_time",
            deserialize_with = "Gang::__TSB__deserialize_get_bonus_time"
        )]
        pub get_bonus_time: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "recruitMember",
            serialize_with = "Gang::__TSB__serialize_recruit_member",
            deserialize_with = "Gang::__TSB__deserialize_recruit_member"
        )]
        pub recruit_member: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getEquipmentCost",
            serialize_with = "Gang::__TSB__serialize_get_equipment_cost",
            deserialize_with = "Gang::__TSB__deserialize_get_equipment_cost"
        )]
        pub get_equipment_cost: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getTaskStats",
            serialize_with = "Gang::__TSB__serialize_get_task_stats",
            deserialize_with = "Gang::__TSB__deserialize_get_task_stats"
        )]
        pub get_task_stats:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<GangTaskStats, JsValue>>,
        #[serde(
            rename = "getAscensionResult",
            serialize_with = "Gang::__TSB__serialize_get_ascension_result",
            deserialize_with = "Gang::__TSB__deserialize_get_ascension_result"
        )]
        pub get_ascension_result: std::rc::Rc<
            dyn Fn(String) -> std::result::Result<GangGetAscensionResultReturn, JsValue>,
        >,
        #[serde(
            rename = "getEquipmentStats",
            serialize_with = "Gang::__TSB__serialize_get_equipment_stats",
            deserialize_with = "Gang::__TSB__deserialize_get_equipment_stats"
        )]
        pub get_equipment_stats:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<EquipmentStats, JsValue>>,
        #[serde(
            rename = "getMemberInformation",
            serialize_with = "Gang::__TSB__serialize_get_member_information",
            deserialize_with = "Gang::__TSB__deserialize_get_member_information"
        )]
        pub get_member_information:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<GangMemberInfo, JsValue>>,
        #[serde(
            rename = "getOtherGangInformation",
            serialize_with = "Gang::__TSB__serialize_get_other_gang_information",
            deserialize_with = "Gang::__TSB__deserialize_get_other_gang_information"
        )]
        pub get_other_gang_information:
            std::rc::Rc<dyn Fn() -> std::result::Result<GangOtherInfo, JsValue>>,
        #[serde(
            rename = "getGangInformation",
            serialize_with = "Gang::__TSB__serialize_get_gang_information",
            deserialize_with = "Gang::__TSB__deserialize_get_gang_information"
        )]
        pub get_gang_information:
            std::rc::Rc<dyn Fn() -> std::result::Result<GangGenInfo, JsValue>>,
        #[serde(
            rename = "getEquipmentNames",
            serialize_with = "Gang::__TSB__serialize_get_equipment_names",
            deserialize_with = "Gang::__TSB__deserialize_get_equipment_names"
        )]
        pub get_equipment_names: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "purchaseEquipment",
            serialize_with = "Gang::__TSB__serialize_purchase_equipment",
            deserialize_with = "Gang::__TSB__deserialize_purchase_equipment"
        )]
        pub purchase_equipment:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getTaskNames",
            serialize_with = "Gang::__TSB__serialize_get_task_names",
            deserialize_with = "Gang::__TSB__deserialize_get_task_names"
        )]
        pub get_task_names: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "setTerritoryWarfare",
            serialize_with = "Gang::__TSB__serialize_set_territory_warfare",
            deserialize_with = "Gang::__TSB__deserialize_set_territory_warfare"
        )]
        pub set_territory_warfare: std::rc::Rc<dyn Fn(bool) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "canRecruitMember",
            serialize_with = "Gang::__TSB__serialize_can_recruit_member",
            deserialize_with = "Gang::__TSB__deserialize_can_recruit_member"
        )]
        pub can_recruit_member: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "createGang",
            serialize_with = "Gang::__TSB__serialize_create_gang",
            deserialize_with = "Gang::__TSB__deserialize_create_gang"
        )]
        pub create_gang: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getEquipmentType",
            serialize_with = "Gang::__TSB__serialize_get_equipment_type",
            deserialize_with = "Gang::__TSB__deserialize_get_equipment_type"
        )]
        pub get_equipment_type: std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
        #[serde(
            rename = "inGang",
            serialize_with = "Gang::__TSB__serialize_in_gang",
            deserialize_with = "Gang::__TSB__deserialize_in_gang"
        )]
        pub in_gang: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait Gang_Trait {
        fn set_get_task_stats(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<GangTaskStats, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_task_stats(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<GangTaskStats, JsValue>>,
            JsValue,
        >;
        fn set_get_other_gang_information(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<GangOtherInfo, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_other_gang_information(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<GangOtherInfo, JsValue>>,
            JsValue,
        >;
        fn set_get_member_information(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<GangMemberInfo, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_member_information(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<GangMemberInfo, JsValue>>,
            JsValue,
        >;
        fn set_get_ascension_result(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String) -> std::result::Result<GangGetAscensionResultReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_ascension_result(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String) -> std::result::Result<GangGetAscensionResultReturn, JsValue>,
            >,
            JsValue,
        >;
        fn set_ascend_member(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String) -> std::result::Result<GangAscendMemberReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn ascend_member(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<GangAscendMemberReturn, JsValue>>,
            JsValue,
        >;
        fn set_in_gang(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn in_gang(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_get_bonus_time(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_bonus_time(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_get_gang_information(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<GangGenInfo, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_gang_information(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<GangGenInfo, JsValue>>,
            JsValue,
        >;
        fn set_purchase_equipment(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn purchase_equipment(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_recruit_member(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn recruit_member(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_task_names(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_task_names(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_get_chance_to_win_clash(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_chance_to_win_clash(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_equipment_stats(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<EquipmentStats, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_equipment_stats(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<EquipmentStats, JsValue>>,
            JsValue,
        >;
        fn set_get_equipment_names(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_equipment_names(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_set_member_task(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_member_task(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_set_territory_warfare(
            &mut self,
            value: std::rc::Rc<dyn Fn(bool) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_territory_warfare(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_get_equipment_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_equipment_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_can_recruit_member(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn can_recruit_member(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_create_gang(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn create_gang(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_member_names(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_member_names(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_get_equipment_type(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_equipment_type(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
            JsValue,
        >;
    }
    impl Gang_Trait for Gang {
        fn set_get_task_stats(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<GangTaskStats, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_task_stats = value;
            Ok(())
        }
        fn get_task_stats(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<GangTaskStats, JsValue>>,
            JsValue,
        > {
            Ok(self.get_task_stats.clone())
        }
        fn set_get_other_gang_information(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<GangOtherInfo, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_other_gang_information = value;
            Ok(())
        }
        fn get_other_gang_information(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<GangOtherInfo, JsValue>>,
            JsValue,
        > {
            Ok(self.get_other_gang_information.clone())
        }
        fn set_get_member_information(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<GangMemberInfo, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_member_information = value;
            Ok(())
        }
        fn get_member_information(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<GangMemberInfo, JsValue>>,
            JsValue,
        > {
            Ok(self.get_member_information.clone())
        }
        fn set_get_ascension_result(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String) -> std::result::Result<GangGetAscensionResultReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_ascension_result = value;
            Ok(())
        }
        fn get_ascension_result(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String) -> std::result::Result<GangGetAscensionResultReturn, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.get_ascension_result.clone())
        }
        fn set_ascend_member(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String) -> std::result::Result<GangAscendMemberReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.ascend_member = value;
            Ok(())
        }
        fn ascend_member(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<GangAscendMemberReturn, JsValue>>,
            JsValue,
        > {
            Ok(self.ascend_member.clone())
        }
        fn set_in_gang(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.in_gang = value;
            Ok(())
        }
        fn in_gang(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.in_gang.clone())
        }
        fn set_get_bonus_time(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_bonus_time = value;
            Ok(())
        }
        fn get_bonus_time(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_bonus_time.clone())
        }
        fn set_get_gang_information(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<GangGenInfo, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_gang_information = value;
            Ok(())
        }
        fn get_gang_information(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<GangGenInfo, JsValue>>,
            JsValue,
        > {
            Ok(self.get_gang_information.clone())
        }
        fn set_purchase_equipment(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.purchase_equipment = value;
            Ok(())
        }
        fn purchase_equipment(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.purchase_equipment.clone())
        }
        fn set_recruit_member(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.recruit_member = value;
            Ok(())
        }
        fn recruit_member(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.recruit_member.clone())
        }
        fn set_get_task_names(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_task_names = value;
            Ok(())
        }
        fn get_task_names(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_task_names.clone())
        }
        fn set_get_chance_to_win_clash(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_chance_to_win_clash = value;
            Ok(())
        }
        fn get_chance_to_win_clash(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_chance_to_win_clash.clone())
        }
        fn set_get_equipment_stats(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<EquipmentStats, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_equipment_stats = value;
            Ok(())
        }
        fn get_equipment_stats(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<EquipmentStats, JsValue>>,
            JsValue,
        > {
            Ok(self.get_equipment_stats.clone())
        }
        fn set_get_equipment_names(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_equipment_names = value;
            Ok(())
        }
        fn get_equipment_names(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_equipment_names.clone())
        }
        fn set_set_member_task(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_member_task = value;
            Ok(())
        }
        fn set_member_task(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.set_member_task.clone())
        }
        fn set_set_territory_warfare(
            &mut self,
            value: std::rc::Rc<dyn Fn(bool) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_territory_warfare = value;
            Ok(())
        }
        fn set_territory_warfare(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.set_territory_warfare.clone())
        }
        fn set_get_equipment_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_equipment_cost = value;
            Ok(())
        }
        fn get_equipment_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_equipment_cost.clone())
        }
        fn set_can_recruit_member(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.can_recruit_member = value;
            Ok(())
        }
        fn can_recruit_member(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.can_recruit_member.clone())
        }
        fn set_create_gang(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.create_gang = value;
            Ok(())
        }
        fn create_gang(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.create_gang.clone())
        }
        fn set_get_member_names(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_member_names = value;
            Ok(())
        }
        fn get_member_names(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_member_names.clone())
        }
        fn set_get_equipment_type(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_equipment_type = value;
            Ok(())
        }
        fn get_equipment_type(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
            JsValue,
        > {
            Ok(self.get_equipment_type.clone())
        }
    }
    impl Gang {
        #[allow(non_snake_case)]
        fn __TSB__serialize_ascend_member<S>(
            ascend_member: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<GangAscendMemberReturn, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let ascend_member = ascend_member.clone();
            let ascend_member_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<JsValue, JsValue> {
                    let result = ascend_member(arg0)?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &ascend_member_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_member_names<S>(
            get_member_names: &std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_member_names = get_member_names.clone();
            let get_member_names_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_member_names()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_member_names_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_chance_to_win_clash<S>(
            get_chance_to_win_clash: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_chance_to_win_clash = get_chance_to_win_clash.clone();
            let get_chance_to_win_clash_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_chance_to_win_clash(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_chance_to_win_clash_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_member_task<S>(
            set_member_task: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_member_task = set_member_task.clone();
            let set_member_task_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<bool, JsValue> {
                    let result = set_member_task(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_member_task_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_bonus_time<S>(
            get_bonus_time: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_bonus_time = get_bonus_time.clone();
            let get_bonus_time_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_bonus_time()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_bonus_time_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_recruit_member<S>(
            recruit_member: &std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let recruit_member = recruit_member.clone();
            let recruit_member_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<bool, JsValue> {
                    let result = recruit_member(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &recruit_member_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_equipment_cost<S>(
            get_equipment_cost: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_equipment_cost = get_equipment_cost.clone();
            let get_equipment_cost_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_equipment_cost(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_equipment_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_task_stats<S>(
            get_task_stats: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<GangTaskStats, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_task_stats = get_task_stats.clone();
            let get_task_stats_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<JsValue, JsValue> {
                    let result = get_task_stats(arg0)?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_task_stats_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_ascension_result<S>(
            get_ascension_result: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<GangGetAscensionResultReturn, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_ascension_result = get_ascension_result.clone();
            let get_ascension_result_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<JsValue, JsValue> {
                    let result = get_ascension_result(arg0)?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_ascension_result_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_equipment_stats<S>(
            get_equipment_stats: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<EquipmentStats, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_equipment_stats = get_equipment_stats.clone();
            let get_equipment_stats_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<JsValue, JsValue> {
                    let result = get_equipment_stats(arg0)?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_equipment_stats_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_member_information<S>(
            get_member_information: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<GangMemberInfo, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_member_information = get_member_information.clone();
            let get_member_information_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<JsValue, JsValue> {
                    let result = get_member_information(arg0)?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_member_information_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_other_gang_information<S>(
            get_other_gang_information: &std::rc::Rc<
                dyn Fn() -> std::result::Result<GangOtherInfo, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_other_gang_information = get_other_gang_information.clone();
            let get_other_gang_information_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_other_gang_information()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_other_gang_information_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_gang_information<S>(
            get_gang_information: &std::rc::Rc<
                dyn Fn() -> std::result::Result<GangGenInfo, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_gang_information = get_gang_information.clone();
            let get_gang_information_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_gang_information()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_gang_information_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_equipment_names<S>(
            get_equipment_names: &std::rc::Rc<
                dyn Fn() -> std::result::Result<Vec<String>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_equipment_names = get_equipment_names.clone();
            let get_equipment_names_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_equipment_names()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_equipment_names_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_purchase_equipment<S>(
            purchase_equipment: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let purchase_equipment = purchase_equipment.clone();
            let purchase_equipment_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<bool, JsValue> {
                    let result = purchase_equipment(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &purchase_equipment_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_task_names<S>(
            get_task_names: &std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_task_names = get_task_names.clone();
            let get_task_names_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_task_names()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_task_names_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_territory_warfare<S>(
            set_territory_warfare: &std::rc::Rc<dyn Fn(bool) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_territory_warfare = set_territory_warfare.clone();
            let set_territory_warfare_closure = Closure::wrap(Box::new(
                move |arg0: bool| -> std::result::Result<(), JsValue> {
                    let result = set_territory_warfare(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(bool) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_territory_warfare_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_can_recruit_member<S>(
            can_recruit_member: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let can_recruit_member = can_recruit_member.clone();
            let can_recruit_member_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = can_recruit_member()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &can_recruit_member_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_create_gang<S>(
            create_gang: &std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let create_gang = create_gang.clone();
            let create_gang_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<bool, JsValue> {
                    let result = create_gang(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &create_gang_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_equipment_type<S>(
            get_equipment_type: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<String, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_equipment_type = get_equipment_type.clone();
            let get_equipment_type_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<String, JsValue> {
                    let result = get_equipment_type(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<String, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_equipment_type_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_in_gang<S>(
            in_gang: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let in_gang = in_gang.clone();
            let in_gang_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = in_gang()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &in_gang_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_ascend_member<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<GangAscendMemberReturn, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let ascend_member: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            ascend_member
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String) -> std::result::Result<GangAscendMemberReturn, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_member_names<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_member_names: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_member_names
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_chance_to_win_clash<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_chance_to_win_clash: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_chance_to_win_clash
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_member_task<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_member_task: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_member_task
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_bonus_time<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_bonus_time: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_bonus_time
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_recruit_member<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let recruit_member: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            recruit_member
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_equipment_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_equipment_cost: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_equipment_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_task_stats<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<GangTaskStats, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_task_stats: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_task_stats
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String) -> std::result::Result<GangTaskStats, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_ascension_result<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String) -> std::result::Result<GangGetAscensionResultReturn, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_ascension_result: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_ascension_result
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                            )
                                -> std::result::Result<GangGetAscensionResultReturn, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_equipment_stats<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<EquipmentStats, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_equipment_stats: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_equipment_stats
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String) -> std::result::Result<EquipmentStats, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_member_information<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<GangMemberInfo, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_member_information: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_member_information
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String) -> std::result::Result<GangMemberInfo, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_other_gang_information<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<GangOtherInfo, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_other_gang_information: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_other_gang_information
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<GangOtherInfo, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_gang_information<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<GangGenInfo, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_gang_information: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_gang_information
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<GangGenInfo, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_equipment_names<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_equipment_names: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_equipment_names
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_purchase_equipment<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let purchase_equipment: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            purchase_equipment
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_task_names<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_task_names: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_task_names
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_territory_warfare<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(bool) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_territory_warfare: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_territory_warfare
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: bool| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(bool) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_can_recruit_member<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let can_recruit_member: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            can_recruit_member
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_create_gang<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let create_gang: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            create_gang
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_equipment_type<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_equipment_type: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_equipment_type
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_in_gang<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let in_gang: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            in_gang
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Server {
        #[serde(rename = "isConnectedTo")]
        pub is_connected_to: bool,
        #[serde(rename = "hostname")]
        pub hostname: String,
        #[serde(rename = "ip")]
        pub ip: String,
        #[serde(rename = "moneyAvailable")]
        pub money_available: Option<f64>,
        #[serde(rename = "minDifficulty")]
        pub min_difficulty: Option<f64>,
        #[serde(rename = "baseDifficulty")]
        pub base_difficulty: Option<f64>,
        #[serde(rename = "requiredHackingSkill")]
        pub required_hacking_skill: Option<f64>,
        #[serde(rename = "numOpenPortsRequired")]
        pub num_open_ports_required: Option<f64>,
        #[serde(rename = "purchasedByPlayer")]
        pub purchased_by_player: bool,
        #[serde(rename = "hackDifficulty")]
        pub hack_difficulty: Option<f64>,
        #[serde(rename = "organizationName")]
        pub organization_name: String,
        #[serde(rename = "serverGrowth")]
        pub server_growth: Option<f64>,
        #[serde(rename = "moneyMax")]
        pub money_max: Option<f64>,
        #[serde(rename = "cpuCores")]
        pub cpu_cores: f64,
        #[serde(rename = "backdoorInstalled")]
        pub backdoor_installed: Option<bool>,
        #[serde(rename = "sshPortOpen")]
        pub ssh_port_open: bool,
        #[serde(rename = "httpPortOpen")]
        pub http_port_open: bool,
        #[serde(rename = "hasAdminRights")]
        pub has_admin_rights: bool,
        #[serde(rename = "ramUsed")]
        pub ram_used: f64,
        #[serde(rename = "smtpPortOpen")]
        pub smtp_port_open: bool,
        #[serde(rename = "maxRam")]
        pub max_ram: f64,
        #[serde(rename = "openPortCount")]
        pub open_port_count: Option<f64>,
        #[serde(rename = "ftpPortOpen")]
        pub ftp_port_open: bool,
        #[serde(rename = "sqlPortOpen")]
        pub sql_port_open: bool,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait Server_Trait {
        fn set_open_port_count(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn open_port_count(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_ram_used(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn ram_used(&self) -> std::result::Result<f64, JsValue>;
        fn set_money_available(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn money_available(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_required_hacking_skill(
            &mut self,
            value: Option<f64>,
        ) -> std::result::Result<(), JsValue>;
        fn required_hacking_skill(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_server_growth(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn server_growth(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_cpu_cores(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cpu_cores(&self) -> std::result::Result<f64, JsValue>;
        fn set_num_open_ports_required(
            &mut self,
            value: Option<f64>,
        ) -> std::result::Result<(), JsValue>;
        fn num_open_ports_required(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_is_connected_to(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn is_connected_to(&self) -> std::result::Result<bool, JsValue>;
        fn set_organization_name(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn organization_name(&self) -> std::result::Result<String, JsValue>;
        fn set_ip(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn ip(&self) -> std::result::Result<String, JsValue>;
        fn set_hack_difficulty(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn hack_difficulty(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_sql_port_open(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn sql_port_open(&self) -> std::result::Result<bool, JsValue>;
        fn set_min_difficulty(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn min_difficulty(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_backdoor_installed(
            &mut self,
            value: Option<bool>,
        ) -> std::result::Result<(), JsValue>;
        fn backdoor_installed(&self) -> std::result::Result<Option<bool>, JsValue>;
        fn set_base_difficulty(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn base_difficulty(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_money_max(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn money_max(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_hostname(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn hostname(&self) -> std::result::Result<String, JsValue>;
        fn set_smtp_port_open(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn smtp_port_open(&self) -> std::result::Result<bool, JsValue>;
        fn set_max_ram(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn max_ram(&self) -> std::result::Result<f64, JsValue>;
        fn set_http_port_open(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn http_port_open(&self) -> std::result::Result<bool, JsValue>;
        fn set_ssh_port_open(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn ssh_port_open(&self) -> std::result::Result<bool, JsValue>;
        fn set_purchased_by_player(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn purchased_by_player(&self) -> std::result::Result<bool, JsValue>;
        fn set_ftp_port_open(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn ftp_port_open(&self) -> std::result::Result<bool, JsValue>;
        fn set_has_admin_rights(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn has_admin_rights(&self) -> std::result::Result<bool, JsValue>;
    }
    impl Server_Trait for Server {
        fn set_open_port_count(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.open_port_count = value;
            Ok(())
        }
        fn open_port_count(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.open_port_count.clone())
        }
        fn set_ram_used(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.ram_used = value;
            Ok(())
        }
        fn ram_used(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.ram_used)
        }
        fn set_money_available(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.money_available = value;
            Ok(())
        }
        fn money_available(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.money_available.clone())
        }
        fn set_required_hacking_skill(
            &mut self,
            value: Option<f64>,
        ) -> std::result::Result<(), JsValue> {
            self.required_hacking_skill = value;
            Ok(())
        }
        fn required_hacking_skill(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.required_hacking_skill.clone())
        }
        fn set_server_growth(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.server_growth = value;
            Ok(())
        }
        fn server_growth(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.server_growth.clone())
        }
        fn set_cpu_cores(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cpu_cores = value;
            Ok(())
        }
        fn cpu_cores(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cpu_cores)
        }
        fn set_num_open_ports_required(
            &mut self,
            value: Option<f64>,
        ) -> std::result::Result<(), JsValue> {
            self.num_open_ports_required = value;
            Ok(())
        }
        fn num_open_ports_required(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.num_open_ports_required.clone())
        }
        fn set_is_connected_to(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.is_connected_to = value;
            Ok(())
        }
        fn is_connected_to(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.is_connected_to)
        }
        fn set_organization_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.organization_name = value;
            Ok(())
        }
        fn organization_name(&self) -> std::result::Result<String, JsValue> {
            Ok(self.organization_name.clone())
        }
        fn set_ip(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.ip = value;
            Ok(())
        }
        fn ip(&self) -> std::result::Result<String, JsValue> {
            Ok(self.ip.clone())
        }
        fn set_hack_difficulty(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.hack_difficulty = value;
            Ok(())
        }
        fn hack_difficulty(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.hack_difficulty.clone())
        }
        fn set_sql_port_open(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.sql_port_open = value;
            Ok(())
        }
        fn sql_port_open(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.sql_port_open)
        }
        fn set_min_difficulty(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.min_difficulty = value;
            Ok(())
        }
        fn min_difficulty(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.min_difficulty.clone())
        }
        fn set_backdoor_installed(
            &mut self,
            value: Option<bool>,
        ) -> std::result::Result<(), JsValue> {
            self.backdoor_installed = value;
            Ok(())
        }
        fn backdoor_installed(&self) -> std::result::Result<Option<bool>, JsValue> {
            Ok(self.backdoor_installed.clone())
        }
        fn set_base_difficulty(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.base_difficulty = value;
            Ok(())
        }
        fn base_difficulty(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.base_difficulty.clone())
        }
        fn set_money_max(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.money_max = value;
            Ok(())
        }
        fn money_max(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.money_max.clone())
        }
        fn set_hostname(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.hostname = value;
            Ok(())
        }
        fn hostname(&self) -> std::result::Result<String, JsValue> {
            Ok(self.hostname.clone())
        }
        fn set_smtp_port_open(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.smtp_port_open = value;
            Ok(())
        }
        fn smtp_port_open(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.smtp_port_open)
        }
        fn set_max_ram(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.max_ram = value;
            Ok(())
        }
        fn max_ram(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.max_ram)
        }
        fn set_http_port_open(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.http_port_open = value;
            Ok(())
        }
        fn http_port_open(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.http_port_open)
        }
        fn set_ssh_port_open(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.ssh_port_open = value;
            Ok(())
        }
        fn ssh_port_open(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.ssh_port_open)
        }
        fn set_purchased_by_player(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.purchased_by_player = value;
            Ok(())
        }
        fn purchased_by_player(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.purchased_by_player)
        }
        fn set_ftp_port_open(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.ftp_port_open = value;
            Ok(())
        }
        fn ftp_port_open(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.ftp_port_open)
        }
        fn set_has_admin_rights(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.has_admin_rights = value;
            Ok(())
        }
        fn has_admin_rights(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.has_admin_rights)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsScpParamsFiles {
        VecOfString(Vec<String>),
        String(String),
    }
    #[allow(dead_code, non_camel_case_types)]
    pub type NsEnums = NsEnumsAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum ProcessInfoArgs {
        Bool(bool),
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct IStyleSettings {
        #[serde(rename = "lineHeight")]
        pub line_height: f64,
        #[serde(rename = "fontFamily")]
        pub font_family: String,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait IStyleSettings_Trait {
        fn set_line_height(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn line_height(&self) -> std::result::Result<f64, JsValue>;
        fn set_font_family(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn font_family(&self) -> std::result::Result<String, JsValue>;
    }
    impl IStyleSettings_Trait for IStyleSettings {
        fn set_line_height(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.line_height = value;
            Ok(())
        }
        fn line_height(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.line_height)
        }
        fn set_font_family(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.font_family = value;
            Ok(())
        }
        fn font_family(&self) -> std::result::Result<String, JsValue> {
            Ok(self.font_family.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsTailParamsArgs {
        Bool(bool),
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct ActiveFragment {
        #[serde(rename = "x")]
        pub x: f64,
        #[serde(rename = "id")]
        pub id: f64,
        #[serde(rename = "y")]
        pub y: f64,
        #[serde(rename = "numCharge")]
        pub num_charge: f64,
        #[serde(rename = "highestCharge")]
        pub highest_charge: f64,
        #[serde(rename = "rotation")]
        pub rotation: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait ActiveFragment_Trait {
        fn set_x(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn x(&self) -> std::result::Result<f64, JsValue>;
        fn set_num_charge(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn num_charge(&self) -> std::result::Result<f64, JsValue>;
        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn id(&self) -> std::result::Result<f64, JsValue>;
        fn set_highest_charge(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn highest_charge(&self) -> std::result::Result<f64, JsValue>;
        fn set_y(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn y(&self) -> std::result::Result<f64, JsValue>;
        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn rotation(&self) -> std::result::Result<f64, JsValue>;
    }
    impl ActiveFragment_Trait for ActiveFragment {
        fn set_x(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.x = value;
            Ok(())
        }
        fn x(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.x)
        }
        fn set_num_charge(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.num_charge = value;
            Ok(())
        }
        fn num_charge(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.num_charge)
        }
        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.id = value;
            Ok(())
        }
        fn id(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.id)
        }
        fn set_highest_charge(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.highest_charge = value;
            Ok(())
        }
        fn highest_charge(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.highest_charge)
        }
        fn set_y(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.y = value;
            Ok(())
        }
        fn y(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.y)
        }
        fn set_rotation(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.rotation = value;
            Ok(())
        }
        fn rotation(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.rotation)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct GameInfo {
        #[serde(rename = "commit")]
        pub commit: String,
        #[serde(rename = "version")]
        pub version: String,
        #[serde(rename = "platform")]
        pub platform: String,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait GameInfo_Trait {
        fn set_platform(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn platform(&self) -> std::result::Result<String, JsValue>;
        fn set_commit(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn commit(&self) -> std::result::Result<String, JsValue>;
        fn set_version(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn version(&self) -> std::result::Result<String, JsValue>;
    }
    impl GameInfo_Trait for GameInfo {
        fn set_platform(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.platform = value;
            Ok(())
        }
        fn platform(&self) -> std::result::Result<String, JsValue> {
            Ok(self.platform.clone())
        }
        fn set_commit(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.commit = value;
            Ok(())
        }
        fn commit(&self) -> std::result::Result<String, JsValue> {
            Ok(self.commit.clone())
        }
        fn set_version(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.version = value;
            Ok(())
        }
        fn version(&self) -> std::result::Result<String, JsValue> {
            Ok(self.version.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum CorpResearchNameAliased {
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsGetScriptExpGainParamsArgs {
        Bool(bool),
        F64(f64),
        String(String),
    }
    #[wasm_bindgen]
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum GymType {
        Strength = "str",
        Defense = "def",
        Dexterity = "dex",
        Agility = "agi",
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum FilenameOrPidAliased {
        String(String),
        F64(f64),
    }
    #[allow(dead_code, non_camel_case_types)]
    type CorpMaterialName = CorpMaterialNameAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct TailProperties {
        #[serde(rename = "height")]
        pub height: f64,
        #[serde(rename = "width")]
        pub width: f64,
        #[serde(rename = "y")]
        pub y: f64,
        #[serde(rename = "x")]
        pub x: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait TailProperties_Trait {
        fn set_x(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn x(&self) -> std::result::Result<f64, JsValue>;
        fn set_width(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn width(&self) -> std::result::Result<f64, JsValue>;
        fn set_height(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn height(&self) -> std::result::Result<f64, JsValue>;
        fn set_y(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn y(&self) -> std::result::Result<f64, JsValue>;
    }
    impl TailProperties_Trait for TailProperties {
        fn set_x(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.x = value;
            Ok(())
        }
        fn x(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.x)
        }
        fn set_width(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.width = value;
            Ok(())
        }
        fn width(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.width)
        }
        fn set_height(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.height = value;
            Ok(())
        }
        fn height(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.height)
        }
        fn set_y(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.y = value;
            Ok(())
        }
        fn y(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.y)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NetscriptPortWriteReturn {
        TsBindgenRtNull,
        PortData(PortData),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct CorpIndustryData {
        #[serde(rename = "advertisingFactor")]
        pub advertising_factor: Option<f64>,
        #[serde(rename = "realEstateFactor")]
        pub real_estate_factor: Option<f64>,
        #[serde(rename = "requiredMaterials")]
        pub required_materials: std::collections::HashMap<String, f64>,
        #[serde(rename = "startingCost")]
        pub starting_cost: f64,
        #[serde(rename = "robotFactor")]
        pub robot_factor: Option<f64>,
        #[serde(rename = "description")]
        pub description: String,
        #[serde(rename = "aiCoreFactor")]
        pub ai_core_factor: Option<f64>,
        #[serde(rename = "recommendStarting")]
        pub recommend_starting: bool,
        #[serde(rename = "hardwareFactor")]
        pub hardware_factor: Option<f64>,
        #[serde(rename = "producedMaterials")]
        pub produced_materials: Option<Vec<CorpMaterialName>>,
        #[serde(rename = "product")]
        pub product: Option<CorpProductData>,
        #[serde(rename = "scienceFactor")]
        pub science_factor: Option<f64>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait CorpIndustryData_Trait {
        fn set_real_estate_factor(
            &mut self,
            value: Option<f64>,
        ) -> std::result::Result<(), JsValue>;
        fn real_estate_factor(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_produced_materials(
            &mut self,
            value: Option<Vec<CorpMaterialName>>,
        ) -> std::result::Result<(), JsValue>;
        fn produced_materials(&self)
            -> std::result::Result<Option<Vec<CorpMaterialName>>, JsValue>;
        fn set_ai_core_factor(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn ai_core_factor(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_advertising_factor(
            &mut self,
            value: Option<f64>,
        ) -> std::result::Result<(), JsValue>;
        fn advertising_factor(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_robot_factor(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn robot_factor(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_starting_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn starting_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_description(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn description(&self) -> std::result::Result<String, JsValue>;
        fn set_recommend_starting(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn recommend_starting(&self) -> std::result::Result<bool, JsValue>;
        fn set_hardware_factor(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn hardware_factor(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_product(
            &mut self,
            value: Option<CorpProductData>,
        ) -> std::result::Result<(), JsValue>;
        fn product(&self) -> std::result::Result<Option<CorpProductData>, JsValue>;
        fn set_science_factor(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn science_factor(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_required_materials(
            &mut self,
            value: std::collections::HashMap<String, f64>,
        ) -> std::result::Result<(), JsValue>;
        fn required_materials(
            &self,
        ) -> std::result::Result<std::collections::HashMap<String, f64>, JsValue>;
    }
    impl CorpIndustryData_Trait for CorpIndustryData {
        fn set_real_estate_factor(
            &mut self,
            value: Option<f64>,
        ) -> std::result::Result<(), JsValue> {
            self.real_estate_factor = value;
            Ok(())
        }
        fn real_estate_factor(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.real_estate_factor.clone())
        }
        fn set_produced_materials(
            &mut self,
            value: Option<Vec<CorpMaterialName>>,
        ) -> std::result::Result<(), JsValue> {
            self.produced_materials = value;
            Ok(())
        }
        fn produced_materials(
            &self,
        ) -> std::result::Result<Option<Vec<CorpMaterialName>>, JsValue> {
            Ok(self.produced_materials.clone())
        }
        fn set_ai_core_factor(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.ai_core_factor = value;
            Ok(())
        }
        fn ai_core_factor(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.ai_core_factor.clone())
        }
        fn set_advertising_factor(
            &mut self,
            value: Option<f64>,
        ) -> std::result::Result<(), JsValue> {
            self.advertising_factor = value;
            Ok(())
        }
        fn advertising_factor(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.advertising_factor.clone())
        }
        fn set_robot_factor(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.robot_factor = value;
            Ok(())
        }
        fn robot_factor(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.robot_factor.clone())
        }
        fn set_starting_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.starting_cost = value;
            Ok(())
        }
        fn starting_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.starting_cost)
        }
        fn set_description(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.description = value;
            Ok(())
        }
        fn description(&self) -> std::result::Result<String, JsValue> {
            Ok(self.description.clone())
        }
        fn set_recommend_starting(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.recommend_starting = value;
            Ok(())
        }
        fn recommend_starting(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.recommend_starting)
        }
        fn set_hardware_factor(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.hardware_factor = value;
            Ok(())
        }
        fn hardware_factor(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.hardware_factor.clone())
        }
        fn set_product(
            &mut self,
            value: Option<CorpProductData>,
        ) -> std::result::Result<(), JsValue> {
            self.product = value;
            Ok(())
        }
        fn product(&self) -> std::result::Result<Option<CorpProductData>, JsValue> {
            Ok(self.product.clone())
        }
        fn set_science_factor(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.science_factor = value;
            Ok(())
        }
        fn science_factor(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.science_factor.clone())
        }
        fn set_required_materials(
            &mut self,
            value: std::collections::HashMap<String, f64>,
        ) -> std::result::Result<(), JsValue> {
            self.required_materials = value;
            Ok(())
        }
        fn required_materials(
            &self,
        ) -> std::result::Result<std::collections::HashMap<String, f64>, JsValue> {
            Ok(self.required_materials.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct TixGetPositionReturn(pub f64, pub f64, pub f64, pub f64);
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct ProcessInfo {
        #[serde(rename = "temporary")]
        pub temporary: bool,
        #[serde(rename = "threads")]
        pub threads: f64,
        #[serde(rename = "pid")]
        pub pid: f64,
        #[serde(rename = "filename")]
        pub filename: String,
        #[serde(rename = "args")]
        pub args: Vec<ProcessInfoArgs>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait ProcessInfo_Trait {
        fn set_pid(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn pid(&self) -> std::result::Result<f64, JsValue>;
        fn set_threads(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn threads(&self) -> std::result::Result<f64, JsValue>;
        fn set_filename(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn filename(&self) -> std::result::Result<String, JsValue>;
        fn set_args(&mut self, value: Vec<ProcessInfoArgs>) -> std::result::Result<(), JsValue>;
        fn args(&self) -> std::result::Result<Vec<ProcessInfoArgs>, JsValue>;
        fn set_temporary(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn temporary(&self) -> std::result::Result<bool, JsValue>;
    }
    impl ProcessInfo_Trait for ProcessInfo {
        fn set_pid(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.pid = value;
            Ok(())
        }
        fn pid(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.pid)
        }
        fn set_threads(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.threads = value;
            Ok(())
        }
        fn threads(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.threads)
        }
        fn set_filename(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.filename = value;
            Ok(())
        }
        fn filename(&self) -> std::result::Result<String, JsValue> {
            Ok(self.filename.clone())
        }
        fn set_args(&mut self, value: Vec<ProcessInfoArgs>) -> std::result::Result<(), JsValue> {
            self.args = value;
            Ok(())
        }
        fn args(&self) -> std::result::Result<Vec<ProcessInfoArgs>, JsValue> {
            Ok(self.args.clone())
        }
        fn set_temporary(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.temporary = value;
            Ok(())
        }
        fn temporary(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.temporary)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct WarehouseApi {
        #[serde(
            rename = "setSmartSupplyOption",
            serialize_with = "WarehouseApi::__TSB__serialize_set_smart_supply_option",
            deserialize_with = "WarehouseApi::__TSB__deserialize_set_smart_supply_option"
        )]
        pub set_smart_supply_option: std::rc::Rc<
            dyn Fn(String, CityName, String, String) -> std::result::Result<(), JsValue>,
        >,
        #[serde(
            rename = "limitMaterialProduction",
            serialize_with = "WarehouseApi::__TSB__serialize_limit_material_production",
            deserialize_with = "WarehouseApi::__TSB__deserialize_limit_material_production"
        )]
        pub limit_material_production:
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "sellProduct",
            serialize_with = "WarehouseApi::__TSB__serialize_sell_product",
            deserialize_with = "WarehouseApi::__TSB__deserialize_sell_product"
        )]
        pub sell_product: std::rc::Rc<
            dyn Fn(
                String,
                CityName,
                String,
                String,
                String,
                bool,
            ) -> std::result::Result<(), JsValue>,
        >,
        #[serde(
            rename = "setMaterialMarketTA1",
            serialize_with = "WarehouseApi::__TSB__serialize_set_material_market_ta1",
            deserialize_with = "WarehouseApi::__TSB__deserialize_set_material_market_ta1"
        )]
        pub set_material_market_ta1:
            std::rc::Rc<dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "getWarehouse",
            serialize_with = "WarehouseApi::__TSB__serialize_get_warehouse",
            deserialize_with = "WarehouseApi::__TSB__deserialize_get_warehouse"
        )]
        pub get_warehouse:
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Warehouse, JsValue>>,
        #[serde(
            rename = "limitProductProduction",
            serialize_with = "WarehouseApi::__TSB__serialize_limit_product_production",
            deserialize_with = "WarehouseApi::__TSB__deserialize_limit_product_production"
        )]
        pub limit_product_production:
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "makeProduct",
            serialize_with = "WarehouseApi::__TSB__serialize_make_product",
            deserialize_with = "WarehouseApi::__TSB__deserialize_make_product"
        )]
        pub make_product: std::rc::Rc<
            dyn Fn(String, CityName, String, f64, f64) -> std::result::Result<(), JsValue>,
        >,
        #[serde(
            rename = "getProduct",
            serialize_with = "WarehouseApi::__TSB__serialize_get_product",
            deserialize_with = "WarehouseApi::__TSB__deserialize_get_product"
        )]
        pub get_product:
            std::rc::Rc<dyn Fn(String, CityName, String) -> std::result::Result<Product, JsValue>>,
        #[serde(
            rename = "upgradeWarehouse",
            serialize_with = "WarehouseApi::__TSB__serialize_upgrade_warehouse",
            deserialize_with = "WarehouseApi::__TSB__deserialize_upgrade_warehouse"
        )]
        pub upgrade_warehouse:
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "setMaterialMarketTA2",
            serialize_with = "WarehouseApi::__TSB__serialize_set_material_market_ta2",
            deserialize_with = "WarehouseApi::__TSB__deserialize_set_material_market_ta2"
        )]
        pub set_material_market_ta2:
            std::rc::Rc<dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "exportMaterial",
            serialize_with = "WarehouseApi::__TSB__serialize_export_material",
            deserialize_with = "WarehouseApi::__TSB__deserialize_export_material"
        )]
        pub export_material: std::rc::Rc<
            dyn Fn(
                String,
                CityName,
                String,
                CityName,
                String,
                WarehouseApiExportMaterialParamsAmt,
            ) -> std::result::Result<(), JsValue>,
        >,
        #[serde(
            rename = "setProductMarketTA1",
            serialize_with = "WarehouseApi::__TSB__serialize_set_product_market_ta1",
            deserialize_with = "WarehouseApi::__TSB__deserialize_set_product_market_ta1"
        )]
        pub set_product_market_ta1:
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "bulkPurchase",
            serialize_with = "WarehouseApi::__TSB__serialize_bulk_purchase",
            deserialize_with = "WarehouseApi::__TSB__deserialize_bulk_purchase"
        )]
        pub bulk_purchase:
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "buyMaterial",
            serialize_with = "WarehouseApi::__TSB__serialize_buy_material",
            deserialize_with = "WarehouseApi::__TSB__deserialize_buy_material"
        )]
        pub buy_material:
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "cancelExportMaterial",
            serialize_with = "WarehouseApi::__TSB__serialize_cancel_export_material",
            deserialize_with = "WarehouseApi::__TSB__deserialize_cancel_export_material"
        )]
        pub cancel_export_material: std::rc::Rc<
            dyn Fn(String, CityName, String, CityName, String) -> std::result::Result<(), JsValue>,
        >,
        #[serde(
            rename = "setSmartSupply",
            serialize_with = "WarehouseApi::__TSB__serialize_set_smart_supply",
            deserialize_with = "WarehouseApi::__TSB__deserialize_set_smart_supply"
        )]
        pub set_smart_supply:
            std::rc::Rc<dyn Fn(String, CityName, bool) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "getUpgradeWarehouseCost",
            serialize_with = "WarehouseApi::__TSB__serialize_get_upgrade_warehouse_cost",
            deserialize_with = "WarehouseApi::__TSB__deserialize_get_upgrade_warehouse_cost"
        )]
        pub get_upgrade_warehouse_cost:
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "discontinueProduct",
            serialize_with = "WarehouseApi::__TSB__serialize_discontinue_product",
            deserialize_with = "WarehouseApi::__TSB__deserialize_discontinue_product"
        )]
        pub discontinue_product:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "setProductMarketTA2",
            serialize_with = "WarehouseApi::__TSB__serialize_set_product_market_ta2",
            deserialize_with = "WarehouseApi::__TSB__deserialize_set_product_market_ta2"
        )]
        pub set_product_market_ta2:
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "hasWarehouse",
            serialize_with = "WarehouseApi::__TSB__serialize_has_warehouse",
            deserialize_with = "WarehouseApi::__TSB__deserialize_has_warehouse"
        )]
        pub has_warehouse:
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getMaterial",
            serialize_with = "WarehouseApi::__TSB__serialize_get_material",
            deserialize_with = "WarehouseApi::__TSB__deserialize_get_material"
        )]
        pub get_material:
            std::rc::Rc<dyn Fn(String, CityName, String) -> std::result::Result<Material, JsValue>>,
        #[serde(
            rename = "purchaseWarehouse",
            serialize_with = "WarehouseApi::__TSB__serialize_purchase_warehouse",
            deserialize_with = "WarehouseApi::__TSB__deserialize_purchase_warehouse"
        )]
        pub purchase_warehouse:
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "sellMaterial",
            serialize_with = "WarehouseApi::__TSB__serialize_sell_material",
            deserialize_with = "WarehouseApi::__TSB__deserialize_sell_material"
        )]
        pub sell_material: std::rc::Rc<
            dyn Fn(String, CityName, String, String, String) -> std::result::Result<(), JsValue>,
        >,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait WarehouseApi_Trait {
        fn set_limit_product_production(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn limit_product_production(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_set_material_market_ta2(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn set_material_market_ta2(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_get_upgrade_warehouse_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_upgrade_warehouse_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_limit_material_production(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn limit_material_production(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_set_product_market_ta1(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_product_market_ta1(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_has_warehouse(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn has_warehouse(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_export_material(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                    WarehouseApiExportMaterialParamsAmt,
                ) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn export_material(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                    WarehouseApiExportMaterialParamsAmt,
                ) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        >;
        fn set_purchase_warehouse(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn purchase_warehouse(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_bulk_purchase(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn bulk_purchase(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_make_product(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, f64, f64) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn make_product(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, CityName, String, f64, f64) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        >;
        fn set_get_material(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String) -> std::result::Result<Material, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_material(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String) -> std::result::Result<Material, JsValue>>,
            JsValue,
        >;
        fn set_buy_material(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn buy_material(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_cancel_export_material(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn cancel_export_material(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        >;
        fn set_set_smart_supply(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName, bool) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_smart_supply(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_discontinue_product(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn discontinue_product(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_set_product_market_ta2(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_product_market_ta2(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_get_warehouse(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Warehouse, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_warehouse(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Warehouse, JsValue>>,
            JsValue,
        >;
        fn set_set_material_market_ta1(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn set_material_market_ta1(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_sell_product(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                    bool,
                ) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn sell_product(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                    bool,
                ) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        >;
        fn set_set_smart_supply_option(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, String) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn set_smart_supply_option(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, CityName, String, String) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        >;
        fn set_sell_material(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn sell_material(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        >;
        fn set_get_product(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String) -> std::result::Result<Product, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_product(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String) -> std::result::Result<Product, JsValue>>,
            JsValue,
        >;
        fn set_upgrade_warehouse(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn upgrade_warehouse(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
    }
    impl WarehouseApi_Trait for WarehouseApi {
        fn set_limit_product_production(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.limit_product_production = value;
            Ok(())
        }
        fn limit_product_production(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.limit_product_production.clone())
        }
        fn set_set_material_market_ta2(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.set_material_market_ta2 = value;
            Ok(())
        }
        fn set_material_market_ta2(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.set_material_market_ta2.clone())
        }
        fn set_get_upgrade_warehouse_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_upgrade_warehouse_cost = value;
            Ok(())
        }
        fn get_upgrade_warehouse_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_upgrade_warehouse_cost.clone())
        }
        fn set_limit_material_production(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.limit_material_production = value;
            Ok(())
        }
        fn limit_material_production(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.limit_material_production.clone())
        }
        fn set_set_product_market_ta1(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_product_market_ta1 = value;
            Ok(())
        }
        fn set_product_market_ta1(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.set_product_market_ta1.clone())
        }
        fn set_has_warehouse(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.has_warehouse = value;
            Ok(())
        }
        fn has_warehouse(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.has_warehouse.clone())
        }
        fn set_export_material(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                    WarehouseApiExportMaterialParamsAmt,
                ) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.export_material = value;
            Ok(())
        }
        fn export_material(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                    WarehouseApiExportMaterialParamsAmt,
                ) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        > {
            Ok(self.export_material.clone())
        }
        fn set_purchase_warehouse(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.purchase_warehouse = value;
            Ok(())
        }
        fn purchase_warehouse(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.purchase_warehouse.clone())
        }
        fn set_bulk_purchase(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.bulk_purchase = value;
            Ok(())
        }
        fn bulk_purchase(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.bulk_purchase.clone())
        }
        fn set_make_product(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, f64, f64) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.make_product = value;
            Ok(())
        }
        fn make_product(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, CityName, String, f64, f64) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        > {
            Ok(self.make_product.clone())
        }
        fn set_get_material(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String) -> std::result::Result<Material, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_material = value;
            Ok(())
        }
        fn get_material(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String) -> std::result::Result<Material, JsValue>>,
            JsValue,
        > {
            Ok(self.get_material.clone())
        }
        fn set_buy_material(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.buy_material = value;
            Ok(())
        }
        fn buy_material(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.buy_material.clone())
        }
        fn set_cancel_export_material(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.cancel_export_material = value;
            Ok(())
        }
        fn cancel_export_material(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        > {
            Ok(self.cancel_export_material.clone())
        }
        fn set_set_smart_supply(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName, bool) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_smart_supply = value;
            Ok(())
        }
        fn set_smart_supply(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.set_smart_supply.clone())
        }
        fn set_discontinue_product(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.discontinue_product = value;
            Ok(())
        }
        fn discontinue_product(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.discontinue_product.clone())
        }
        fn set_set_product_market_ta2(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_product_market_ta2 = value;
            Ok(())
        }
        fn set_product_market_ta2(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.set_product_market_ta2.clone())
        }
        fn set_get_warehouse(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Warehouse, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_warehouse = value;
            Ok(())
        }
        fn get_warehouse(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Warehouse, JsValue>>,
            JsValue,
        > {
            Ok(self.get_warehouse.clone())
        }
        fn set_set_material_market_ta1(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.set_material_market_ta1 = value;
            Ok(())
        }
        fn set_material_market_ta1(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.set_material_market_ta1.clone())
        }
        fn set_sell_product(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                    bool,
                ) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.sell_product = value;
            Ok(())
        }
        fn sell_product(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                    bool,
                ) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        > {
            Ok(self.sell_product.clone())
        }
        fn set_set_smart_supply_option(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, String) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.set_smart_supply_option = value;
            Ok(())
        }
        fn set_smart_supply_option(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, CityName, String, String) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        > {
            Ok(self.set_smart_supply_option.clone())
        }
        fn set_sell_material(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.sell_material = value;
            Ok(())
        }
        fn sell_material(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        > {
            Ok(self.sell_material.clone())
        }
        fn set_get_product(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String) -> std::result::Result<Product, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_product = value;
            Ok(())
        }
        fn get_product(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String) -> std::result::Result<Product, JsValue>>,
            JsValue,
        > {
            Ok(self.get_product.clone())
        }
        fn set_upgrade_warehouse(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.upgrade_warehouse = value;
            Ok(())
        }
        fn upgrade_warehouse(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.upgrade_warehouse.clone())
        }
    }
    impl WarehouseApi {
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_smart_supply_option<S>(
            set_smart_supply_option: &std::rc::Rc<
                dyn Fn(String, CityName, String, String) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_smart_supply_option = set_smart_supply_option.clone();
            let set_smart_supply_option_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: String|
                      -> std::result::Result<(), JsValue> {
                    let result = set_smart_supply_option(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                    )?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(String, JsValue, String, String) -> std::result::Result<(), JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_smart_supply_option_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_limit_material_production<S>(
            limit_material_production: &std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let limit_material_production = limit_material_production.clone();
            let limit_material_production_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: f64|
                      -> std::result::Result<(), JsValue> {
                    let result = limit_material_production(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, String, f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &limit_material_production_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_sell_product<S>(
            sell_product: &std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                    bool,
                ) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let sell_product = sell_product.clone();
            let sell_product_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: String,
                      arg4: String,
                      arg5: bool|
                      -> std::result::Result<(), JsValue> {
                    let result = sell_product(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                        arg4,
                        arg5,
                    )?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        String,
                        JsValue,
                        String,
                        String,
                        String,
                        bool,
                    ) -> std::result::Result<(), JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &sell_product_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_material_market_ta1<S>(
            set_material_market_ta1: &std::rc::Rc<
                dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_material_market_ta1 = set_material_market_ta1.clone();
            let set_material_market_ta1_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: bool|
                      -> std::result::Result<(), JsValue> {
                    let result = set_material_market_ta1(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, String, bool) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_material_market_ta1_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_warehouse<S>(
            get_warehouse: &std::rc::Rc<
                dyn Fn(String, CityName) -> std::result::Result<Warehouse, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_warehouse = get_warehouse.clone();
            let get_warehouse_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: JsValue| -> std::result::Result<JsValue, JsValue> {
                    let result = get_warehouse(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(String, JsValue) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_warehouse_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_limit_product_production<S>(
            limit_product_production: &std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let limit_product_production = limit_product_production.clone();
            let limit_product_production_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: f64|
                      -> std::result::Result<(), JsValue> {
                    let result = limit_product_production(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, String, f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &limit_product_production_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_make_product<S>(
            make_product: &std::rc::Rc<
                dyn Fn(String, CityName, String, f64, f64) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let make_product = make_product.clone();
            let make_product_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: f64,
                      arg4: f64|
                      -> std::result::Result<(), JsValue> {
                    let result = make_product(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                        arg4,
                    )?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(String, JsValue, String, f64, f64) -> std::result::Result<(), JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &make_product_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_product<S>(
            get_product: &std::rc::Rc<
                dyn Fn(String, CityName, String) -> std::result::Result<Product, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_product = get_product.clone();
            let get_product_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String|
                      -> std::result::Result<JsValue, JsValue> {
                    let result = get_product(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(String, JsValue, String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_product_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_upgrade_warehouse<S>(
            upgrade_warehouse: &std::rc::Rc<
                dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let upgrade_warehouse = upgrade_warehouse.clone();
            let upgrade_warehouse_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: JsValue, arg2: f64| -> std::result::Result<(), JsValue> {
                    let result = upgrade_warehouse(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &upgrade_warehouse_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_material_market_ta2<S>(
            set_material_market_ta2: &std::rc::Rc<
                dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_material_market_ta2 = set_material_market_ta2.clone();
            let set_material_market_ta2_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: bool|
                      -> std::result::Result<(), JsValue> {
                    let result = set_material_market_ta2(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, String, bool) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_material_market_ta2_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_export_material<S>(
            export_material: &std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                    WarehouseApiExportMaterialParamsAmt,
                ) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let export_material = export_material.clone();
            let export_material_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: JsValue,
                      arg4: String,
                      arg5: JsValue|
                      -> std::result::Result<(), JsValue> {
                    let result = export_material(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        ts_bindgen_rt::from_jsvalue(&arg3).map_err(ts_bindgen_rt::Error::from)?,
                        arg4,
                        ts_bindgen_rt::from_jsvalue(&arg5).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        String,
                        JsValue,
                        String,
                        JsValue,
                        String,
                        JsValue,
                    ) -> std::result::Result<(), JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &export_material_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_product_market_ta1<S>(
            set_product_market_ta1: &std::rc::Rc<
                dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_product_market_ta1 = set_product_market_ta1.clone();
            let set_product_market_ta1_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String, arg2: bool| -> std::result::Result<(), JsValue> {
                    let result = set_product_market_ta1(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_product_market_ta1_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_bulk_purchase<S>(
            bulk_purchase: &std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let bulk_purchase = bulk_purchase.clone();
            let bulk_purchase_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: f64|
                      -> std::result::Result<(), JsValue> {
                    let result = bulk_purchase(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, String, f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &bulk_purchase_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_buy_material<S>(
            buy_material: &std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let buy_material = buy_material.clone();
            let buy_material_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: f64|
                      -> std::result::Result<(), JsValue> {
                    let result = buy_material(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, String, f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &buy_material_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_cancel_export_material<S>(
            cancel_export_material: &std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let cancel_export_material = cancel_export_material.clone();
            let cancel_export_material_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: JsValue,
                      arg4: String|
                      -> std::result::Result<(), JsValue> {
                    let result = cancel_export_material(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        ts_bindgen_rt::from_jsvalue(&arg3).map_err(ts_bindgen_rt::Error::from)?,
                        arg4,
                    )?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        String,
                        JsValue,
                        String,
                        JsValue,
                        String,
                    ) -> std::result::Result<(), JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &cancel_export_material_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_smart_supply<S>(
            set_smart_supply: &std::rc::Rc<
                dyn Fn(String, CityName, bool) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_smart_supply = set_smart_supply.clone();
            let set_smart_supply_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: bool|
                      -> std::result::Result<(), JsValue> {
                    let result = set_smart_supply(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, bool) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_smart_supply_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_upgrade_warehouse_cost<S>(
            get_upgrade_warehouse_cost: &std::rc::Rc<
                dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_upgrade_warehouse_cost = get_upgrade_warehouse_cost.clone();
            let get_upgrade_warehouse_cost_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: f64|
                      -> std::result::Result<f64, JsValue> {
                    let result = get_upgrade_warehouse_cost(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_upgrade_warehouse_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_discontinue_product<S>(
            discontinue_product: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let discontinue_product = discontinue_product.clone();
            let discontinue_product_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<(), JsValue> {
                    let result = discontinue_product(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &discontinue_product_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_product_market_ta2<S>(
            set_product_market_ta2: &std::rc::Rc<
                dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_product_market_ta2 = set_product_market_ta2.clone();
            let set_product_market_ta2_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String, arg2: bool| -> std::result::Result<(), JsValue> {
                    let result = set_product_market_ta2(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_product_market_ta2_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_has_warehouse<S>(
            has_warehouse: &std::rc::Rc<
                dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let has_warehouse = has_warehouse.clone();
            let has_warehouse_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: JsValue| -> std::result::Result<bool, JsValue> {
                    let result = has_warehouse(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &has_warehouse_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_material<S>(
            get_material: &std::rc::Rc<
                dyn Fn(String, CityName, String) -> std::result::Result<Material, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_material = get_material.clone();
            let get_material_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String|
                      -> std::result::Result<JsValue, JsValue> {
                    let result = get_material(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(String, JsValue, String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_material_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_purchase_warehouse<S>(
            purchase_warehouse: &std::rc::Rc<
                dyn Fn(String, CityName) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let purchase_warehouse = purchase_warehouse.clone();
            let purchase_warehouse_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: JsValue| -> std::result::Result<(), JsValue> {
                    let result = purchase_warehouse(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &purchase_warehouse_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_sell_material<S>(
            sell_material: &std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let sell_material = sell_material.clone();
            let sell_material_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: String,
                      arg4: String|
                      -> std::result::Result<(), JsValue> {
                    let result = sell_material(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                        arg4,
                    )?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        String,
                        JsValue,
                        String,
                        String,
                        String,
                    ) -> std::result::Result<(), JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &sell_material_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_smart_supply_option<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, CityName, String, String) -> std::result::Result<(), JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_smart_supply_option: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_smart_supply_option
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: String, arg3: String| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                String,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_limit_material_production<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let limit_material_production: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            limit_material_production
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: String, arg3: f64| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                f64,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_sell_product<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                    bool,
                ) -> std::result::Result<(), JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let sell_product: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            sell_product
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String,
                              arg1: CityName,
                              arg2: String,
                              arg3: String,
                              arg4: String,
                              arg5: bool| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let arg4 = JsValue::from(arg4);
                            let arg5 = JsValue::from(arg5);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            _Args.push(&arg4);
                            _Args.push(&arg5);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                String,
                                String,
                                bool,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_material_market_ta1<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_material_market_ta1: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_material_market_ta1
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: String, arg3: bool| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                bool,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_warehouse<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Warehouse, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_warehouse: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_warehouse
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName) -> std::result::Result<Warehouse, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_limit_product_production<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let limit_product_production: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            limit_product_production
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: String, arg3: f64| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                f64,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_make_product<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, CityName, String, f64, f64) -> std::result::Result<(), JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let make_product: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            make_product
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: String, arg3: f64, arg4: f64| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let arg4 = JsValue::from(arg4);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            _Args.push(&arg4);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                f64,
                                f64,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_product<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String) -> std::result::Result<Product, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_product: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_product
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName, arg2: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                            )
                                -> std::result::Result<Product, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_upgrade_warehouse<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let upgrade_warehouse: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            upgrade_warehouse
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_material_market_ta2<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, bool) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_material_market_ta2: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_material_market_ta2
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: String, arg3: bool| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                bool,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_export_material<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                    WarehouseApiExportMaterialParamsAmt,
                ) -> std::result::Result<(), JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let export_material: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            export_material
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String,
                              arg1: CityName,
                              arg2: String,
                              arg3: CityName,
                              arg4: String,
                              arg5: WarehouseApiExportMaterialParamsAmt| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = ts_bindgen_rt::to_jsvalue(&arg3);
                            let arg4 = JsValue::from(arg4);
                            let arg5 = ts_bindgen_rt::to_jsvalue(&arg5);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            _Args.push(&arg4);
                            _Args.push(&arg5);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                CityName,
                                String,
                                WarehouseApiExportMaterialParamsAmt,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_product_market_ta1<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_product_market_ta1: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_product_market_ta1
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String, arg2: bool| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_bulk_purchase<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let bulk_purchase: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            bulk_purchase
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: String, arg3: f64| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                f64,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_buy_material<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String, f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let buy_material: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            buy_material
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: String, arg3: f64| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                f64,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_cancel_export_material<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    CityName,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let cancel_export_material: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            cancel_export_material
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String,
                              arg1: CityName,
                              arg2: String,
                              arg3: CityName,
                              arg4: String| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = ts_bindgen_rt::to_jsvalue(&arg3);
                            let arg4 = JsValue::from(arg4);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            _Args.push(&arg4);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                CityName,
                                String,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_smart_supply<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, bool) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_smart_supply: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_smart_supply
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName, arg2: bool| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName, bool) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_upgrade_warehouse_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_upgrade_warehouse_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_upgrade_warehouse_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_discontinue_product<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let discontinue_product: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            discontinue_product
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_product_market_ta2<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_product_market_ta2: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_product_market_ta2
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String, arg2: bool| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, String, bool) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_has_warehouse<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let has_warehouse: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            has_warehouse
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_material<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, String) -> std::result::Result<Material, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_material: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_material
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName, arg2: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                            )
                                -> std::result::Result<Material, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_purchase_warehouse<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let purchase_warehouse: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            purchase_warehouse
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_sell_material<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    String,
                    String,
                    String,
                ) -> std::result::Result<(), JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let sell_material: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            sell_material
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String,
                              arg1: CityName,
                              arg2: String,
                              arg3: String,
                              arg4: String| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let arg4 = JsValue::from(arg4);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            _Args.push(&arg4);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                String,
                                String,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct SleevePerson {
        #[serde(rename = "shock")]
        pub shock: f64,
        #[serde(rename = "hp")]
        pub hp: Hp,
        #[serde(rename = "storedCycles")]
        pub stored_cycles: f64,
        #[serde(rename = "city")]
        pub city: CityName,
        #[serde(rename = "sync")]
        pub sync: f64,
        #[serde(rename = "skills")]
        pub skills: Skills,
        #[serde(rename = "memory")]
        pub memory: f64,
        #[serde(rename = "exp")]
        pub exp: Skills,
        #[serde(rename = "mults")]
        pub mults: Multipliers,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait SleevePerson_Trait: Person_Trait {
        fn set_memory(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn memory(&self) -> std::result::Result<f64, JsValue>;
        fn set_sync(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn sync(&self) -> std::result::Result<f64, JsValue>;
        fn set_stored_cycles(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn stored_cycles(&self) -> std::result::Result<f64, JsValue>;
        fn set_shock(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn shock(&self) -> std::result::Result<f64, JsValue>;
    }
    impl Person_Trait for SleevePerson {
        fn set_hp(&mut self, value: Hp) -> std::result::Result<(), JsValue> {
            self.hp = value;
            Ok(())
        }
        fn hp(&self) -> std::result::Result<Hp, JsValue> {
            Ok(self.hp.clone())
        }
        fn set_exp(&mut self, value: Skills) -> std::result::Result<(), JsValue> {
            self.exp = value;
            Ok(())
        }
        fn exp(&self) -> std::result::Result<Skills, JsValue> {
            Ok(self.exp.clone())
        }
        fn set_skills(&mut self, value: Skills) -> std::result::Result<(), JsValue> {
            self.skills = value;
            Ok(())
        }
        fn skills(&self) -> std::result::Result<Skills, JsValue> {
            Ok(self.skills.clone())
        }
        fn set_mults(&mut self, value: Multipliers) -> std::result::Result<(), JsValue> {
            self.mults = value;
            Ok(())
        }
        fn mults(&self) -> std::result::Result<Multipliers, JsValue> {
            Ok(self.mults.clone())
        }
        fn set_city(&mut self, value: CityName) -> std::result::Result<(), JsValue> {
            self.city = value;
            Ok(())
        }
        fn city(&self) -> std::result::Result<CityName, JsValue> {
            Ok(self.city.clone())
        }
    }
    impl SleevePerson_Trait for SleevePerson
    where
        SleevePerson: Person_Trait,
    {
        fn set_memory(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.memory = value;
            Ok(())
        }
        fn memory(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.memory)
        }
        fn set_sync(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.sync = value;
            Ok(())
        }
        fn sync(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.sync)
        }
        fn set_stored_cycles(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.stored_cycles = value;
            Ok(())
        }
        fn stored_cycles(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.stored_cycles)
        }
        fn set_shock(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.shock = value;
            Ok(())
        }
        fn shock(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.shock)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct SleeveRecoveryTaskAliased {
        #[serde(rename = "type")]
        pub type_: String,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait SleeveRecoveryTaskAliased_Trait {
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn type_(&self) -> std::result::Result<String, JsValue>;
    }
    impl SleeveRecoveryTaskAliased_Trait for SleeveRecoveryTaskAliased {
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.type_ = value;
            Ok(())
        }
        fn type_(&self) -> std::result::Result<String, JsValue> {
            Ok(self.type_.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsGetRunningScriptParamsArgs {
        Bool(bool),
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum WarehouseApiExportMaterialParamsAmt {
        String(String),
        F64(f64),
    }
    #[wasm_bindgen]
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum PositionTypes {
        Long = "L",
        Short = "S",
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Hacknet {
        #[serde(
            rename = "hashCost",
            serialize_with = "Hacknet::__TSB__serialize_hash_cost",
            deserialize_with = "Hacknet::__TSB__deserialize_hash_cost"
        )]
        pub hash_cost: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "numHashes",
            serialize_with = "Hacknet::__TSB__serialize_num_hashes",
            deserialize_with = "Hacknet::__TSB__deserialize_num_hashes"
        )]
        pub num_hashes: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "maxNumNodes",
            serialize_with = "Hacknet::__TSB__serialize_max_num_nodes",
            deserialize_with = "Hacknet::__TSB__deserialize_max_num_nodes"
        )]
        pub max_num_nodes: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getRamUpgradeCost",
            serialize_with = "Hacknet::__TSB__serialize_get_ram_upgrade_cost",
            deserialize_with = "Hacknet::__TSB__deserialize_get_ram_upgrade_cost"
        )]
        pub get_ram_upgrade_cost:
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "upgradeCache",
            serialize_with = "Hacknet::__TSB__serialize_upgrade_cache",
            deserialize_with = "Hacknet::__TSB__deserialize_upgrade_cache"
        )]
        pub upgrade_cache: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getHashUpgrades",
            serialize_with = "Hacknet::__TSB__serialize_get_hash_upgrades",
            deserialize_with = "Hacknet::__TSB__deserialize_get_hash_upgrades"
        )]
        pub get_hash_upgrades: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "hashCapacity",
            serialize_with = "Hacknet::__TSB__serialize_hash_capacity",
            deserialize_with = "Hacknet::__TSB__deserialize_hash_capacity"
        )]
        pub hash_capacity: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getStudyMult",
            serialize_with = "Hacknet::__TSB__serialize_get_study_mult",
            deserialize_with = "Hacknet::__TSB__deserialize_get_study_mult"
        )]
        pub get_study_mult: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "upgradeCore",
            serialize_with = "Hacknet::__TSB__serialize_upgrade_core",
            deserialize_with = "Hacknet::__TSB__deserialize_upgrade_core"
        )]
        pub upgrade_core: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getHashUpgradeLevel",
            serialize_with = "Hacknet::__TSB__serialize_get_hash_upgrade_level",
            deserialize_with = "Hacknet::__TSB__deserialize_get_hash_upgrade_level"
        )]
        pub get_hash_upgrade_level:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getPurchaseNodeCost",
            serialize_with = "Hacknet::__TSB__serialize_get_purchase_node_cost",
            deserialize_with = "Hacknet::__TSB__deserialize_get_purchase_node_cost"
        )]
        pub get_purchase_node_cost: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getCacheUpgradeCost",
            serialize_with = "Hacknet::__TSB__serialize_get_cache_upgrade_cost",
            deserialize_with = "Hacknet::__TSB__deserialize_get_cache_upgrade_cost"
        )]
        pub get_cache_upgrade_cost:
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getLevelUpgradeCost",
            serialize_with = "Hacknet::__TSB__serialize_get_level_upgrade_cost",
            deserialize_with = "Hacknet::__TSB__deserialize_get_level_upgrade_cost"
        )]
        pub get_level_upgrade_cost:
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "upgradeLevel",
            serialize_with = "Hacknet::__TSB__serialize_upgrade_level",
            deserialize_with = "Hacknet::__TSB__deserialize_upgrade_level"
        )]
        pub upgrade_level: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "upgradeRam",
            serialize_with = "Hacknet::__TSB__serialize_upgrade_ram",
            deserialize_with = "Hacknet::__TSB__deserialize_upgrade_ram"
        )]
        pub upgrade_ram: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "purchaseNode",
            serialize_with = "Hacknet::__TSB__serialize_purchase_node",
            deserialize_with = "Hacknet::__TSB__deserialize_purchase_node"
        )]
        pub purchase_node: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getNodeStats",
            serialize_with = "Hacknet::__TSB__serialize_get_node_stats",
            deserialize_with = "Hacknet::__TSB__deserialize_get_node_stats"
        )]
        pub get_node_stats: std::rc::Rc<dyn Fn(f64) -> std::result::Result<NodeStats, JsValue>>,
        #[serde(
            rename = "spendHashes",
            serialize_with = "Hacknet::__TSB__serialize_spend_hashes",
            deserialize_with = "Hacknet::__TSB__deserialize_spend_hashes"
        )]
        pub spend_hashes:
            std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getTrainingMult",
            serialize_with = "Hacknet::__TSB__serialize_get_training_mult",
            deserialize_with = "Hacknet::__TSB__deserialize_get_training_mult"
        )]
        pub get_training_mult: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getCoreUpgradeCost",
            serialize_with = "Hacknet::__TSB__serialize_get_core_upgrade_cost",
            deserialize_with = "Hacknet::__TSB__deserialize_get_core_upgrade_cost"
        )]
        pub get_core_upgrade_cost:
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "numNodes",
            serialize_with = "Hacknet::__TSB__serialize_num_nodes",
            deserialize_with = "Hacknet::__TSB__deserialize_num_nodes"
        )]
        pub num_nodes: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait Hacknet_Trait {
        fn set_upgrade_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn upgrade_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_node_stats(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<NodeStats, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_node_stats(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<NodeStats, JsValue>>,
            JsValue,
        >;
        fn set_get_study_mult(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_study_mult(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_get_ram_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_ram_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_hash_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn hash_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_num_hashes(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn num_hashes(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_upgrade_core(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn upgrade_core(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_purchase_node(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn purchase_node(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_get_cache_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_cache_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_level_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_level_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_hash_upgrade_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_hash_upgrade_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_upgrade_cache(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn upgrade_cache(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_hash_upgrades(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_hash_upgrades(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_get_core_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_core_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_hash_capacity(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn hash_capacity(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_get_training_mult(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_training_mult(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_max_num_nodes(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn max_num_nodes(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_upgrade_ram(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn upgrade_ram(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_num_nodes(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn num_nodes(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_get_purchase_node_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_purchase_node_cost(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_spend_hashes(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn spend_hashes(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
    }
    impl Hacknet_Trait for Hacknet {
        fn set_upgrade_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.upgrade_level = value;
            Ok(())
        }
        fn upgrade_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.upgrade_level.clone())
        }
        fn set_get_node_stats(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<NodeStats, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_node_stats = value;
            Ok(())
        }
        fn get_node_stats(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<NodeStats, JsValue>>,
            JsValue,
        > {
            Ok(self.get_node_stats.clone())
        }
        fn set_get_study_mult(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_study_mult = value;
            Ok(())
        }
        fn get_study_mult(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_study_mult.clone())
        }
        fn set_get_ram_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_ram_upgrade_cost = value;
            Ok(())
        }
        fn get_ram_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_ram_upgrade_cost.clone())
        }
        fn set_hash_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.hash_cost = value;
            Ok(())
        }
        fn hash_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.hash_cost.clone())
        }
        fn set_num_hashes(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.num_hashes = value;
            Ok(())
        }
        fn num_hashes(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.num_hashes.clone())
        }
        fn set_upgrade_core(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.upgrade_core = value;
            Ok(())
        }
        fn upgrade_core(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.upgrade_core.clone())
        }
        fn set_purchase_node(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.purchase_node = value;
            Ok(())
        }
        fn purchase_node(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.purchase_node.clone())
        }
        fn set_get_cache_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_cache_upgrade_cost = value;
            Ok(())
        }
        fn get_cache_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_cache_upgrade_cost.clone())
        }
        fn set_get_level_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_level_upgrade_cost = value;
            Ok(())
        }
        fn get_level_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_level_upgrade_cost.clone())
        }
        fn set_get_hash_upgrade_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_hash_upgrade_level = value;
            Ok(())
        }
        fn get_hash_upgrade_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_hash_upgrade_level.clone())
        }
        fn set_upgrade_cache(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.upgrade_cache = value;
            Ok(())
        }
        fn upgrade_cache(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.upgrade_cache.clone())
        }
        fn set_get_hash_upgrades(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_hash_upgrades = value;
            Ok(())
        }
        fn get_hash_upgrades(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_hash_upgrades.clone())
        }
        fn set_get_core_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_core_upgrade_cost = value;
            Ok(())
        }
        fn get_core_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_core_upgrade_cost.clone())
        }
        fn set_hash_capacity(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.hash_capacity = value;
            Ok(())
        }
        fn hash_capacity(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.hash_capacity.clone())
        }
        fn set_get_training_mult(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_training_mult = value;
            Ok(())
        }
        fn get_training_mult(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_training_mult.clone())
        }
        fn set_max_num_nodes(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.max_num_nodes = value;
            Ok(())
        }
        fn max_num_nodes(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.max_num_nodes.clone())
        }
        fn set_upgrade_ram(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.upgrade_ram = value;
            Ok(())
        }
        fn upgrade_ram(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.upgrade_ram.clone())
        }
        fn set_num_nodes(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.num_nodes = value;
            Ok(())
        }
        fn num_nodes(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.num_nodes.clone())
        }
        fn set_get_purchase_node_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_purchase_node_cost = value;
            Ok(())
        }
        fn get_purchase_node_cost(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_purchase_node_cost.clone())
        }
        fn set_spend_hashes(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.spend_hashes = value;
            Ok(())
        }
        fn spend_hashes(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.spend_hashes.clone())
        }
    }
    impl Hacknet {
        #[allow(non_snake_case)]
        fn __TSB__serialize_hash_cost<S>(
            hash_cost: &std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hash_cost = hash_cost.clone();
            let hash_cost_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = hash_cost(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &hash_cost_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_num_hashes<S>(
            num_hashes: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let num_hashes = num_hashes.clone();
            let num_hashes_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = num_hashes()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &num_hashes_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_max_num_nodes<S>(
            max_num_nodes: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let max_num_nodes = max_num_nodes.clone();
            let max_num_nodes_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = max_num_nodes()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &max_num_nodes_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_ram_upgrade_cost<S>(
            get_ram_upgrade_cost: &std::rc::Rc<
                dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_ram_upgrade_cost = get_ram_upgrade_cost.clone();
            let get_ram_upgrade_cost_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = get_ram_upgrade_cost(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_ram_upgrade_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_upgrade_cache<S>(
            upgrade_cache: &std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let upgrade_cache = upgrade_cache.clone();
            let upgrade_cache_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<bool, JsValue> {
                    let result = upgrade_cache(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &upgrade_cache_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_hash_upgrades<S>(
            get_hash_upgrades: &std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_hash_upgrades = get_hash_upgrades.clone();
            let get_hash_upgrades_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_hash_upgrades()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_hash_upgrades_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_hash_capacity<S>(
            hash_capacity: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hash_capacity = hash_capacity.clone();
            let hash_capacity_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = hash_capacity()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &hash_capacity_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_study_mult<S>(
            get_study_mult: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_study_mult = get_study_mult.clone();
            let get_study_mult_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_study_mult()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_study_mult_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_upgrade_core<S>(
            upgrade_core: &std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let upgrade_core = upgrade_core.clone();
            let upgrade_core_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<bool, JsValue> {
                    let result = upgrade_core(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &upgrade_core_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_hash_upgrade_level<S>(
            get_hash_upgrade_level: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_hash_upgrade_level = get_hash_upgrade_level.clone();
            let get_hash_upgrade_level_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_hash_upgrade_level(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_hash_upgrade_level_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_purchase_node_cost<S>(
            get_purchase_node_cost: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_purchase_node_cost = get_purchase_node_cost.clone();
            let get_purchase_node_cost_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_purchase_node_cost()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_purchase_node_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_cache_upgrade_cost<S>(
            get_cache_upgrade_cost: &std::rc::Rc<
                dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_cache_upgrade_cost = get_cache_upgrade_cost.clone();
            let get_cache_upgrade_cost_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = get_cache_upgrade_cost(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_cache_upgrade_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_level_upgrade_cost<S>(
            get_level_upgrade_cost: &std::rc::Rc<
                dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_level_upgrade_cost = get_level_upgrade_cost.clone();
            let get_level_upgrade_cost_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = get_level_upgrade_cost(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_level_upgrade_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_upgrade_level<S>(
            upgrade_level: &std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let upgrade_level = upgrade_level.clone();
            let upgrade_level_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<bool, JsValue> {
                    let result = upgrade_level(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &upgrade_level_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_upgrade_ram<S>(
            upgrade_ram: &std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let upgrade_ram = upgrade_ram.clone();
            let upgrade_ram_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<bool, JsValue> {
                    let result = upgrade_ram(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &upgrade_ram_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_purchase_node<S>(
            purchase_node: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let purchase_node = purchase_node.clone();
            let purchase_node_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = purchase_node()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &purchase_node_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_node_stats<S>(
            get_node_stats: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<NodeStats, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_node_stats = get_node_stats.clone();
            let get_node_stats_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<JsValue, JsValue> {
                    let result = get_node_stats(arg0)?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_node_stats_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_spend_hashes<S>(
            spend_hashes: &std::rc::Rc<
                dyn Fn(String, String, f64) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let spend_hashes = spend_hashes.clone();
            let spend_hashes_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: String,
                      arg2: f64|
                      -> std::result::Result<bool, JsValue> {
                    let result = spend_hashes(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String, f64) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &spend_hashes_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_training_mult<S>(
            get_training_mult: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_training_mult = get_training_mult.clone();
            let get_training_mult_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_training_mult()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_training_mult_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_core_upgrade_cost<S>(
            get_core_upgrade_cost: &std::rc::Rc<
                dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_core_upgrade_cost = get_core_upgrade_cost.clone();
            let get_core_upgrade_cost_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = get_core_upgrade_cost(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_core_upgrade_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_num_nodes<S>(
            num_nodes: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let num_nodes = num_nodes.clone();
            let num_nodes_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = num_nodes()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &num_nodes_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hash_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hash_cost: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            hash_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_num_hashes<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let num_hashes: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            num_hashes
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_max_num_nodes<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let max_num_nodes: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            max_num_nodes
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_ram_upgrade_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_ram_upgrade_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_ram_upgrade_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_upgrade_cache<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let upgrade_cache: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            upgrade_cache
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_hash_upgrades<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_hash_upgrades: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_hash_upgrades
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hash_capacity<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hash_capacity: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            hash_capacity
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_study_mult<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_study_mult: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_study_mult
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_upgrade_core<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let upgrade_core: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            upgrade_core
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_hash_upgrade_level<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_hash_upgrade_level: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_hash_upgrade_level
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_purchase_node_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_purchase_node_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_purchase_node_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_cache_upgrade_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_cache_upgrade_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_cache_upgrade_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_level_upgrade_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_level_upgrade_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_level_upgrade_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_upgrade_level<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let upgrade_level: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            upgrade_level
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_upgrade_ram<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let upgrade_ram: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            upgrade_ram
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_purchase_node<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let purchase_node: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            purchase_node
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_node_stats<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<NodeStats, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_node_stats: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_node_stats
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<NodeStats, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_spend_hashes<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, f64) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let spend_hashes: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            spend_hashes
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, String, f64) -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_training_mult<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_training_mult: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_training_mult
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_core_upgrade_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_core_upgrade_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_core_upgrade_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_num_nodes<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let num_nodes: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            num_nodes
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct GangTaskStats {
        #[serde(rename = "strWeight")]
        pub str_weight: f64,
        #[serde(rename = "baseRespect")]
        pub base_respect: f64,
        #[serde(rename = "chaWeight")]
        pub cha_weight: f64,
        #[serde(rename = "baseWanted")]
        pub base_wanted: f64,
        #[serde(rename = "baseMoney")]
        pub base_money: f64,
        #[serde(rename = "desc")]
        pub desc: String,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "isCombat")]
        pub is_combat: bool,
        #[serde(rename = "defWeight")]
        pub def_weight: f64,
        #[serde(rename = "territory")]
        pub territory: GangTerritory,
        #[serde(rename = "dexWeight")]
        pub dex_weight: f64,
        #[serde(rename = "hackWeight")]
        pub hack_weight: f64,
        #[serde(rename = "agiWeight")]
        pub agi_weight: f64,
        #[serde(rename = "difficulty")]
        pub difficulty: f64,
        #[serde(rename = "isHacking")]
        pub is_hacking: bool,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait GangTaskStats_Trait {
        fn set_agi_weight(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn agi_weight(&self) -> std::result::Result<f64, JsValue>;
        fn set_is_combat(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn is_combat(&self) -> std::result::Result<bool, JsValue>;
        fn set_cha_weight(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cha_weight(&self) -> std::result::Result<f64, JsValue>;
        fn set_base_wanted(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn base_wanted(&self) -> std::result::Result<f64, JsValue>;
        fn set_difficulty(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn difficulty(&self) -> std::result::Result<f64, JsValue>;
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn name(&self) -> std::result::Result<String, JsValue>;
        fn set_base_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn base_money(&self) -> std::result::Result<f64, JsValue>;
        fn set_hack_weight(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hack_weight(&self) -> std::result::Result<f64, JsValue>;
        fn set_str_weight(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn str_weight(&self) -> std::result::Result<f64, JsValue>;
        fn set_base_respect(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn base_respect(&self) -> std::result::Result<f64, JsValue>;
        fn set_def_weight(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn def_weight(&self) -> std::result::Result<f64, JsValue>;
        fn set_desc(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn desc(&self) -> std::result::Result<String, JsValue>;
        fn set_dex_weight(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn dex_weight(&self) -> std::result::Result<f64, JsValue>;
        fn set_is_hacking(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn is_hacking(&self) -> std::result::Result<bool, JsValue>;
        fn set_territory(&mut self, value: GangTerritory) -> std::result::Result<(), JsValue>;
        fn territory(&self) -> std::result::Result<GangTerritory, JsValue>;
    }
    impl GangTaskStats_Trait for GangTaskStats {
        fn set_agi_weight(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.agi_weight = value;
            Ok(())
        }
        fn agi_weight(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.agi_weight)
        }
        fn set_is_combat(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.is_combat = value;
            Ok(())
        }
        fn is_combat(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.is_combat)
        }
        fn set_cha_weight(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cha_weight = value;
            Ok(())
        }
        fn cha_weight(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cha_weight)
        }
        fn set_base_wanted(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.base_wanted = value;
            Ok(())
        }
        fn base_wanted(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.base_wanted)
        }
        fn set_difficulty(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.difficulty = value;
            Ok(())
        }
        fn difficulty(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.difficulty)
        }
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.name = value;
            Ok(())
        }
        fn name(&self) -> std::result::Result<String, JsValue> {
            Ok(self.name.clone())
        }
        fn set_base_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.base_money = value;
            Ok(())
        }
        fn base_money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.base_money)
        }
        fn set_hack_weight(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hack_weight = value;
            Ok(())
        }
        fn hack_weight(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hack_weight)
        }
        fn set_str_weight(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.str_weight = value;
            Ok(())
        }
        fn str_weight(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.str_weight)
        }
        fn set_base_respect(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.base_respect = value;
            Ok(())
        }
        fn base_respect(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.base_respect)
        }
        fn set_def_weight(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.def_weight = value;
            Ok(())
        }
        fn def_weight(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.def_weight)
        }
        fn set_desc(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.desc = value;
            Ok(())
        }
        fn desc(&self) -> std::result::Result<String, JsValue> {
            Ok(self.desc.clone())
        }
        fn set_dex_weight(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.dex_weight = value;
            Ok(())
        }
        fn dex_weight(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.dex_weight)
        }
        fn set_is_hacking(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.is_hacking = value;
            Ok(())
        }
        fn is_hacking(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.is_hacking)
        }
        fn set_territory(&mut self, value: GangTerritory) -> std::result::Result<(), JsValue> {
            self.territory = value;
            Ok(())
        }
        fn territory(&self) -> std::result::Result<GangTerritory, JsValue> {
            Ok(self.territory.clone())
        }
    }
    #[wasm_bindgen]
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum FactionWorkType {
        Hacking = "hacking",
        Field = "field",
        Security = "security",
    }
    #[allow(dead_code, non_camel_case_types)]
    type CorpIndustryName = CorpIndustryNameAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Infiltration {
        #[serde(
            rename = "getInfiltration",
            serialize_with = "Infiltration::__TSB__serialize_get_infiltration",
            deserialize_with = "Infiltration::__TSB__deserialize_get_infiltration"
        )]
        pub get_infiltration:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<InfiltrationLocation, JsValue>>,
        #[serde(
            rename = "getPossibleLocations",
            serialize_with = "Infiltration::__TSB__serialize_get_possible_locations",
            deserialize_with = "Infiltration::__TSB__deserialize_get_possible_locations"
        )]
        pub get_possible_locations:
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<ILocation>, JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait Infiltration_Trait {
        fn set_get_infiltration(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String) -> std::result::Result<InfiltrationLocation, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_infiltration(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<InfiltrationLocation, JsValue>>,
            JsValue,
        >;
        fn set_get_possible_locations(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<ILocation>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_possible_locations(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<ILocation>, JsValue>>,
            JsValue,
        >;
    }
    impl Infiltration_Trait for Infiltration {
        fn set_get_infiltration(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String) -> std::result::Result<InfiltrationLocation, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_infiltration = value;
            Ok(())
        }
        fn get_infiltration(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<InfiltrationLocation, JsValue>>,
            JsValue,
        > {
            Ok(self.get_infiltration.clone())
        }
        fn set_get_possible_locations(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<ILocation>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_possible_locations = value;
            Ok(())
        }
        fn get_possible_locations(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<ILocation>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_possible_locations.clone())
        }
    }
    impl Infiltration {
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_infiltration<S>(
            get_infiltration: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<InfiltrationLocation, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_infiltration = get_infiltration.clone();
            let get_infiltration_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<JsValue, JsValue> {
                    let result = get_infiltration(arg0)?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_infiltration_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_possible_locations<S>(
            get_possible_locations: &std::rc::Rc<
                dyn Fn() -> std::result::Result<Vec<ILocation>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_possible_locations = get_possible_locations.clone();
            let get_possible_locations_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_possible_locations()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(
                                &ts_bindgen_rt::to_jsvalue(&result_item)
                                    .map_err(ts_bindgen_rt::Error::from)?,
                            );
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_possible_locations_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_infiltration<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<InfiltrationLocation, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_infiltration: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_infiltration
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String) -> std::result::Result<InfiltrationLocation, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_possible_locations<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<ILocation>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_possible_locations: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_possible_locations
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<ILocation>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum SleeveBladeburnerTaskAliasedActionType {
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct SleeveFactionTaskAliased {
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "factionName")]
        pub faction_name: String,
        #[serde(rename = "factionWorkType")]
        pub faction_work_type: FactionWorkType,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait SleeveFactionTaskAliased_Trait {
        fn set_faction_work_type(
            &mut self,
            value: FactionWorkType,
        ) -> std::result::Result<(), JsValue>;
        fn faction_work_type(&self) -> std::result::Result<FactionWorkType, JsValue>;
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn type_(&self) -> std::result::Result<String, JsValue>;
        fn set_faction_name(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn faction_name(&self) -> std::result::Result<String, JsValue>;
    }
    impl SleeveFactionTaskAliased_Trait for SleeveFactionTaskAliased {
        fn set_faction_work_type(
            &mut self,
            value: FactionWorkType,
        ) -> std::result::Result<(), JsValue> {
            self.faction_work_type = value;
            Ok(())
        }
        fn faction_work_type(&self) -> std::result::Result<FactionWorkType, JsValue> {
            Ok(self.faction_work_type.clone())
        }
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.type_ = value;
            Ok(())
        }
        fn type_(&self) -> std::result::Result<String, JsValue> {
            Ok(self.type_.clone())
        }
        fn set_faction_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.faction_name = value;
            Ok(())
        }
        fn faction_name(&self) -> std::result::Result<String, JsValue> {
            Ok(self.faction_name.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct GangTerritory {
        #[serde(rename = "money")]
        pub money: f64,
        #[serde(rename = "wanted")]
        pub wanted: f64,
        #[serde(rename = "respect")]
        pub respect: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait GangTerritory_Trait {
        fn set_wanted(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn wanted(&self) -> std::result::Result<f64, JsValue>;
        fn set_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn money(&self) -> std::result::Result<f64, JsValue>;
        fn set_respect(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn respect(&self) -> std::result::Result<f64, JsValue>;
    }
    impl GangTerritory_Trait for GangTerritory {
        fn set_wanted(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.wanted = value;
            Ok(())
        }
        fn wanted(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.wanted)
        }
        fn set_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.money = value;
            Ok(())
        }
        fn money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.money)
        }
        fn set_respect(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.respect = value;
            Ok(())
        }
        fn respect(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.respect)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct CorpProductDataRatingWeights {
        #[serde(rename = "performance")]
        pub performance: Option<f64>,
        #[serde(rename = "durability")]
        pub durability: Option<f64>,
        #[serde(rename = "reliability")]
        pub reliability: Option<f64>,
        #[serde(rename = "quality")]
        pub quality: Option<f64>,
        #[serde(rename = "aesthetics")]
        pub aesthetics: Option<f64>,
        #[serde(rename = "features")]
        pub features: Option<f64>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait CorpProductDataRatingWeights_Trait {
        fn set_quality(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn quality(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_durability(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn durability(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_aesthetics(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn aesthetics(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_performance(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn performance(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_reliability(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn reliability(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_features(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn features(&self) -> std::result::Result<Option<f64>, JsValue>;
    }
    impl CorpProductDataRatingWeights_Trait for CorpProductDataRatingWeights {
        fn set_quality(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.quality = value;
            Ok(())
        }
        fn quality(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.quality.clone())
        }
        fn set_durability(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.durability = value;
            Ok(())
        }
        fn durability(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.durability.clone())
        }
        fn set_aesthetics(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.aesthetics = value;
            Ok(())
        }
        fn aesthetics(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.aesthetics.clone())
        }
        fn set_performance(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.performance = value;
            Ok(())
        }
        fn performance(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.performance.clone())
        }
        fn set_reliability(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.reliability = value;
            Ok(())
        }
        fn reliability(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.reliability.clone())
        }
        fn set_features(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.features = value;
            Ok(())
        }
        fn features(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.features.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Grafting {
        #[serde(
            rename = "getAugmentationGraftTime",
            serialize_with = "Grafting::__TSB__serialize_get_augmentation_graft_time",
            deserialize_with = "Grafting::__TSB__deserialize_get_augmentation_graft_time"
        )]
        pub get_augmentation_graft_time:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "graftAugmentation",
            serialize_with = "Grafting::__TSB__serialize_graft_augmentation",
            deserialize_with = "Grafting::__TSB__deserialize_graft_augmentation"
        )]
        pub graft_augmentation:
            std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getGraftableAugmentations",
            serialize_with = "Grafting::__TSB__serialize_get_graftable_augmentations",
            deserialize_with = "Grafting::__TSB__deserialize_get_graftable_augmentations"
        )]
        pub get_graftable_augmentations:
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "getAugmentationGraftPrice",
            serialize_with = "Grafting::__TSB__serialize_get_augmentation_graft_price",
            deserialize_with = "Grafting::__TSB__deserialize_get_augmentation_graft_price"
        )]
        pub get_augmentation_graft_price:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait Grafting_Trait {
        fn set_get_augmentation_graft_time(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_augmentation_graft_time(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_graftable_augmentations(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_graftable_augmentations(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_graft_augmentation(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn graft_augmentation(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_augmentation_graft_price(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_augmentation_graft_price(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
    }
    impl Grafting_Trait for Grafting {
        fn set_get_augmentation_graft_time(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_augmentation_graft_time = value;
            Ok(())
        }
        fn get_augmentation_graft_time(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_augmentation_graft_time.clone())
        }
        fn set_get_graftable_augmentations(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_graftable_augmentations = value;
            Ok(())
        }
        fn get_graftable_augmentations(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_graftable_augmentations.clone())
        }
        fn set_graft_augmentation(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.graft_augmentation = value;
            Ok(())
        }
        fn graft_augmentation(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.graft_augmentation.clone())
        }
        fn set_get_augmentation_graft_price(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_augmentation_graft_price = value;
            Ok(())
        }
        fn get_augmentation_graft_price(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_augmentation_graft_price.clone())
        }
    }
    impl Grafting {
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_augmentation_graft_time<S>(
            get_augmentation_graft_time: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_augmentation_graft_time = get_augmentation_graft_time.clone();
            let get_augmentation_graft_time_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_augmentation_graft_time(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_augmentation_graft_time_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_graft_augmentation<S>(
            graft_augmentation: &std::rc::Rc<
                dyn Fn(String, bool) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let graft_augmentation = graft_augmentation.clone();
            let graft_augmentation_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: bool| -> std::result::Result<bool, JsValue> {
                    let result = graft_augmentation(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &graft_augmentation_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_graftable_augmentations<S>(
            get_graftable_augmentations: &std::rc::Rc<
                dyn Fn() -> std::result::Result<Vec<String>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_graftable_augmentations = get_graftable_augmentations.clone();
            let get_graftable_augmentations_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_graftable_augmentations()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_graftable_augmentations_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_augmentation_graft_price<S>(
            get_augmentation_graft_price: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_augmentation_graft_price = get_augmentation_graft_price.clone();
            let get_augmentation_graft_price_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_augmentation_graft_price(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_augmentation_graft_price_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_augmentation_graft_time<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_augmentation_graft_time: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_augmentation_graft_time
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_graft_augmentation<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let graft_augmentation: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            graft_augmentation
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: bool| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_graftable_augmentations<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_graftable_augmentations: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_graftable_augmentations
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_augmentation_graft_price<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_augmentation_graft_price: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_augmentation_graft_price
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[allow(dead_code, non_camel_case_types)]
    type CorpUpgradeName = CorpUpgradeNameAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsRunParamsArgs {
        Bool(bool),
        F64(f64),
        String(String),
    }
    #[allow(dead_code, non_camel_case_types)]
    type FilenameOrPid = FilenameOrPidAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct UserInterfaceTheme {
        #[serde(rename = "success")]
        pub success: String,
        #[serde(rename = "successlight")]
        pub successlight: String,
        #[serde(rename = "backgroundsecondary")]
        pub backgroundsecondary: String,
        #[serde(rename = "infodark")]
        pub infodark: String,
        #[serde(rename = "cha")]
        pub cha: String,
        #[serde(rename = "secondarydark")]
        pub secondarydark: String,
        #[serde(rename = "errorlight")]
        pub errorlight: String,
        #[serde(rename = "well")]
        pub well: String,
        #[serde(rename = "warning")]
        pub warning: String,
        #[serde(rename = "int")]
        pub int: String,
        #[serde(rename = "hp")]
        pub hp: String,
        #[serde(rename = "warningdark")]
        pub warningdark: String,
        #[serde(rename = "info")]
        pub info: String,
        #[serde(rename = "successdark")]
        pub successdark: String,
        #[serde(rename = "primary")]
        pub primary: String,
        #[serde(rename = "secondarylight")]
        pub secondarylight: String,
        #[serde(rename = "money")]
        pub money: String,
        #[serde(rename = "primarylight")]
        pub primarylight: String,
        #[serde(rename = "secondary")]
        pub secondary: String,
        #[serde(rename = "rep")]
        pub rep: String,
        #[serde(rename = "combat")]
        pub combat: String,
        #[serde(rename = "disabled")]
        pub disabled: String,
        #[serde(rename = "warninglight")]
        pub warninglight: String,
        #[serde(rename = "errordark")]
        pub errordark: String,
        #[serde(rename = "button")]
        pub button: String,
        #[serde(rename = "backgroundprimary")]
        pub backgroundprimary: String,
        #[serde(rename = "infolight")]
        pub infolight: String,
        #[serde(rename = "black")]
        pub black: String,
        #[serde(rename = "hack")]
        pub hack: String,
        #[serde(rename = "error")]
        pub error: String,
        #[serde(rename = "primarydark")]
        pub primarydark: String,
        #[serde(rename = "white")]
        pub white: String,
        #[serde(rename = "welllight")]
        pub welllight: String,
        #[serde(flatten)]
        pub extra_fields: std::collections::HashMap<String, UserInterfaceThemeIndexer>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait UserInterfaceTheme_Trait {
        fn set_warninglight(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn warninglight(&self) -> std::result::Result<String, JsValue>;
        fn set_error(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn error(&self) -> std::result::Result<String, JsValue>;
        fn set_info(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn info(&self) -> std::result::Result<String, JsValue>;
        fn set_errordark(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn errordark(&self) -> std::result::Result<String, JsValue>;
        fn set_secondary(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn secondary(&self) -> std::result::Result<String, JsValue>;
        fn set_int(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn int(&self) -> std::result::Result<String, JsValue>;
        fn set_rep(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn rep(&self) -> std::result::Result<String, JsValue>;
        fn set_secondarylight(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn secondarylight(&self) -> std::result::Result<String, JsValue>;
        fn set_errorlight(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn errorlight(&self) -> std::result::Result<String, JsValue>;
        fn set_combat(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn combat(&self) -> std::result::Result<String, JsValue>;
        fn set_white(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn white(&self) -> std::result::Result<String, JsValue>;
        fn set_primarydark(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn primarydark(&self) -> std::result::Result<String, JsValue>;
        fn set_infodark(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn infodark(&self) -> std::result::Result<String, JsValue>;
        fn set_well(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn well(&self) -> std::result::Result<String, JsValue>;
        fn set_successdark(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn successdark(&self) -> std::result::Result<String, JsValue>;
        fn set_cha(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn cha(&self) -> std::result::Result<String, JsValue>;
        fn set_button(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn button(&self) -> std::result::Result<String, JsValue>;
        fn set_success(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn success(&self) -> std::result::Result<String, JsValue>;
        fn set_hp(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn hp(&self) -> std::result::Result<String, JsValue>;
        fn set_primary(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn primary(&self) -> std::result::Result<String, JsValue>;
        fn set_black(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn black(&self) -> std::result::Result<String, JsValue>;
        fn set_successlight(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn successlight(&self) -> std::result::Result<String, JsValue>;
        fn set_warningdark(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn warningdark(&self) -> std::result::Result<String, JsValue>;
        fn set_hack(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn hack(&self) -> std::result::Result<String, JsValue>;
        fn set_backgroundsecondary(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn backgroundsecondary(&self) -> std::result::Result<String, JsValue>;
        fn set_backgroundprimary(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn backgroundprimary(&self) -> std::result::Result<String, JsValue>;
        fn set_money(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn money(&self) -> std::result::Result<String, JsValue>;
        fn set_disabled(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn disabled(&self) -> std::result::Result<String, JsValue>;
        fn set_welllight(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn welllight(&self) -> std::result::Result<String, JsValue>;
        fn set_infolight(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn infolight(&self) -> std::result::Result<String, JsValue>;
        fn set_primarylight(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn primarylight(&self) -> std::result::Result<String, JsValue>;
        fn set_secondarydark(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn secondarydark(&self) -> std::result::Result<String, JsValue>;
        fn set_warning(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn warning(&self) -> std::result::Result<String, JsValue>;
    }
    impl UserInterfaceTheme_Trait for UserInterfaceTheme {
        fn set_warninglight(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.warninglight = value;
            Ok(())
        }
        fn warninglight(&self) -> std::result::Result<String, JsValue> {
            Ok(self.warninglight.clone())
        }
        fn set_error(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.error = value;
            Ok(())
        }
        fn error(&self) -> std::result::Result<String, JsValue> {
            Ok(self.error.clone())
        }
        fn set_info(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.info = value;
            Ok(())
        }
        fn info(&self) -> std::result::Result<String, JsValue> {
            Ok(self.info.clone())
        }
        fn set_errordark(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.errordark = value;
            Ok(())
        }
        fn errordark(&self) -> std::result::Result<String, JsValue> {
            Ok(self.errordark.clone())
        }
        fn set_secondary(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.secondary = value;
            Ok(())
        }
        fn secondary(&self) -> std::result::Result<String, JsValue> {
            Ok(self.secondary.clone())
        }
        fn set_int(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.int = value;
            Ok(())
        }
        fn int(&self) -> std::result::Result<String, JsValue> {
            Ok(self.int.clone())
        }
        fn set_rep(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.rep = value;
            Ok(())
        }
        fn rep(&self) -> std::result::Result<String, JsValue> {
            Ok(self.rep.clone())
        }
        fn set_secondarylight(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.secondarylight = value;
            Ok(())
        }
        fn secondarylight(&self) -> std::result::Result<String, JsValue> {
            Ok(self.secondarylight.clone())
        }
        fn set_errorlight(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.errorlight = value;
            Ok(())
        }
        fn errorlight(&self) -> std::result::Result<String, JsValue> {
            Ok(self.errorlight.clone())
        }
        fn set_combat(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.combat = value;
            Ok(())
        }
        fn combat(&self) -> std::result::Result<String, JsValue> {
            Ok(self.combat.clone())
        }
        fn set_white(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.white = value;
            Ok(())
        }
        fn white(&self) -> std::result::Result<String, JsValue> {
            Ok(self.white.clone())
        }
        fn set_primarydark(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.primarydark = value;
            Ok(())
        }
        fn primarydark(&self) -> std::result::Result<String, JsValue> {
            Ok(self.primarydark.clone())
        }
        fn set_infodark(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.infodark = value;
            Ok(())
        }
        fn infodark(&self) -> std::result::Result<String, JsValue> {
            Ok(self.infodark.clone())
        }
        fn set_well(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.well = value;
            Ok(())
        }
        fn well(&self) -> std::result::Result<String, JsValue> {
            Ok(self.well.clone())
        }
        fn set_successdark(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.successdark = value;
            Ok(())
        }
        fn successdark(&self) -> std::result::Result<String, JsValue> {
            Ok(self.successdark.clone())
        }
        fn set_cha(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.cha = value;
            Ok(())
        }
        fn cha(&self) -> std::result::Result<String, JsValue> {
            Ok(self.cha.clone())
        }
        fn set_button(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.button = value;
            Ok(())
        }
        fn button(&self) -> std::result::Result<String, JsValue> {
            Ok(self.button.clone())
        }
        fn set_success(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.success = value;
            Ok(())
        }
        fn success(&self) -> std::result::Result<String, JsValue> {
            Ok(self.success.clone())
        }
        fn set_hp(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.hp = value;
            Ok(())
        }
        fn hp(&self) -> std::result::Result<String, JsValue> {
            Ok(self.hp.clone())
        }
        fn set_primary(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.primary = value;
            Ok(())
        }
        fn primary(&self) -> std::result::Result<String, JsValue> {
            Ok(self.primary.clone())
        }
        fn set_black(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.black = value;
            Ok(())
        }
        fn black(&self) -> std::result::Result<String, JsValue> {
            Ok(self.black.clone())
        }
        fn set_successlight(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.successlight = value;
            Ok(())
        }
        fn successlight(&self) -> std::result::Result<String, JsValue> {
            Ok(self.successlight.clone())
        }
        fn set_warningdark(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.warningdark = value;
            Ok(())
        }
        fn warningdark(&self) -> std::result::Result<String, JsValue> {
            Ok(self.warningdark.clone())
        }
        fn set_hack(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.hack = value;
            Ok(())
        }
        fn hack(&self) -> std::result::Result<String, JsValue> {
            Ok(self.hack.clone())
        }
        fn set_backgroundsecondary(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.backgroundsecondary = value;
            Ok(())
        }
        fn backgroundsecondary(&self) -> std::result::Result<String, JsValue> {
            Ok(self.backgroundsecondary.clone())
        }
        fn set_backgroundprimary(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.backgroundprimary = value;
            Ok(())
        }
        fn backgroundprimary(&self) -> std::result::Result<String, JsValue> {
            Ok(self.backgroundprimary.clone())
        }
        fn set_money(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.money = value;
            Ok(())
        }
        fn money(&self) -> std::result::Result<String, JsValue> {
            Ok(self.money.clone())
        }
        fn set_disabled(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.disabled = value;
            Ok(())
        }
        fn disabled(&self) -> std::result::Result<String, JsValue> {
            Ok(self.disabled.clone())
        }
        fn set_welllight(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.welllight = value;
            Ok(())
        }
        fn welllight(&self) -> std::result::Result<String, JsValue> {
            Ok(self.welllight.clone())
        }
        fn set_infolight(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.infolight = value;
            Ok(())
        }
        fn infolight(&self) -> std::result::Result<String, JsValue> {
            Ok(self.infolight.clone())
        }
        fn set_primarylight(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.primarylight = value;
            Ok(())
        }
        fn primarylight(&self) -> std::result::Result<String, JsValue> {
            Ok(self.primarylight.clone())
        }
        fn set_secondarydark(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.secondarydark = value;
            Ok(())
        }
        fn secondarydark(&self) -> std::result::Result<String, JsValue> {
            Ok(self.secondarydark.clone())
        }
        fn set_warning(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.warning = value;
            Ok(())
        }
        fn warning(&self) -> std::result::Result<String, JsValue> {
            Ok(self.warning.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct CorpConstants {
        #[serde(rename = "teaCostPerEmployee")]
        pub tea_cost_per_employee: f64,
        #[serde(rename = "gameCyclesPerMarketCycle")]
        pub game_cycles_per_market_cycle: f64,
        #[serde(rename = "issueNewSharesCooldown")]
        pub issue_new_shares_cooldown: f64,
        #[serde(rename = "stateNames")]
        pub state_names: Vec<CorpStateName>,
        #[serde(rename = "gameCyclesPerCorpStateCycle")]
        pub game_cycles_per_corp_state_cycle: f64,
        #[serde(rename = "maxProductsBase")]
        pub max_products_base: f64,
        #[serde(rename = "officeInitialCost")]
        pub office_initial_cost: f64,
        #[serde(rename = "sharesPerPriceUpdate")]
        pub shares_per_price_update: f64,
        #[serde(rename = "industryNames")]
        pub industry_names: Vec<CorpIndustryName>,
        #[serde(rename = "officeInitialSize")]
        pub office_initial_size: f64,
        #[serde(rename = "secondsPerMarketCycle")]
        pub seconds_per_market_cycle: f64,
        #[serde(rename = "researchNamesBase")]
        pub research_names_base: Vec<CorpResearchName>,
        #[serde(rename = "dividendMaxRate")]
        pub dividend_max_rate: f64,
        #[serde(rename = "researchNamesProductOnly")]
        pub research_names_product_only: Vec<CorpResearchName>,
        #[serde(rename = "warehouseSizeUpgradeCostBase")]
        pub warehouse_size_upgrade_cost_base: f64,
        #[serde(rename = "initialShares")]
        pub initial_shares: f64,
        #[serde(rename = "unlockNames")]
        pub unlock_names: Vec<CorpUnlockName>,
        #[serde(rename = "materialNames")]
        pub material_names: Vec<CorpMaterialName>,
        #[serde(rename = "upgradeNames")]
        pub upgrade_names: Vec<CorpUpgradeName>,
        #[serde(rename = "sellSharesCooldown")]
        pub sell_shares_cooldown: f64,
        #[serde(rename = "bribeThreshold")]
        pub bribe_threshold: f64,
        #[serde(rename = "employeeSalaryMultiplier")]
        pub employee_salary_multiplier: f64,
        #[serde(rename = "marketCyclesPerEmployeeRaise")]
        pub market_cycles_per_employee_raise: f64,
        #[serde(rename = "officeSizeUpgradeCostBase")]
        pub office_size_upgrade_cost_base: f64,
        #[serde(rename = "baseProductProfitMult")]
        pub base_product_profit_mult: f64,
        #[serde(rename = "bribeAmountPerReputation")]
        pub bribe_amount_per_reputation: f64,
        #[serde(rename = "warehouseInitialSize")]
        pub warehouse_initial_size: f64,
        #[serde(rename = "researchNames")]
        pub research_names: Vec<CorpResearchName>,
        #[serde(rename = "warehouseInitialCost")]
        pub warehouse_initial_cost: f64,
        #[serde(rename = "employeeRaiseAmount")]
        pub employee_raise_amount: f64,
        #[serde(rename = "minEmployeeDecay")]
        pub min_employee_decay: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait CorpConstants_Trait {
        fn set_base_product_profit_mult(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn base_product_profit_mult(&self) -> std::result::Result<f64, JsValue>;
        fn set_bribe_threshold(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn bribe_threshold(&self) -> std::result::Result<f64, JsValue>;
        fn set_state_names(
            &mut self,
            value: Vec<CorpStateName>,
        ) -> std::result::Result<(), JsValue>;
        fn state_names(&self) -> std::result::Result<Vec<CorpStateName>, JsValue>;
        fn set_game_cycles_per_market_cycle(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue>;
        fn game_cycles_per_market_cycle(&self) -> std::result::Result<f64, JsValue>;
        fn set_employee_salary_multiplier(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue>;
        fn employee_salary_multiplier(&self) -> std::result::Result<f64, JsValue>;
        fn set_warehouse_initial_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn warehouse_initial_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_warehouse_initial_size(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn warehouse_initial_size(&self) -> std::result::Result<f64, JsValue>;
        fn set_market_cycles_per_employee_raise(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue>;
        fn market_cycles_per_employee_raise(&self) -> std::result::Result<f64, JsValue>;
        fn set_industry_names(
            &mut self,
            value: Vec<CorpIndustryName>,
        ) -> std::result::Result<(), JsValue>;
        fn industry_names(&self) -> std::result::Result<Vec<CorpIndustryName>, JsValue>;
        fn set_dividend_max_rate(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn dividend_max_rate(&self) -> std::result::Result<f64, JsValue>;
        fn set_office_initial_size(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn office_initial_size(&self) -> std::result::Result<f64, JsValue>;
        fn set_office_size_upgrade_cost_base(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue>;
        fn office_size_upgrade_cost_base(&self) -> std::result::Result<f64, JsValue>;
        fn set_material_names(
            &mut self,
            value: Vec<CorpMaterialName>,
        ) -> std::result::Result<(), JsValue>;
        fn material_names(&self) -> std::result::Result<Vec<CorpMaterialName>, JsValue>;
        fn set_upgrade_names(
            &mut self,
            value: Vec<CorpUpgradeName>,
        ) -> std::result::Result<(), JsValue>;
        fn upgrade_names(&self) -> std::result::Result<Vec<CorpUpgradeName>, JsValue>;
        fn set_research_names(
            &mut self,
            value: Vec<CorpResearchName>,
        ) -> std::result::Result<(), JsValue>;
        fn research_names(&self) -> std::result::Result<Vec<CorpResearchName>, JsValue>;
        fn set_seconds_per_market_cycle(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn seconds_per_market_cycle(&self) -> std::result::Result<f64, JsValue>;
        fn set_warehouse_size_upgrade_cost_base(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue>;
        fn warehouse_size_upgrade_cost_base(&self) -> std::result::Result<f64, JsValue>;
        fn set_min_employee_decay(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn min_employee_decay(&self) -> std::result::Result<f64, JsValue>;
        fn set_office_initial_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn office_initial_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_game_cycles_per_corp_state_cycle(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue>;
        fn game_cycles_per_corp_state_cycle(&self) -> std::result::Result<f64, JsValue>;
        fn set_tea_cost_per_employee(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn tea_cost_per_employee(&self) -> std::result::Result<f64, JsValue>;
        fn set_issue_new_shares_cooldown(&mut self, value: f64)
            -> std::result::Result<(), JsValue>;
        fn issue_new_shares_cooldown(&self) -> std::result::Result<f64, JsValue>;
        fn set_max_products_base(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn max_products_base(&self) -> std::result::Result<f64, JsValue>;
        fn set_research_names_base(
            &mut self,
            value: Vec<CorpResearchName>,
        ) -> std::result::Result<(), JsValue>;
        fn research_names_base(&self) -> std::result::Result<Vec<CorpResearchName>, JsValue>;
        fn set_research_names_product_only(
            &mut self,
            value: Vec<CorpResearchName>,
        ) -> std::result::Result<(), JsValue>;
        fn research_names_product_only(
            &self,
        ) -> std::result::Result<Vec<CorpResearchName>, JsValue>;
        fn set_sell_shares_cooldown(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn sell_shares_cooldown(&self) -> std::result::Result<f64, JsValue>;
        fn set_bribe_amount_per_reputation(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue>;
        fn bribe_amount_per_reputation(&self) -> std::result::Result<f64, JsValue>;
        fn set_initial_shares(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn initial_shares(&self) -> std::result::Result<f64, JsValue>;
        fn set_employee_raise_amount(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn employee_raise_amount(&self) -> std::result::Result<f64, JsValue>;
        fn set_unlock_names(
            &mut self,
            value: Vec<CorpUnlockName>,
        ) -> std::result::Result<(), JsValue>;
        fn unlock_names(&self) -> std::result::Result<Vec<CorpUnlockName>, JsValue>;
        fn set_shares_per_price_update(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn shares_per_price_update(&self) -> std::result::Result<f64, JsValue>;
    }
    impl CorpConstants_Trait for CorpConstants {
        fn set_base_product_profit_mult(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.base_product_profit_mult = value;
            Ok(())
        }
        fn base_product_profit_mult(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.base_product_profit_mult)
        }
        fn set_bribe_threshold(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.bribe_threshold = value;
            Ok(())
        }
        fn bribe_threshold(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.bribe_threshold)
        }
        fn set_state_names(
            &mut self,
            value: Vec<CorpStateName>,
        ) -> std::result::Result<(), JsValue> {
            self.state_names = value;
            Ok(())
        }
        fn state_names(&self) -> std::result::Result<Vec<CorpStateName>, JsValue> {
            Ok(self.state_names.clone())
        }
        fn set_game_cycles_per_market_cycle(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue> {
            self.game_cycles_per_market_cycle = value;
            Ok(())
        }
        fn game_cycles_per_market_cycle(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.game_cycles_per_market_cycle)
        }
        fn set_employee_salary_multiplier(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue> {
            self.employee_salary_multiplier = value;
            Ok(())
        }
        fn employee_salary_multiplier(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.employee_salary_multiplier)
        }
        fn set_warehouse_initial_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.warehouse_initial_cost = value;
            Ok(())
        }
        fn warehouse_initial_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.warehouse_initial_cost)
        }
        fn set_warehouse_initial_size(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.warehouse_initial_size = value;
            Ok(())
        }
        fn warehouse_initial_size(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.warehouse_initial_size)
        }
        fn set_market_cycles_per_employee_raise(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue> {
            self.market_cycles_per_employee_raise = value;
            Ok(())
        }
        fn market_cycles_per_employee_raise(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.market_cycles_per_employee_raise)
        }
        fn set_industry_names(
            &mut self,
            value: Vec<CorpIndustryName>,
        ) -> std::result::Result<(), JsValue> {
            self.industry_names = value;
            Ok(())
        }
        fn industry_names(&self) -> std::result::Result<Vec<CorpIndustryName>, JsValue> {
            Ok(self.industry_names.clone())
        }
        fn set_dividend_max_rate(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.dividend_max_rate = value;
            Ok(())
        }
        fn dividend_max_rate(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.dividend_max_rate)
        }
        fn set_office_initial_size(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.office_initial_size = value;
            Ok(())
        }
        fn office_initial_size(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.office_initial_size)
        }
        fn set_office_size_upgrade_cost_base(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue> {
            self.office_size_upgrade_cost_base = value;
            Ok(())
        }
        fn office_size_upgrade_cost_base(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.office_size_upgrade_cost_base)
        }
        fn set_material_names(
            &mut self,
            value: Vec<CorpMaterialName>,
        ) -> std::result::Result<(), JsValue> {
            self.material_names = value;
            Ok(())
        }
        fn material_names(&self) -> std::result::Result<Vec<CorpMaterialName>, JsValue> {
            Ok(self.material_names.clone())
        }
        fn set_upgrade_names(
            &mut self,
            value: Vec<CorpUpgradeName>,
        ) -> std::result::Result<(), JsValue> {
            self.upgrade_names = value;
            Ok(())
        }
        fn upgrade_names(&self) -> std::result::Result<Vec<CorpUpgradeName>, JsValue> {
            Ok(self.upgrade_names.clone())
        }
        fn set_research_names(
            &mut self,
            value: Vec<CorpResearchName>,
        ) -> std::result::Result<(), JsValue> {
            self.research_names = value;
            Ok(())
        }
        fn research_names(&self) -> std::result::Result<Vec<CorpResearchName>, JsValue> {
            Ok(self.research_names.clone())
        }
        fn set_seconds_per_market_cycle(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.seconds_per_market_cycle = value;
            Ok(())
        }
        fn seconds_per_market_cycle(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.seconds_per_market_cycle)
        }
        fn set_warehouse_size_upgrade_cost_base(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue> {
            self.warehouse_size_upgrade_cost_base = value;
            Ok(())
        }
        fn warehouse_size_upgrade_cost_base(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.warehouse_size_upgrade_cost_base)
        }
        fn set_min_employee_decay(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.min_employee_decay = value;
            Ok(())
        }
        fn min_employee_decay(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.min_employee_decay)
        }
        fn set_office_initial_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.office_initial_cost = value;
            Ok(())
        }
        fn office_initial_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.office_initial_cost)
        }
        fn set_game_cycles_per_corp_state_cycle(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue> {
            self.game_cycles_per_corp_state_cycle = value;
            Ok(())
        }
        fn game_cycles_per_corp_state_cycle(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.game_cycles_per_corp_state_cycle)
        }
        fn set_tea_cost_per_employee(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.tea_cost_per_employee = value;
            Ok(())
        }
        fn tea_cost_per_employee(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.tea_cost_per_employee)
        }
        fn set_issue_new_shares_cooldown(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue> {
            self.issue_new_shares_cooldown = value;
            Ok(())
        }
        fn issue_new_shares_cooldown(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.issue_new_shares_cooldown)
        }
        fn set_max_products_base(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.max_products_base = value;
            Ok(())
        }
        fn max_products_base(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.max_products_base)
        }
        fn set_research_names_base(
            &mut self,
            value: Vec<CorpResearchName>,
        ) -> std::result::Result<(), JsValue> {
            self.research_names_base = value;
            Ok(())
        }
        fn research_names_base(&self) -> std::result::Result<Vec<CorpResearchName>, JsValue> {
            Ok(self.research_names_base.clone())
        }
        fn set_research_names_product_only(
            &mut self,
            value: Vec<CorpResearchName>,
        ) -> std::result::Result<(), JsValue> {
            self.research_names_product_only = value;
            Ok(())
        }
        fn research_names_product_only(
            &self,
        ) -> std::result::Result<Vec<CorpResearchName>, JsValue> {
            Ok(self.research_names_product_only.clone())
        }
        fn set_sell_shares_cooldown(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.sell_shares_cooldown = value;
            Ok(())
        }
        fn sell_shares_cooldown(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.sell_shares_cooldown)
        }
        fn set_bribe_amount_per_reputation(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue> {
            self.bribe_amount_per_reputation = value;
            Ok(())
        }
        fn bribe_amount_per_reputation(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.bribe_amount_per_reputation)
        }
        fn set_initial_shares(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.initial_shares = value;
            Ok(())
        }
        fn initial_shares(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.initial_shares)
        }
        fn set_employee_raise_amount(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.employee_raise_amount = value;
            Ok(())
        }
        fn employee_raise_amount(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.employee_raise_amount)
        }
        fn set_unlock_names(
            &mut self,
            value: Vec<CorpUnlockName>,
        ) -> std::result::Result<(), JsValue> {
            self.unlock_names = value;
            Ok(())
        }
        fn unlock_names(&self) -> std::result::Result<Vec<CorpUnlockName>, JsValue> {
            Ok(self.unlock_names.clone())
        }
        fn set_shares_per_price_update(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.shares_per_price_update = value;
            Ok(())
        }
        fn shares_per_price_update(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.shares_per_price_update)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct EquipmentStats {
        #[serde(rename = "dex")]
        pub dex: Option<f64>,
        #[serde(rename = "hack")]
        pub hack: Option<f64>,
        #[serde(rename = "cha")]
        pub cha: Option<f64>,
        #[serde(rename = "agi")]
        pub agi: Option<f64>,
        #[serde(rename = "str")]
        pub str: Option<f64>,
        #[serde(rename = "def")]
        pub def: Option<f64>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait EquipmentStats_Trait {
        fn set_cha(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn cha(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_dex(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn dex(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_str(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn str(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_agi(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn agi(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_def(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn def(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_hack(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn hack(&self) -> std::result::Result<Option<f64>, JsValue>;
    }
    impl EquipmentStats_Trait for EquipmentStats {
        fn set_cha(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.cha = value;
            Ok(())
        }
        fn cha(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.cha.clone())
        }
        fn set_dex(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.dex = value;
            Ok(())
        }
        fn dex(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.dex.clone())
        }
        fn set_str(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.str = value;
            Ok(())
        }
        fn str(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.str.clone())
        }
        fn set_agi(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.agi = value;
            Ok(())
        }
        fn agi(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.agi.clone())
        }
        fn set_def(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.def = value;
            Ok(())
        }
        fn def(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.def.clone())
        }
        fn set_hack(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.hack = value;
            Ok(())
        }
        fn hack(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.hack.clone())
        }
    }
    #[wasm_bindgen]
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum ToastVariant {
        Success = "success",
        Warning = "warning",
        Error = "error",
        Info = "info",
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct GangMemberAscension {
        #[serde(rename = "str")]
        pub str: f64,
        #[serde(rename = "dex")]
        pub dex: f64,
        #[serde(rename = "hack")]
        pub hack: f64,
        #[serde(rename = "cha")]
        pub cha: f64,
        #[serde(rename = "agi")]
        pub agi: f64,
        #[serde(rename = "def")]
        pub def: f64,
        #[serde(rename = "respect")]
        pub respect: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait GangMemberAscension_Trait {
        fn set_hack(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hack(&self) -> std::result::Result<f64, JsValue>;
        fn set_agi(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn agi(&self) -> std::result::Result<f64, JsValue>;
        fn set_cha(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn cha(&self) -> std::result::Result<f64, JsValue>;
        fn set_dex(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn dex(&self) -> std::result::Result<f64, JsValue>;
        fn set_str(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn str(&self) -> std::result::Result<f64, JsValue>;
        fn set_def(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn def(&self) -> std::result::Result<f64, JsValue>;
        fn set_respect(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn respect(&self) -> std::result::Result<f64, JsValue>;
    }
    impl GangMemberAscension_Trait for GangMemberAscension {
        fn set_hack(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hack = value;
            Ok(())
        }
        fn hack(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hack)
        }
        fn set_agi(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.agi = value;
            Ok(())
        }
        fn agi(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.agi)
        }
        fn set_cha(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.cha = value;
            Ok(())
        }
        fn cha(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.cha)
        }
        fn set_dex(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.dex = value;
            Ok(())
        }
        fn dex(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.dex)
        }
        fn set_str(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.str = value;
            Ok(())
        }
        fn str(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.str)
        }
        fn set_def(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.def = value;
            Ok(())
        }
        fn def(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.def)
        }
        fn set_respect(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.respect = value;
            Ok(())
        }
        fn respect(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.respect)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum SleeveGetTaskReturn {
        SleeveTask(SleeveTask),
        TsBindgenRtNull,
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct GangOtherInfoObject {
        #[serde(rename = "territory")]
        pub territory: f64,
        #[serde(rename = "power")]
        pub power: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait GangOtherInfoObject_Trait {
        fn set_power(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn power(&self) -> std::result::Result<f64, JsValue>;
        fn set_territory(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn territory(&self) -> std::result::Result<f64, JsValue>;
    }
    impl GangOtherInfoObject_Trait for GangOtherInfoObject {
        fn set_power(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.power = value;
            Ok(())
        }
        fn power(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.power)
        }
        fn set_territory(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.territory = value;
            Ok(())
        }
        fn territory(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.territory)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct NsGetTotalScriptIncomeReturn(pub f64, pub f64);
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct ProductStats {
        #[serde(rename = "aesthetics")]
        pub aesthetics: f64,
        #[serde(rename = "performance")]
        pub performance: f64,
        #[serde(rename = "durability")]
        pub durability: f64,
        #[serde(rename = "reliability")]
        pub reliability: f64,
        #[serde(rename = "features")]
        pub features: f64,
        #[serde(rename = "quality")]
        pub quality: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait ProductStats_Trait {
        fn set_features(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn features(&self) -> std::result::Result<f64, JsValue>;
        fn set_reliability(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn reliability(&self) -> std::result::Result<f64, JsValue>;
        fn set_durability(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn durability(&self) -> std::result::Result<f64, JsValue>;
        fn set_aesthetics(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn aesthetics(&self) -> std::result::Result<f64, JsValue>;
        fn set_performance(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn performance(&self) -> std::result::Result<f64, JsValue>;
        fn set_quality(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn quality(&self) -> std::result::Result<f64, JsValue>;
    }
    impl ProductStats_Trait for ProductStats {
        fn set_features(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.features = value;
            Ok(())
        }
        fn features(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.features)
        }
        fn set_reliability(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.reliability = value;
            Ok(())
        }
        fn reliability(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.reliability)
        }
        fn set_durability(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.durability = value;
            Ok(())
        }
        fn durability(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.durability)
        }
        fn set_aesthetics(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.aesthetics = value;
            Ok(())
        }
        fn aesthetics(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.aesthetics)
        }
        fn set_performance(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.performance = value;
            Ok(())
        }
        fn performance(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.performance)
        }
        fn set_quality(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.quality = value;
            Ok(())
        }
        fn quality(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.quality)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct BasicHgwOptions {
        #[serde(rename = "threads")]
        pub threads: Option<f64>,
        #[serde(rename = "additionalMsec")]
        pub additional_msec: Option<f64>,
        #[serde(rename = "stock")]
        pub stock: Option<bool>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait BasicHgwOptions_Trait {
        fn set_stock(&mut self, value: Option<bool>) -> std::result::Result<(), JsValue>;
        fn stock(&self) -> std::result::Result<Option<bool>, JsValue>;
        fn set_threads(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn threads(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_additional_msec(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn additional_msec(&self) -> std::result::Result<Option<f64>, JsValue>;
    }
    impl BasicHgwOptions_Trait for BasicHgwOptions {
        fn set_stock(&mut self, value: Option<bool>) -> std::result::Result<(), JsValue> {
            self.stock = value;
            Ok(())
        }
        fn stock(&self) -> std::result::Result<Option<bool>, JsValue> {
            Ok(self.stock.clone())
        }
        fn set_threads(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.threads = value;
            Ok(())
        }
        fn threads(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.threads.clone())
        }
        fn set_additional_msec(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.additional_msec = value;
            Ok(())
        }
        fn additional_msec(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.additional_msec.clone())
        }
    }
    #[wasm_bindgen]
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum OrderTypes {
        LimitBuy = "Limit Buy Order",
        LimitSell = "Limit Sell Order",
        StopBuy = "Stop Buy Order",
        StopSell = "Stop Sell Order",
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct CorpProductData {
        #[serde(rename = "desc")]
        pub desc: String,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "verb")]
        pub verb: String,
        #[serde(rename = "ratingWeights")]
        pub rating_weights: CorpProductDataRatingWeights,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait CorpProductData_Trait {
        fn set_rating_weights(
            &mut self,
            value: CorpProductDataRatingWeights,
        ) -> std::result::Result<(), JsValue>;
        fn rating_weights(&self) -> std::result::Result<CorpProductDataRatingWeights, JsValue>;
        fn set_verb(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn verb(&self) -> std::result::Result<String, JsValue>;
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn name(&self) -> std::result::Result<String, JsValue>;
        fn set_desc(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn desc(&self) -> std::result::Result<String, JsValue>;
    }
    impl CorpProductData_Trait for CorpProductData {
        fn set_rating_weights(
            &mut self,
            value: CorpProductDataRatingWeights,
        ) -> std::result::Result<(), JsValue> {
            self.rating_weights = value;
            Ok(())
        }
        fn rating_weights(&self) -> std::result::Result<CorpProductDataRatingWeights, JsValue> {
            Ok(self.rating_weights.clone())
        }
        fn set_verb(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.verb = value;
            Ok(())
        }
        fn verb(&self) -> std::result::Result<String, JsValue> {
            Ok(self.verb.clone())
        }
        fn set_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.name = value;
            Ok(())
        }
        fn name(&self) -> std::result::Result<String, JsValue> {
            Ok(self.name.clone())
        }
        fn set_desc(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.desc = value;
            Ok(())
        }
        fn desc(&self) -> std::result::Result<String, JsValue> {
            Ok(self.desc.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum ScriptArgAliased {
        Bool(bool),
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct NsFlagsParamsSchema(pub String, pub NsFlagsParamsSchemaTuple1);
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Ns {
        #[serde(
            rename = "getFunctionRamCost",
            serialize_with = "Ns::__TSB__serialize_get_function_ram_cost",
            deserialize_with = "Ns::__TSB__deserialize_get_function_ram_cost"
        )]
        pub get_function_ram_cost: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "formatRam",
            serialize_with = "Ns::__TSB__serialize_format_ram",
            deserialize_with = "Ns::__TSB__deserialize_format_ram"
        )]
        pub format_ram: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<String, JsValue>>,
        #[serde(rename = "singularity")]
        pub singularity: Singularity,
        #[serde(
            rename = "rm",
            serialize_with = "Ns::__TSB__serialize_rm",
            deserialize_with = "Ns::__TSB__deserialize_rm"
        )]
        pub rm: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "upgradePurchasedServer",
            serialize_with = "Ns::__TSB__serialize_upgrade_purchased_server",
            deserialize_with = "Ns::__TSB__deserialize_upgrade_purchased_server"
        )]
        pub upgrade_purchased_server:
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getHackTime",
            serialize_with = "Ns::__TSB__serialize_get_hack_time",
            deserialize_with = "Ns::__TSB__deserialize_get_hack_time"
        )]
        pub get_hack_time: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "prompt",
            serialize_with = "Ns::__TSB__serialize_prompt",
            deserialize_with = "Ns::__TSB__deserialize_prompt"
        )]
        pub prompt: std::rc::Rc<
            dyn Fn(String, NsPromptParamsOptions) -> std::result::Result<js_sys::Promise, JsValue>,
        >,
        #[serde(
            rename = "getServerMaxMoney",
            serialize_with = "Ns::__TSB__serialize_get_server_max_money",
            deserialize_with = "Ns::__TSB__deserialize_get_server_max_money"
        )]
        pub get_server_max_money: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "flags",
            serialize_with = "Ns::__TSB__serialize_flags",
            deserialize_with = "Ns::__TSB__deserialize_flags"
        )]
        pub flags: std::rc::Rc<
            dyn Fn(
                Vec<NsFlagsParamsSchema>,
            ) -> std::result::Result<
                std::collections::HashMap<String, NsFlagsReturn>,
                JsValue,
            >,
        >,
        #[serde(
            rename = "growthAnalyze",
            serialize_with = "Ns::__TSB__serialize_growth_analyze",
            deserialize_with = "Ns::__TSB__deserialize_growth_analyze"
        )]
        pub growth_analyze:
            std::rc::Rc<dyn Fn(String, f64, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "hasRootAccess",
            serialize_with = "Ns::__TSB__serialize_has_root_access",
            deserialize_with = "Ns::__TSB__deserialize_has_root_access"
        )]
        pub has_root_access: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "tail",
            serialize_with = "Ns::__TSB__serialize_tail",
            deserialize_with = "Ns::__TSB__deserialize_tail"
        )]
        pub tail: std::rc::Rc<
            dyn Fn(
                FilenameOrPid,
                String,
                Vec<NsTailParamsArgs>,
            ) -> std::result::Result<(), JsValue>,
        >,
        #[serde(
            rename = "getHackingLevel",
            serialize_with = "Ns::__TSB__serialize_get_hacking_level",
            deserialize_with = "Ns::__TSB__deserialize_get_hacking_level"
        )]
        pub get_hacking_level: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "enableLog",
            serialize_with = "Ns::__TSB__serialize_enable_log",
            deserialize_with = "Ns::__TSB__deserialize_enable_log"
        )]
        pub enable_log: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "ftpcrack",
            serialize_with = "Ns::__TSB__serialize_ftpcrack",
            deserialize_with = "Ns::__TSB__deserialize_ftpcrack"
        )]
        pub ftpcrack: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "getTotalScriptIncome",
            serialize_with = "Ns::__TSB__serialize_get_total_script_income",
            deserialize_with = "Ns::__TSB__deserialize_get_total_script_income"
        )]
        pub get_total_script_income:
            std::rc::Rc<dyn Fn() -> std::result::Result<NsGetTotalScriptIncomeReturn, JsValue>>,
        #[serde(
            rename = "getWeakenTime",
            serialize_with = "Ns::__TSB__serialize_get_weaken_time",
            deserialize_with = "Ns::__TSB__deserialize_get_weaken_time"
        )]
        pub get_weaken_time: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getServerGrowth",
            serialize_with = "Ns::__TSB__serialize_get_server_growth",
            deserialize_with = "Ns::__TSB__deserialize_get_server_growth"
        )]
        pub get_server_growth: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "hackAnalyzeSecurity",
            serialize_with = "Ns::__TSB__serialize_hack_analyze_security",
            deserialize_with = "Ns::__TSB__deserialize_hack_analyze_security"
        )]
        pub hack_analyze_security:
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "scriptKill",
            serialize_with = "Ns::__TSB__serialize_script_kill",
            deserialize_with = "Ns::__TSB__deserialize_script_kill"
        )]
        pub script_kill: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getServer",
            serialize_with = "Ns::__TSB__serialize_get_server",
            deserialize_with = "Ns::__TSB__deserialize_get_server"
        )]
        pub get_server: std::rc::Rc<dyn Fn(String) -> std::result::Result<Server, JsValue>>,
        #[serde(rename = "codingcontract")]
        pub codingcontract: CodingContract,
        #[serde(rename = "formulas")]
        pub formulas: Formulas,
        #[serde(rename = "infiltration")]
        pub infiltration: Infiltration,
        #[serde(
            rename = "getServerRequiredHackingLevel",
            serialize_with = "Ns::__TSB__serialize_get_server_required_hacking_level",
            deserialize_with = "Ns::__TSB__deserialize_get_server_required_hacking_level"
        )]
        pub get_server_required_hacking_level:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(rename = "stock")]
        pub stock: Tix,
        #[serde(
            rename = "run",
            serialize_with = "Ns::__TSB__serialize_run",
            deserialize_with = "Ns::__TSB__deserialize_run"
        )]
        pub run: std::rc::Rc<
            dyn Fn(
                String,
                NsRunParamsThreadOrOptions,
                Vec<NsRunParamsArgs>,
            ) -> std::result::Result<f64, JsValue>,
        >,
        #[serde(
            rename = "getServerMoneyAvailable",
            serialize_with = "Ns::__TSB__serialize_get_server_money_available",
            deserialize_with = "Ns::__TSB__deserialize_get_server_money_available"
        )]
        pub get_server_money_available:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "grow",
            serialize_with = "Ns::__TSB__serialize_grow",
            deserialize_with = "Ns::__TSB__deserialize_grow"
        )]
        pub grow: std::rc::Rc<
            dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
        >,
        #[serde(
            rename = "vsprintf",
            serialize_with = "Ns::__TSB__serialize_vsprintf",
            deserialize_with = "Ns::__TSB__deserialize_vsprintf"
        )]
        pub vsprintf:
            std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<String, JsValue>>,
        #[serde(
            rename = "growthAnalyzeSecurity",
            serialize_with = "Ns::__TSB__serialize_growth_analyze_security",
            deserialize_with = "Ns::__TSB__deserialize_growth_analyze_security"
        )]
        pub growth_analyze_security:
            std::rc::Rc<dyn Fn(f64, String, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getMoneySources",
            serialize_with = "Ns::__TSB__serialize_get_money_sources",
            deserialize_with = "Ns::__TSB__deserialize_get_money_sources"
        )]
        pub get_money_sources: std::rc::Rc<dyn Fn() -> std::result::Result<MoneySources, JsValue>>,
        #[serde(
            rename = "sqlinject",
            serialize_with = "Ns::__TSB__serialize_sqlinject",
            deserialize_with = "Ns::__TSB__deserialize_sqlinject"
        )]
        pub sqlinject: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "fileExists",
            serialize_with = "Ns::__TSB__serialize_file_exists",
            deserialize_with = "Ns::__TSB__deserialize_file_exists"
        )]
        pub file_exists: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "print",
            serialize_with = "Ns::__TSB__serialize_print",
            deserialize_with = "Ns::__TSB__deserialize_print"
        )]
        pub print: std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "read",
            serialize_with = "Ns::__TSB__serialize_read",
            deserialize_with = "Ns::__TSB__deserialize_read"
        )]
        pub read: std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
        #[serde(
            rename = "purchaseServer",
            serialize_with = "Ns::__TSB__serialize_purchase_server",
            deserialize_with = "Ns::__TSB__deserialize_purchase_server"
        )]
        pub purchase_server:
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<String, JsValue>>,
        #[serde(
            rename = "getSharePower",
            serialize_with = "Ns::__TSB__serialize_get_share_power",
            deserialize_with = "Ns::__TSB__deserialize_get_share_power"
        )]
        pub get_share_power: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "tFormat",
            serialize_with = "Ns::__TSB__serialize_t_format",
            deserialize_with = "Ns::__TSB__deserialize_t_format"
        )]
        pub t_format: std::rc::Rc<dyn Fn(f64, bool) -> std::result::Result<String, JsValue>>,
        #[serde(
            rename = "readPort",
            serialize_with = "Ns::__TSB__serialize_read_port",
            deserialize_with = "Ns::__TSB__deserialize_read_port"
        )]
        pub read_port: std::rc::Rc<dyn Fn(f64) -> std::result::Result<PortData, JsValue>>,
        #[serde(
            rename = "hackAnalyzeChance",
            serialize_with = "Ns::__TSB__serialize_hack_analyze_chance",
            deserialize_with = "Ns::__TSB__deserialize_hack_analyze_chance"
        )]
        pub hack_analyze_chance: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getPurchasedServerCost",
            serialize_with = "Ns::__TSB__serialize_get_purchased_server_cost",
            deserialize_with = "Ns::__TSB__deserialize_get_purchased_server_cost"
        )]
        pub get_purchased_server_cost:
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
        #[serde(rename = "grafting")]
        pub grafting: Grafting,
        #[serde(
            rename = "getHacknetMultipliers",
            serialize_with = "Ns::__TSB__serialize_get_hacknet_multipliers",
            deserialize_with = "Ns::__TSB__deserialize_get_hacknet_multipliers"
        )]
        pub get_hacknet_multipliers:
            std::rc::Rc<dyn Fn() -> std::result::Result<HacknetMultipliers, JsValue>>,
        #[serde(
            rename = "peek",
            serialize_with = "Ns::__TSB__serialize_peek",
            deserialize_with = "Ns::__TSB__deserialize_peek"
        )]
        pub peek: std::rc::Rc<dyn Fn(f64) -> std::result::Result<PortData, JsValue>>,
        #[serde(
            rename = "scriptRunning",
            serialize_with = "Ns::__TSB__serialize_script_running",
            deserialize_with = "Ns::__TSB__deserialize_script_running"
        )]
        pub script_running:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "writePort",
            serialize_with = "Ns::__TSB__serialize_write_port",
            deserialize_with = "Ns::__TSB__deserialize_write_port"
        )]
        pub write_port: std::rc::Rc<
            dyn Fn(f64, NsWritePortParamsData) -> std::result::Result<NsWritePortReturn, JsValue>,
        >,
        #[serde(
            rename = "getPurchasedServerUpgradeCost",
            serialize_with = "Ns::__TSB__serialize_get_purchased_server_upgrade_cost",
            deserialize_with = "Ns::__TSB__deserialize_get_purchased_server_upgrade_cost"
        )]
        pub get_purchased_server_upgrade_cost:
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "httpworm",
            serialize_with = "Ns::__TSB__serialize_httpworm",
            deserialize_with = "Ns::__TSB__deserialize_httpworm"
        )]
        pub httpworm: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "getPlayer",
            serialize_with = "Ns::__TSB__serialize_get_player",
            deserialize_with = "Ns::__TSB__deserialize_get_player"
        )]
        pub get_player: std::rc::Rc<dyn Fn() -> std::result::Result<Player, JsValue>>,
        #[serde(rename = "pid")]
        pub pid: f64,
        #[serde(
            rename = "getScriptIncome",
            serialize_with = "Ns::__TSB__serialize_get_script_income",
            deserialize_with = "Ns::__TSB__deserialize_get_script_income"
        )]
        pub get_script_income: std::rc::Rc<
            dyn Fn(
                String,
                String,
                Vec<NsGetScriptIncomeParamsArgs>,
            ) -> std::result::Result<f64, JsValue>,
        >,
        #[serde(
            rename = "spawn",
            serialize_with = "Ns::__TSB__serialize_spawn",
            deserialize_with = "Ns::__TSB__deserialize_spawn"
        )]
        pub spawn: std::rc::Rc<
            dyn Fn(
                String,
                NsSpawnParamsThreadOrOptions,
                Vec<NsSpawnParamsArgs>,
            ) -> std::result::Result<(), JsValue>,
        >,
        #[serde(
            rename = "getPurchasedServers",
            serialize_with = "Ns::__TSB__serialize_get_purchased_servers",
            deserialize_with = "Ns::__TSB__deserialize_get_purchased_servers"
        )]
        pub get_purchased_servers:
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "tprintf",
            serialize_with = "Ns::__TSB__serialize_tprintf",
            deserialize_with = "Ns::__TSB__deserialize_tprintf"
        )]
        pub tprintf: std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "getServerUsedRam",
            serialize_with = "Ns::__TSB__serialize_get_server_used_ram",
            deserialize_with = "Ns::__TSB__deserialize_get_server_used_ram"
        )]
        pub get_server_used_ram: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getScriptLogs",
            serialize_with = "Ns::__TSB__serialize_get_script_logs",
            deserialize_with = "Ns::__TSB__deserialize_get_script_logs"
        )]
        pub get_script_logs: std::rc::Rc<
            dyn Fn(
                String,
                String,
                Vec<NsGetScriptLogsParamsArgs>,
            ) -> std::result::Result<Vec<String>, JsValue>,
        >,
        #[serde(
            rename = "wget",
            serialize_with = "Ns::__TSB__serialize_wget",
            deserialize_with = "Ns::__TSB__deserialize_wget"
        )]
        pub wget: std::rc::Rc<
            dyn Fn(String, String, String) -> std::result::Result<js_sys::Promise, JsValue>,
        >,
        #[serde(
            rename = "getTimeSinceLastAug",
            serialize_with = "Ns::__TSB__serialize_get_time_since_last_aug",
            deserialize_with = "Ns::__TSB__deserialize_get_time_since_last_aug"
        )]
        pub get_time_since_last_aug: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "killall",
            serialize_with = "Ns::__TSB__serialize_killall",
            deserialize_with = "Ns::__TSB__deserialize_killall"
        )]
        pub killall: std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "isLogEnabled",
            serialize_with = "Ns::__TSB__serialize_is_log_enabled",
            deserialize_with = "Ns::__TSB__deserialize_is_log_enabled"
        )]
        pub is_log_enabled: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "alert",
            serialize_with = "Ns::__TSB__serialize_alert",
            deserialize_with = "Ns::__TSB__deserialize_alert"
        )]
        pub alert: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "weaken",
            serialize_with = "Ns::__TSB__serialize_weaken",
            deserialize_with = "Ns::__TSB__deserialize_weaken"
        )]
        pub weaken: std::rc::Rc<
            dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
        >,
        #[serde(
            rename = "weakenAnalyze",
            serialize_with = "Ns::__TSB__serialize_weaken_analyze",
            deserialize_with = "Ns::__TSB__deserialize_weaken_analyze"
        )]
        pub weaken_analyze: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "brutessh",
            serialize_with = "Ns::__TSB__serialize_brutessh",
            deserialize_with = "Ns::__TSB__deserialize_brutessh"
        )]
        pub brutessh: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "clearLog",
            serialize_with = "Ns::__TSB__serialize_clear_log",
            deserialize_with = "Ns::__TSB__deserialize_clear_log"
        )]
        pub clear_log: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "asleep",
            serialize_with = "Ns::__TSB__serialize_asleep",
            deserialize_with = "Ns::__TSB__deserialize_asleep"
        )]
        pub asleep: std::rc::Rc<dyn Fn(f64) -> std::result::Result<js_sys::Promise, JsValue>>,
        #[serde(
            rename = "relaysmtp",
            serialize_with = "Ns::__TSB__serialize_relaysmtp",
            deserialize_with = "Ns::__TSB__deserialize_relaysmtp"
        )]
        pub relaysmtp: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "getPortHandle",
            serialize_with = "Ns::__TSB__serialize_get_port_handle",
            deserialize_with = "Ns::__TSB__deserialize_get_port_handle"
        )]
        pub get_port_handle:
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<NetscriptPort, JsValue>>,
        #[serde(
            rename = "kill",
            serialize_with = "Ns::__TSB__serialize_kill",
            deserialize_with = "Ns::__TSB__deserialize_kill"
        )]
        pub kill: std::rc::Rc<
            dyn Fn(String, String, Vec<ScriptArg>) -> std::result::Result<bool, JsValue>,
        >,
        #[serde(
            rename = "getRunningScript",
            serialize_with = "Ns::__TSB__serialize_get_running_script",
            deserialize_with = "Ns::__TSB__deserialize_get_running_script"
        )]
        pub get_running_script: std::rc::Rc<
            dyn Fn(
                FilenameOrPid,
                String,
                Vec<NsGetRunningScriptParamsArgs>,
            ) -> std::result::Result<NsGetRunningScriptReturn, JsValue>,
        >,
        #[serde(
            rename = "getHackingMultipliers",
            serialize_with = "Ns::__TSB__serialize_get_hacking_multipliers",
            deserialize_with = "Ns::__TSB__deserialize_get_hacking_multipliers"
        )]
        pub get_hacking_multipliers:
            std::rc::Rc<dyn Fn() -> std::result::Result<HackingMultipliers, JsValue>>,
        #[serde(
            rename = "getPurchasedServerLimit",
            serialize_with = "Ns::__TSB__serialize_get_purchased_server_limit",
            deserialize_with = "Ns::__TSB__deserialize_get_purchased_server_limit"
        )]
        pub get_purchased_server_limit: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "write",
            serialize_with = "Ns::__TSB__serialize_write",
            deserialize_with = "Ns::__TSB__deserialize_write"
        )]
        pub write: std::rc::Rc<
            dyn Fn(String, String, NsWriteParamsMode) -> std::result::Result<(), JsValue>,
        >,
        #[serde(
            rename = "getTotalScriptExpGain",
            serialize_with = "Ns::__TSB__serialize_get_total_script_exp_gain",
            deserialize_with = "Ns::__TSB__deserialize_get_total_script_exp_gain"
        )]
        pub get_total_script_exp_gain: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(rename = "bladeburner")]
        pub bladeburner: Bladeburner,
        #[serde(
            rename = "getFavorToDonate",
            serialize_with = "Ns::__TSB__serialize_get_favor_to_donate",
            deserialize_with = "Ns::__TSB__deserialize_get_favor_to_donate"
        )]
        pub get_favor_to_donate: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "serverExists",
            serialize_with = "Ns::__TSB__serialize_server_exists",
            deserialize_with = "Ns::__TSB__deserialize_server_exists"
        )]
        pub server_exists: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "disableLog",
            serialize_with = "Ns::__TSB__serialize_disable_log",
            deserialize_with = "Ns::__TSB__deserialize_disable_log"
        )]
        pub disable_log: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "sprintf",
            serialize_with = "Ns::__TSB__serialize_sprintf",
            deserialize_with = "Ns::__TSB__deserialize_sprintf"
        )]
        pub sprintf:
            std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<String, JsValue>>,
        #[serde(
            rename = "resizeTail",
            serialize_with = "Ns::__TSB__serialize_resize_tail",
            deserialize_with = "Ns::__TSB__deserialize_resize_tail"
        )]
        pub resize_tail: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "share",
            serialize_with = "Ns::__TSB__serialize_share",
            deserialize_with = "Ns::__TSB__deserialize_share"
        )]
        pub share: std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
        #[serde(
            rename = "formatNumber",
            serialize_with = "Ns::__TSB__serialize_format_number",
            deserialize_with = "Ns::__TSB__deserialize_format_number"
        )]
        pub format_number:
            std::rc::Rc<dyn Fn(f64, f64, f64, bool) -> std::result::Result<String, JsValue>>,
        #[serde(
            rename = "toast",
            serialize_with = "Ns::__TSB__serialize_toast",
            deserialize_with = "Ns::__TSB__deserialize_toast"
        )]
        pub toast: std::rc::Rc<
            dyn Fn(String, ToastVariant, NsToastParamsDuration) -> std::result::Result<(), JsValue>,
        >,
        #[serde(
            rename = "ps",
            serialize_with = "Ns::__TSB__serialize_ps",
            deserialize_with = "Ns::__TSB__deserialize_ps"
        )]
        pub ps: std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<ProcessInfo>, JsValue>>,
        #[serde(
            rename = "scan",
            serialize_with = "Ns::__TSB__serialize_scan",
            deserialize_with = "Ns::__TSB__deserialize_scan"
        )]
        pub scan: std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "closeTail",
            serialize_with = "Ns::__TSB__serialize_close_tail",
            deserialize_with = "Ns::__TSB__deserialize_close_tail"
        )]
        pub close_tail: std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "nFormat",
            serialize_with = "Ns::__TSB__serialize_n_format",
            deserialize_with = "Ns::__TSB__deserialize_n_format"
        )]
        pub n_format: std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<String, JsValue>>,
        #[serde(rename = "gang")]
        pub gang: Gang,
        #[serde(
            rename = "getServerSecurityLevel",
            serialize_with = "Ns::__TSB__serialize_get_server_security_level",
            deserialize_with = "Ns::__TSB__deserialize_get_server_security_level"
        )]
        pub get_server_security_level:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "scp",
            serialize_with = "Ns::__TSB__serialize_scp",
            deserialize_with = "Ns::__TSB__deserialize_scp"
        )]
        pub scp: std::rc::Rc<
            dyn Fn(NsScpParamsFiles, String, String) -> std::result::Result<bool, JsValue>,
        >,
        #[serde(
            rename = "getScriptExpGain",
            serialize_with = "Ns::__TSB__serialize_get_script_exp_gain",
            deserialize_with = "Ns::__TSB__deserialize_get_script_exp_gain"
        )]
        pub get_script_exp_gain: std::rc::Rc<
            dyn Fn(
                String,
                String,
                Vec<NsGetScriptExpGainParamsArgs>,
            ) -> std::result::Result<f64, JsValue>,
        >,
        #[serde(
            rename = "getResetInfo",
            serialize_with = "Ns::__TSB__serialize_get_reset_info",
            deserialize_with = "Ns::__TSB__deserialize_get_reset_info"
        )]
        pub get_reset_info: std::rc::Rc<dyn Fn() -> std::result::Result<ResetInfo, JsValue>>,
        #[serde(
            rename = "tryWritePort",
            serialize_with = "Ns::__TSB__serialize_try_write_port",
            deserialize_with = "Ns::__TSB__deserialize_try_write_port"
        )]
        pub try_write_port: std::rc::Rc<
            dyn Fn(f64, NsTryWritePortParamsData) -> std::result::Result<bool, JsValue>,
        >,
        #[serde(
            rename = "hackAnalyze",
            serialize_with = "Ns::__TSB__serialize_hack_analyze",
            deserialize_with = "Ns::__TSB__deserialize_hack_analyze"
        )]
        pub hack_analyze: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getGrowTime",
            serialize_with = "Ns::__TSB__serialize_get_grow_time",
            deserialize_with = "Ns::__TSB__deserialize_get_grow_time"
        )]
        pub get_grow_time: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "printf",
            serialize_with = "Ns::__TSB__serialize_printf",
            deserialize_with = "Ns::__TSB__deserialize_printf"
        )]
        pub printf: std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "hackAnalyzeThreads",
            serialize_with = "Ns::__TSB__serialize_hack_analyze_threads",
            deserialize_with = "Ns::__TSB__deserialize_hack_analyze_threads"
        )]
        pub hack_analyze_threads:
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getPurchasedServerMaxRam",
            serialize_with = "Ns::__TSB__serialize_get_purchased_server_max_ram",
            deserialize_with = "Ns::__TSB__deserialize_get_purchased_server_max_ram"
        )]
        pub get_purchased_server_max_ram:
            std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "mv",
            serialize_with = "Ns::__TSB__serialize_mv",
            deserialize_with = "Ns::__TSB__deserialize_mv"
        )]
        pub mv: std::rc::Rc<dyn Fn(String, String, String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "exec",
            serialize_with = "Ns::__TSB__serialize_exec",
            deserialize_with = "Ns::__TSB__deserialize_exec"
        )]
        pub exec: std::rc::Rc<
            dyn Fn(
                String,
                String,
                NsExecParamsThreadOrOptions,
                Vec<NsExecParamsArgs>,
            ) -> std::result::Result<f64, JsValue>,
        >,
        #[serde(
            rename = "getServerNumPortsRequired",
            serialize_with = "Ns::__TSB__serialize_get_server_num_ports_required",
            deserialize_with = "Ns::__TSB__deserialize_get_server_num_ports_required"
        )]
        pub get_server_num_ports_required:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getHostname",
            serialize_with = "Ns::__TSB__serialize_get_hostname",
            deserialize_with = "Ns::__TSB__deserialize_get_hostname"
        )]
        pub get_hostname: std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
        #[serde(
            rename = "getServerBaseSecurityLevel",
            serialize_with = "Ns::__TSB__serialize_get_server_base_security_level",
            deserialize_with = "Ns::__TSB__deserialize_get_server_base_security_level"
        )]
        pub get_server_base_security_level:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "tprint",
            serialize_with = "Ns::__TSB__serialize_tprint",
            deserialize_with = "Ns::__TSB__deserialize_tprint"
        )]
        pub tprint: std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "getServerMinSecurityLevel",
            serialize_with = "Ns::__TSB__serialize_get_server_min_security_level",
            deserialize_with = "Ns::__TSB__deserialize_get_server_min_security_level"
        )]
        pub get_server_min_security_level:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getRecentScripts",
            serialize_with = "Ns::__TSB__serialize_get_recent_scripts",
            deserialize_with = "Ns::__TSB__deserialize_get_recent_scripts"
        )]
        pub get_recent_scripts:
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<RecentScript>, JsValue>>,
        #[serde(
            rename = "renamePurchasedServer",
            serialize_with = "Ns::__TSB__serialize_rename_purchased_server",
            deserialize_with = "Ns::__TSB__deserialize_rename_purchased_server"
        )]
        pub rename_purchased_server:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "deleteServer",
            serialize_with = "Ns::__TSB__serialize_delete_server",
            deserialize_with = "Ns::__TSB__deserialize_delete_server"
        )]
        pub delete_server: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        #[serde(rename = "args")]
        pub args: Vec<NsArgs>,
        #[serde(
            rename = "ls",
            serialize_with = "Ns::__TSB__serialize_ls",
            deserialize_with = "Ns::__TSB__deserialize_ls"
        )]
        pub ls: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "getServerMaxRam",
            serialize_with = "Ns::__TSB__serialize_get_server_max_ram",
            deserialize_with = "Ns::__TSB__deserialize_get_server_max_ram"
        )]
        pub get_server_max_ram: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(rename = "enums")]
        pub enums: NsEnums,
        #[serde(
            rename = "isRunning",
            serialize_with = "Ns::__TSB__serialize_is_running",
            deserialize_with = "Ns::__TSB__deserialize_is_running"
        )]
        pub is_running: std::rc::Rc<
            dyn Fn(
                FilenameOrPid,
                String,
                Vec<NsIsRunningParamsArgs>,
            ) -> std::result::Result<bool, JsValue>,
        >,
        #[serde(
            rename = "hack",
            serialize_with = "Ns::__TSB__serialize_hack",
            deserialize_with = "Ns::__TSB__deserialize_hack"
        )]
        pub hack: std::rc::Rc<
            dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
        >,
        #[serde(
            rename = "sleep",
            serialize_with = "Ns::__TSB__serialize_sleep",
            deserialize_with = "Ns::__TSB__deserialize_sleep"
        )]
        pub sleep: std::rc::Rc<dyn Fn(f64) -> std::result::Result<js_sys::Promise, JsValue>>,
        #[serde(
            rename = "getScriptName",
            serialize_with = "Ns::__TSB__serialize_get_script_name",
            deserialize_with = "Ns::__TSB__deserialize_get_script_name"
        )]
        pub get_script_name: std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
        #[serde(rename = "ui")]
        pub ui: UserInterface,
        #[serde(
            rename = "clear",
            serialize_with = "Ns::__TSB__serialize_clear",
            deserialize_with = "Ns::__TSB__deserialize_clear"
        )]
        pub clear: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "hasTorRouter",
            serialize_with = "Ns::__TSB__serialize_has_tor_router",
            deserialize_with = "Ns::__TSB__deserialize_has_tor_router"
        )]
        pub has_tor_router: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "clearPort",
            serialize_with = "Ns::__TSB__serialize_clear_port",
            deserialize_with = "Ns::__TSB__deserialize_clear_port"
        )]
        pub clear_port: std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
        #[serde(rename = "corporation")]
        pub corporation: Corporation,
        #[serde(
            rename = "getScriptRam",
            serialize_with = "Ns::__TSB__serialize_get_script_ram",
            deserialize_with = "Ns::__TSB__deserialize_get_script_ram"
        )]
        pub get_script_ram:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "nuke",
            serialize_with = "Ns::__TSB__serialize_nuke",
            deserialize_with = "Ns::__TSB__deserialize_nuke"
        )]
        pub nuke: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        #[serde(rename = "stanek")]
        pub stanek: Stanek,
        #[serde(rename = "sleeve")]
        pub sleeve: Sleeve,
        #[serde(
            rename = "moveTail",
            serialize_with = "Ns::__TSB__serialize_move_tail",
            deserialize_with = "Ns::__TSB__deserialize_move_tail"
        )]
        pub move_tail: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "getBitNodeMultipliers",
            serialize_with = "Ns::__TSB__serialize_get_bit_node_multipliers",
            deserialize_with = "Ns::__TSB__deserialize_get_bit_node_multipliers"
        )]
        pub get_bit_node_multipliers:
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<BitNodeMultipliers, JsValue>>,
        #[serde(
            rename = "formatPercent",
            serialize_with = "Ns::__TSB__serialize_format_percent",
            deserialize_with = "Ns::__TSB__deserialize_format_percent"
        )]
        pub format_percent:
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<String, JsValue>>,
        #[serde(rename = "hacknet")]
        pub hacknet: Hacknet,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait Ns_Trait {
        fn set_get_server_used_ram(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_server_used_ram(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_read(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn read(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
            JsValue,
        >;
        fn set_weaken(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn weaken(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            JsValue,
        >;
        fn set_relaysmtp(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn relaysmtp(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_server_exists(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn server_exists(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_codingcontract(&mut self, value: CodingContract)
            -> std::result::Result<(), JsValue>;
        fn codingcontract(&self) -> std::result::Result<CodingContract, JsValue>;
        fn set_exec(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    NsExecParamsThreadOrOptions,
                    Vec<NsExecParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn exec(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    NsExecParamsThreadOrOptions,
                    Vec<NsExecParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
            JsValue,
        >;
        fn set_killall(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn killall(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_clear(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn clear(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_get_purchased_server_max_ram(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_purchased_server_max_ram(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_get_hacknet_multipliers(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<HacknetMultipliers, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_hacknet_multipliers(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<HacknetMultipliers, JsValue>>,
            JsValue,
        >;
        fn set_get_server(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<Server, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_server(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Server, JsValue>>,
            JsValue,
        >;
        fn set_get_purchased_server_limit(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_purchased_server_limit(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_is_log_enabled(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn is_log_enabled(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_hostname(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_hostname(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
            JsValue,
        >;
        fn set_enable_log(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn enable_log(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_sqlinject(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn sqlinject(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_disable_log(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn disable_log(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_infiltration(&mut self, value: Infiltration) -> std::result::Result<(), JsValue>;
        fn infiltration(&self) -> std::result::Result<Infiltration, JsValue>;
        fn set_write_port(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    f64,
                    NsWritePortParamsData,
                ) -> std::result::Result<NsWritePortReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn write_port(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    f64,
                    NsWritePortParamsData,
                ) -> std::result::Result<NsWritePortReturn, JsValue>,
            >,
            JsValue,
        >;
        fn set_get_purchased_servers(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_purchased_servers(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_nuke(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn nuke(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_get_server_growth(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_server_growth(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_spawn(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    NsSpawnParamsThreadOrOptions,
                    Vec<NsSpawnParamsArgs>,
                ) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn spawn(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    NsSpawnParamsThreadOrOptions,
                    Vec<NsSpawnParamsArgs>,
                ) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        >;
        fn set_get_server_min_security_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_server_min_security_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_t_format(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, bool) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn t_format(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, bool) -> std::result::Result<String, JsValue>>,
            JsValue,
        >;
        fn set_hack_analyze(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn hack_analyze(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_hack_analyze_threads(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn hack_analyze_threads(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_ls(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn ls(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_move_tail(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn move_tail(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_get_server_base_security_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_server_base_security_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_recent_scripts(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<RecentScript>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_recent_scripts(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<RecentScript>, JsValue>>,
            JsValue,
        >;
        fn set_get_server_money_available(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_server_money_available(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_wget(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, String, String) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn wget(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, String, String) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            JsValue,
        >;
        fn set_vsprintf(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, Vec<JsValue>) -> std::result::Result<String, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn vsprintf(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<String, JsValue>>,
            JsValue,
        >;
        fn set_sprintf(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, Vec<JsValue>) -> std::result::Result<String, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn sprintf(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<String, JsValue>>,
            JsValue,
        >;
        fn set_stock(&mut self, value: Tix) -> std::result::Result<(), JsValue>;
        fn stock(&self) -> std::result::Result<Tix, JsValue>;
        fn set_purchase_server(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn purchase_server(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<String, JsValue>>,
            JsValue,
        >;
        fn set_get_port_handle(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<NetscriptPort, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_port_handle(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<NetscriptPort, JsValue>>,
            JsValue,
        >;
        fn set_get_server_max_ram(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_server_max_ram(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_player(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Player, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_player(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Player, JsValue>>,
            JsValue,
        >;
        fn set_get_running_script(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    FilenameOrPid,
                    String,
                    Vec<NsGetRunningScriptParamsArgs>,
                ) -> std::result::Result<NsGetRunningScriptReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_running_script(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    FilenameOrPid,
                    String,
                    Vec<NsGetRunningScriptParamsArgs>,
                ) -> std::result::Result<NsGetRunningScriptReturn, JsValue>,
            >,
            JsValue,
        >;
        fn set_weaken_analyze(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn weaken_analyze(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_prompt(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    NsPromptParamsOptions,
                ) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn prompt(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    NsPromptParamsOptions,
                ) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            JsValue,
        >;
        fn set_ftpcrack(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn ftpcrack(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_read_port(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<PortData, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn read_port(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<PortData, JsValue>>,
            JsValue,
        >;
        fn set_get_share_power(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_share_power(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_rm(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn rm(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_server_num_ports_required(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_server_num_ports_required(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_run(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    NsRunParamsThreadOrOptions,
                    Vec<NsRunParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn run(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    NsRunParamsThreadOrOptions,
                    Vec<NsRunParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
            JsValue,
        >;
        fn set_tprint(
            &mut self,
            value: std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn tprint(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_print(
            &mut self,
            value: std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn print(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_get_function_ram_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_function_ram_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_growth_analyze_security(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn growth_analyze_security(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_singularity(&mut self, value: Singularity) -> std::result::Result<(), JsValue>;
        fn singularity(&self) -> std::result::Result<Singularity, JsValue>;
        fn set_close_tail(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn close_tail(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_get_script_exp_gain(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    Vec<NsGetScriptExpGainParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_script_exp_gain(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    Vec<NsGetScriptExpGainParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
            JsValue,
        >;
        fn set_scp(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(NsScpParamsFiles, String, String) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn scp(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(NsScpParamsFiles, String, String) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        >;
        fn set_ui(&mut self, value: UserInterface) -> std::result::Result<(), JsValue>;
        fn ui(&self) -> std::result::Result<UserInterface, JsValue>;
        fn set_growth_analyze(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn growth_analyze(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_script_logs(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    Vec<NsGetScriptLogsParamsArgs>,
                ) -> std::result::Result<Vec<String>, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_script_logs(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    Vec<NsGetScriptLogsParamsArgs>,
                ) -> std::result::Result<Vec<String>, JsValue>,
            >,
            JsValue,
        >;
        fn set_hack_analyze_security(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn hack_analyze_security(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_args(&mut self, value: Vec<NsArgs>) -> std::result::Result<(), JsValue>;
        fn args(&self) -> std::result::Result<Vec<NsArgs>, JsValue>;
        fn set_write(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, String, NsWriteParamsMode) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn write(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, String, NsWriteParamsMode) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        >;
        fn set_get_total_script_income(
            &mut self,
            value: std::rc::Rc<
                dyn Fn() -> std::result::Result<NsGetTotalScriptIncomeReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_total_script_income(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<NsGetTotalScriptIncomeReturn, JsValue>>,
            JsValue,
        >;
        fn set_tail(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    FilenameOrPid,
                    String,
                    Vec<NsTailParamsArgs>,
                ) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn tail(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    FilenameOrPid,
                    String,
                    Vec<NsTailParamsArgs>,
                ) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        >;
        fn set_get_bit_node_multipliers(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(f64, f64) -> std::result::Result<BitNodeMultipliers, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_bit_node_multipliers(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<BitNodeMultipliers, JsValue>>,
            JsValue,
        >;
        fn set_hacknet(&mut self, value: Hacknet) -> std::result::Result<(), JsValue>;
        fn hacknet(&self) -> std::result::Result<Hacknet, JsValue>;
        fn set_format_number(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64, bool) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn format_number(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64, bool) -> std::result::Result<String, JsValue>>,
            JsValue,
        >;
        fn set_stanek(&mut self, value: Stanek) -> std::result::Result<(), JsValue>;
        fn stanek(&self) -> std::result::Result<Stanek, JsValue>;
        fn set_has_tor_router(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn has_tor_router(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_asleep(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<js_sys::Promise, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn asleep(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<js_sys::Promise, JsValue>>,
            JsValue,
        >;
        fn set_get_script_name(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_script_name(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
            JsValue,
        >;
        fn set_get_total_script_exp_gain(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_total_script_exp_gain(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_delete_server(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn delete_server(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_server_max_money(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_server_max_money(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_script_kill(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn script_kill(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_httpworm(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn httpworm(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_sleep(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<js_sys::Promise, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn sleep(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<js_sys::Promise, JsValue>>,
            JsValue,
        >;
        fn set_format_ram(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn format_ram(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<String, JsValue>>,
            JsValue,
        >;
        fn set_get_time_since_last_aug(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_time_since_last_aug(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_get_purchased_server_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_purchased_server_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_bladeburner(&mut self, value: Bladeburner) -> std::result::Result<(), JsValue>;
        fn bladeburner(&self) -> std::result::Result<Bladeburner, JsValue>;
        fn set_alert(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn alert(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_grafting(&mut self, value: Grafting) -> std::result::Result<(), JsValue>;
        fn grafting(&self) -> std::result::Result<Grafting, JsValue>;
        fn set_brutessh(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn brutessh(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_clear_port(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn clear_port(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_hack(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn hack(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            JsValue,
        >;
        fn set_resize_tail(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn resize_tail(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_pid(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn pid(&self) -> std::result::Result<f64, JsValue>;
        fn set_ps(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<ProcessInfo>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn ps(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<ProcessInfo>, JsValue>>,
            JsValue,
        >;
        fn set_scan(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn scan(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_get_weaken_time(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_weaken_time(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_favor_to_donate(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_favor_to_donate(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_corporation(&mut self, value: Corporation) -> std::result::Result<(), JsValue>;
        fn corporation(&self) -> std::result::Result<Corporation, JsValue>;
        fn set_get_server_security_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_server_security_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_kill(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, String, Vec<ScriptArg>) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn kill(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, String, Vec<ScriptArg>) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        >;
        fn set_get_grow_time(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_grow_time(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_enums(&mut self, value: NsEnums) -> std::result::Result<(), JsValue>;
        fn enums(&self) -> std::result::Result<NsEnums, JsValue>;
        fn set_clear_log(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn clear_log(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, JsValue>;
        fn set_get_purchased_server_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_purchased_server_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_printf(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn printf(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_get_hacking_level(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_hacking_level(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_get_reset_info(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<ResetInfo, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_reset_info(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<ResetInfo, JsValue>>,
            JsValue,
        >;
        fn set_formulas(&mut self, value: Formulas) -> std::result::Result<(), JsValue>;
        fn formulas(&self) -> std::result::Result<Formulas, JsValue>;
        fn set_try_write_port(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(f64, NsTryWritePortParamsData) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn try_write_port(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(f64, NsTryWritePortParamsData) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        >;
        fn set_has_root_access(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn has_root_access(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_upgrade_purchased_server(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn upgrade_purchased_server(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_hack_time(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_hack_time(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_rename_purchased_server(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn rename_purchased_server(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_script_income(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    Vec<NsGetScriptIncomeParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_script_income(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    Vec<NsGetScriptIncomeParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
            JsValue,
        >;
        fn set_n_format(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn n_format(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<String, JsValue>>,
            JsValue,
        >;
        fn set_format_percent(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn format_percent(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<String, JsValue>>,
            JsValue,
        >;
        fn set_tprintf(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn tprintf(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_sleeve(&mut self, value: Sleeve) -> std::result::Result<(), JsValue>;
        fn sleeve(&self) -> std::result::Result<Sleeve, JsValue>;
        fn set_flags(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    Vec<NsFlagsParamsSchema>,
                ) -> std::result::Result<
                    std::collections::HashMap<String, NsFlagsReturn>,
                    JsValue,
                >,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn flags(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    Vec<NsFlagsParamsSchema>,
                ) -> std::result::Result<
                    std::collections::HashMap<String, NsFlagsReturn>,
                    JsValue,
                >,
            >,
            JsValue,
        >;
        fn set_hack_analyze_chance(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn hack_analyze_chance(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_peek(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<PortData, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn peek(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<PortData, JsValue>>,
            JsValue,
        >;
        fn set_get_hacking_multipliers(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<HackingMultipliers, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_hacking_multipliers(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<HackingMultipliers, JsValue>>,
            JsValue,
        >;
        fn set_get_script_ram(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_script_ram(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_script_running(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn script_running(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_is_running(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    FilenameOrPid,
                    String,
                    Vec<NsIsRunningParamsArgs>,
                ) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn is_running(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    FilenameOrPid,
                    String,
                    Vec<NsIsRunningParamsArgs>,
                ) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        >;
        fn set_share(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn share(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
            JsValue,
        >;
        fn set_toast(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    ToastVariant,
                    NsToastParamsDuration,
                ) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn toast(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    ToastVariant,
                    NsToastParamsDuration,
                ) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        >;
        fn set_get_money_sources(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<MoneySources, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_money_sources(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<MoneySources, JsValue>>,
            JsValue,
        >;
        fn set_file_exists(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn file_exists(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_server_required_hacking_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_server_required_hacking_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_mv(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn mv(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_gang(&mut self, value: Gang) -> std::result::Result<(), JsValue>;
        fn gang(&self) -> std::result::Result<Gang, JsValue>;
        fn set_grow(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn grow(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            JsValue,
        >;
    }
    impl Ns_Trait for Ns {
        fn set_get_server_used_ram(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_server_used_ram = value;
            Ok(())
        }
        fn get_server_used_ram(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_server_used_ram.clone())
        }
        fn set_read(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.read = value;
            Ok(())
        }
        fn read(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
            JsValue,
        > {
            Ok(self.read.clone())
        }
        fn set_weaken(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.weaken = value;
            Ok(())
        }
        fn weaken(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.weaken.clone())
        }
        fn set_relaysmtp(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.relaysmtp = value;
            Ok(())
        }
        fn relaysmtp(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.relaysmtp.clone())
        }
        fn set_server_exists(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.server_exists = value;
            Ok(())
        }
        fn server_exists(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.server_exists.clone())
        }
        fn set_codingcontract(
            &mut self,
            value: CodingContract,
        ) -> std::result::Result<(), JsValue> {
            self.codingcontract = value;
            Ok(())
        }
        fn codingcontract(&self) -> std::result::Result<CodingContract, JsValue> {
            Ok(self.codingcontract.clone())
        }
        fn set_exec(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    NsExecParamsThreadOrOptions,
                    Vec<NsExecParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.exec = value;
            Ok(())
        }
        fn exec(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    NsExecParamsThreadOrOptions,
                    Vec<NsExecParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.exec.clone())
        }
        fn set_killall(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.killall = value;
            Ok(())
        }
        fn killall(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.killall.clone())
        }
        fn set_clear(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.clear = value;
            Ok(())
        }
        fn clear(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.clear.clone())
        }
        fn set_get_purchased_server_max_ram(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_purchased_server_max_ram = value;
            Ok(())
        }
        fn get_purchased_server_max_ram(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_purchased_server_max_ram.clone())
        }
        fn set_get_hacknet_multipliers(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<HacknetMultipliers, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_hacknet_multipliers = value;
            Ok(())
        }
        fn get_hacknet_multipliers(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<HacknetMultipliers, JsValue>>,
            JsValue,
        > {
            Ok(self.get_hacknet_multipliers.clone())
        }
        fn set_get_server(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<Server, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_server = value;
            Ok(())
        }
        fn get_server(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Server, JsValue>>,
            JsValue,
        > {
            Ok(self.get_server.clone())
        }
        fn set_get_purchased_server_limit(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_purchased_server_limit = value;
            Ok(())
        }
        fn get_purchased_server_limit(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_purchased_server_limit.clone())
        }
        fn set_is_log_enabled(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.is_log_enabled = value;
            Ok(())
        }
        fn is_log_enabled(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.is_log_enabled.clone())
        }
        fn set_get_hostname(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_hostname = value;
            Ok(())
        }
        fn get_hostname(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
            JsValue,
        > {
            Ok(self.get_hostname.clone())
        }
        fn set_enable_log(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.enable_log = value;
            Ok(())
        }
        fn enable_log(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.enable_log.clone())
        }
        fn set_sqlinject(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.sqlinject = value;
            Ok(())
        }
        fn sqlinject(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.sqlinject.clone())
        }
        fn set_disable_log(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.disable_log = value;
            Ok(())
        }
        fn disable_log(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.disable_log.clone())
        }
        fn set_infiltration(&mut self, value: Infiltration) -> std::result::Result<(), JsValue> {
            self.infiltration = value;
            Ok(())
        }
        fn infiltration(&self) -> std::result::Result<Infiltration, JsValue> {
            Ok(self.infiltration.clone())
        }
        fn set_write_port(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    f64,
                    NsWritePortParamsData,
                ) -> std::result::Result<NsWritePortReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.write_port = value;
            Ok(())
        }
        fn write_port(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    f64,
                    NsWritePortParamsData,
                ) -> std::result::Result<NsWritePortReturn, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.write_port.clone())
        }
        fn set_get_purchased_servers(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_purchased_servers = value;
            Ok(())
        }
        fn get_purchased_servers(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_purchased_servers.clone())
        }
        fn set_nuke(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.nuke = value;
            Ok(())
        }
        fn nuke(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.nuke.clone())
        }
        fn set_get_server_growth(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_server_growth = value;
            Ok(())
        }
        fn get_server_growth(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_server_growth.clone())
        }
        fn set_spawn(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    NsSpawnParamsThreadOrOptions,
                    Vec<NsSpawnParamsArgs>,
                ) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.spawn = value;
            Ok(())
        }
        fn spawn(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    NsSpawnParamsThreadOrOptions,
                    Vec<NsSpawnParamsArgs>,
                ) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        > {
            Ok(self.spawn.clone())
        }
        fn set_get_server_min_security_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_server_min_security_level = value;
            Ok(())
        }
        fn get_server_min_security_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_server_min_security_level.clone())
        }
        fn set_t_format(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, bool) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.t_format = value;
            Ok(())
        }
        fn t_format(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, bool) -> std::result::Result<String, JsValue>>,
            JsValue,
        > {
            Ok(self.t_format.clone())
        }
        fn set_hack_analyze(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.hack_analyze = value;
            Ok(())
        }
        fn hack_analyze(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.hack_analyze.clone())
        }
        fn set_hack_analyze_threads(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.hack_analyze_threads = value;
            Ok(())
        }
        fn hack_analyze_threads(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.hack_analyze_threads.clone())
        }
        fn set_ls(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.ls = value;
            Ok(())
        }
        fn ls(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.ls.clone())
        }
        fn set_move_tail(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.move_tail = value;
            Ok(())
        }
        fn move_tail(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.move_tail.clone())
        }
        fn set_get_server_base_security_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_server_base_security_level = value;
            Ok(())
        }
        fn get_server_base_security_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_server_base_security_level.clone())
        }
        fn set_get_recent_scripts(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<RecentScript>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_recent_scripts = value;
            Ok(())
        }
        fn get_recent_scripts(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<RecentScript>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_recent_scripts.clone())
        }
        fn set_get_server_money_available(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_server_money_available = value;
            Ok(())
        }
        fn get_server_money_available(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_server_money_available.clone())
        }
        fn set_wget(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, String, String) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.wget = value;
            Ok(())
        }
        fn wget(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, String, String) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.wget.clone())
        }
        fn set_vsprintf(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, Vec<JsValue>) -> std::result::Result<String, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.vsprintf = value;
            Ok(())
        }
        fn vsprintf(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<String, JsValue>>,
            JsValue,
        > {
            Ok(self.vsprintf.clone())
        }
        fn set_sprintf(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, Vec<JsValue>) -> std::result::Result<String, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.sprintf = value;
            Ok(())
        }
        fn sprintf(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<String, JsValue>>,
            JsValue,
        > {
            Ok(self.sprintf.clone())
        }
        fn set_stock(&mut self, value: Tix) -> std::result::Result<(), JsValue> {
            self.stock = value;
            Ok(())
        }
        fn stock(&self) -> std::result::Result<Tix, JsValue> {
            Ok(self.stock.clone())
        }
        fn set_purchase_server(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.purchase_server = value;
            Ok(())
        }
        fn purchase_server(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<String, JsValue>>,
            JsValue,
        > {
            Ok(self.purchase_server.clone())
        }
        fn set_get_port_handle(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<NetscriptPort, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_port_handle = value;
            Ok(())
        }
        fn get_port_handle(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<NetscriptPort, JsValue>>,
            JsValue,
        > {
            Ok(self.get_port_handle.clone())
        }
        fn set_get_server_max_ram(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_server_max_ram = value;
            Ok(())
        }
        fn get_server_max_ram(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_server_max_ram.clone())
        }
        fn set_get_player(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Player, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_player = value;
            Ok(())
        }
        fn get_player(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Player, JsValue>>,
            JsValue,
        > {
            Ok(self.get_player.clone())
        }
        fn set_get_running_script(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    FilenameOrPid,
                    String,
                    Vec<NsGetRunningScriptParamsArgs>,
                ) -> std::result::Result<NsGetRunningScriptReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_running_script = value;
            Ok(())
        }
        fn get_running_script(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    FilenameOrPid,
                    String,
                    Vec<NsGetRunningScriptParamsArgs>,
                ) -> std::result::Result<NsGetRunningScriptReturn, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.get_running_script.clone())
        }
        fn set_weaken_analyze(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.weaken_analyze = value;
            Ok(())
        }
        fn weaken_analyze(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.weaken_analyze.clone())
        }
        fn set_prompt(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    NsPromptParamsOptions,
                ) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.prompt = value;
            Ok(())
        }
        fn prompt(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    NsPromptParamsOptions,
                ) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.prompt.clone())
        }
        fn set_ftpcrack(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.ftpcrack = value;
            Ok(())
        }
        fn ftpcrack(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.ftpcrack.clone())
        }
        fn set_read_port(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<PortData, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.read_port = value;
            Ok(())
        }
        fn read_port(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<PortData, JsValue>>,
            JsValue,
        > {
            Ok(self.read_port.clone())
        }
        fn set_get_share_power(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_share_power = value;
            Ok(())
        }
        fn get_share_power(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_share_power.clone())
        }
        fn set_rm(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.rm = value;
            Ok(())
        }
        fn rm(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.rm.clone())
        }
        fn set_get_server_num_ports_required(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_server_num_ports_required = value;
            Ok(())
        }
        fn get_server_num_ports_required(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_server_num_ports_required.clone())
        }
        fn set_run(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    NsRunParamsThreadOrOptions,
                    Vec<NsRunParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.run = value;
            Ok(())
        }
        fn run(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    NsRunParamsThreadOrOptions,
                    Vec<NsRunParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.run.clone())
        }
        fn set_tprint(
            &mut self,
            value: std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.tprint = value;
            Ok(())
        }
        fn tprint(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.tprint.clone())
        }
        fn set_print(
            &mut self,
            value: std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.print = value;
            Ok(())
        }
        fn print(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.print.clone())
        }
        fn set_get_function_ram_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_function_ram_cost = value;
            Ok(())
        }
        fn get_function_ram_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_function_ram_cost.clone())
        }
        fn set_growth_analyze_security(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.growth_analyze_security = value;
            Ok(())
        }
        fn growth_analyze_security(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.growth_analyze_security.clone())
        }
        fn set_singularity(&mut self, value: Singularity) -> std::result::Result<(), JsValue> {
            self.singularity = value;
            Ok(())
        }
        fn singularity(&self) -> std::result::Result<Singularity, JsValue> {
            Ok(self.singularity.clone())
        }
        fn set_close_tail(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.close_tail = value;
            Ok(())
        }
        fn close_tail(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.close_tail.clone())
        }
        fn set_get_script_exp_gain(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    Vec<NsGetScriptExpGainParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_script_exp_gain = value;
            Ok(())
        }
        fn get_script_exp_gain(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    Vec<NsGetScriptExpGainParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.get_script_exp_gain.clone())
        }
        fn set_scp(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(NsScpParamsFiles, String, String) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.scp = value;
            Ok(())
        }
        fn scp(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(NsScpParamsFiles, String, String) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.scp.clone())
        }
        fn set_ui(&mut self, value: UserInterface) -> std::result::Result<(), JsValue> {
            self.ui = value;
            Ok(())
        }
        fn ui(&self) -> std::result::Result<UserInterface, JsValue> {
            Ok(self.ui.clone())
        }
        fn set_growth_analyze(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.growth_analyze = value;
            Ok(())
        }
        fn growth_analyze(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.growth_analyze.clone())
        }
        fn set_get_script_logs(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    Vec<NsGetScriptLogsParamsArgs>,
                ) -> std::result::Result<Vec<String>, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_script_logs = value;
            Ok(())
        }
        fn get_script_logs(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    Vec<NsGetScriptLogsParamsArgs>,
                ) -> std::result::Result<Vec<String>, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.get_script_logs.clone())
        }
        fn set_hack_analyze_security(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.hack_analyze_security = value;
            Ok(())
        }
        fn hack_analyze_security(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.hack_analyze_security.clone())
        }
        fn set_args(&mut self, value: Vec<NsArgs>) -> std::result::Result<(), JsValue> {
            self.args = value;
            Ok(())
        }
        fn args(&self) -> std::result::Result<Vec<NsArgs>, JsValue> {
            Ok(self.args.clone())
        }
        fn set_write(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, String, NsWriteParamsMode) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.write = value;
            Ok(())
        }
        fn write(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, String, NsWriteParamsMode) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        > {
            Ok(self.write.clone())
        }
        fn set_get_total_script_income(
            &mut self,
            value: std::rc::Rc<
                dyn Fn() -> std::result::Result<NsGetTotalScriptIncomeReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_total_script_income = value;
            Ok(())
        }
        fn get_total_script_income(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<NsGetTotalScriptIncomeReturn, JsValue>>,
            JsValue,
        > {
            Ok(self.get_total_script_income.clone())
        }
        fn set_tail(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    FilenameOrPid,
                    String,
                    Vec<NsTailParamsArgs>,
                ) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.tail = value;
            Ok(())
        }
        fn tail(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    FilenameOrPid,
                    String,
                    Vec<NsTailParamsArgs>,
                ) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        > {
            Ok(self.tail.clone())
        }
        fn set_get_bit_node_multipliers(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(f64, f64) -> std::result::Result<BitNodeMultipliers, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_bit_node_multipliers = value;
            Ok(())
        }
        fn get_bit_node_multipliers(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<BitNodeMultipliers, JsValue>>,
            JsValue,
        > {
            Ok(self.get_bit_node_multipliers.clone())
        }
        fn set_hacknet(&mut self, value: Hacknet) -> std::result::Result<(), JsValue> {
            self.hacknet = value;
            Ok(())
        }
        fn hacknet(&self) -> std::result::Result<Hacknet, JsValue> {
            Ok(self.hacknet.clone())
        }
        fn set_format_number(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64, bool) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.format_number = value;
            Ok(())
        }
        fn format_number(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64, bool) -> std::result::Result<String, JsValue>>,
            JsValue,
        > {
            Ok(self.format_number.clone())
        }
        fn set_stanek(&mut self, value: Stanek) -> std::result::Result<(), JsValue> {
            self.stanek = value;
            Ok(())
        }
        fn stanek(&self) -> std::result::Result<Stanek, JsValue> {
            Ok(self.stanek.clone())
        }
        fn set_has_tor_router(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.has_tor_router = value;
            Ok(())
        }
        fn has_tor_router(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.has_tor_router.clone())
        }
        fn set_asleep(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<js_sys::Promise, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.asleep = value;
            Ok(())
        }
        fn asleep(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<js_sys::Promise, JsValue>>,
            JsValue,
        > {
            Ok(self.asleep.clone())
        }
        fn set_get_script_name(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_script_name = value;
            Ok(())
        }
        fn get_script_name(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
            JsValue,
        > {
            Ok(self.get_script_name.clone())
        }
        fn set_get_total_script_exp_gain(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_total_script_exp_gain = value;
            Ok(())
        }
        fn get_total_script_exp_gain(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_total_script_exp_gain.clone())
        }
        fn set_delete_server(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.delete_server = value;
            Ok(())
        }
        fn delete_server(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.delete_server.clone())
        }
        fn set_get_server_max_money(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_server_max_money = value;
            Ok(())
        }
        fn get_server_max_money(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_server_max_money.clone())
        }
        fn set_script_kill(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.script_kill = value;
            Ok(())
        }
        fn script_kill(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.script_kill.clone())
        }
        fn set_httpworm(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.httpworm = value;
            Ok(())
        }
        fn httpworm(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.httpworm.clone())
        }
        fn set_sleep(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<js_sys::Promise, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.sleep = value;
            Ok(())
        }
        fn sleep(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<js_sys::Promise, JsValue>>,
            JsValue,
        > {
            Ok(self.sleep.clone())
        }
        fn set_format_ram(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.format_ram = value;
            Ok(())
        }
        fn format_ram(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<String, JsValue>>,
            JsValue,
        > {
            Ok(self.format_ram.clone())
        }
        fn set_get_time_since_last_aug(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_time_since_last_aug = value;
            Ok(())
        }
        fn get_time_since_last_aug(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_time_since_last_aug.clone())
        }
        fn set_get_purchased_server_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_purchased_server_upgrade_cost = value;
            Ok(())
        }
        fn get_purchased_server_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_purchased_server_upgrade_cost.clone())
        }
        fn set_bladeburner(&mut self, value: Bladeburner) -> std::result::Result<(), JsValue> {
            self.bladeburner = value;
            Ok(())
        }
        fn bladeburner(&self) -> std::result::Result<Bladeburner, JsValue> {
            Ok(self.bladeburner.clone())
        }
        fn set_alert(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.alert = value;
            Ok(())
        }
        fn alert(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.alert.clone())
        }
        fn set_grafting(&mut self, value: Grafting) -> std::result::Result<(), JsValue> {
            self.grafting = value;
            Ok(())
        }
        fn grafting(&self) -> std::result::Result<Grafting, JsValue> {
            Ok(self.grafting.clone())
        }
        fn set_brutessh(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.brutessh = value;
            Ok(())
        }
        fn brutessh(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.brutessh.clone())
        }
        fn set_clear_port(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.clear_port = value;
            Ok(())
        }
        fn clear_port(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.clear_port.clone())
        }
        fn set_hack(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.hack = value;
            Ok(())
        }
        fn hack(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.hack.clone())
        }
        fn set_resize_tail(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.resize_tail = value;
            Ok(())
        }
        fn resize_tail(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.resize_tail.clone())
        }
        fn set_pid(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.pid = value;
            Ok(())
        }
        fn pid(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.pid)
        }
        fn set_ps(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<ProcessInfo>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.ps = value;
            Ok(())
        }
        fn ps(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<ProcessInfo>, JsValue>>,
            JsValue,
        > {
            Ok(self.ps.clone())
        }
        fn set_scan(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.scan = value;
            Ok(())
        }
        fn scan(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.scan.clone())
        }
        fn set_get_weaken_time(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_weaken_time = value;
            Ok(())
        }
        fn get_weaken_time(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_weaken_time.clone())
        }
        fn set_get_favor_to_donate(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_favor_to_donate = value;
            Ok(())
        }
        fn get_favor_to_donate(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_favor_to_donate.clone())
        }
        fn set_corporation(&mut self, value: Corporation) -> std::result::Result<(), JsValue> {
            self.corporation = value;
            Ok(())
        }
        fn corporation(&self) -> std::result::Result<Corporation, JsValue> {
            Ok(self.corporation.clone())
        }
        fn set_get_server_security_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_server_security_level = value;
            Ok(())
        }
        fn get_server_security_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_server_security_level.clone())
        }
        fn set_kill(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, String, Vec<ScriptArg>) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.kill = value;
            Ok(())
        }
        fn kill(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, String, Vec<ScriptArg>) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.kill.clone())
        }
        fn set_get_grow_time(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_grow_time = value;
            Ok(())
        }
        fn get_grow_time(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_grow_time.clone())
        }
        fn set_enums(&mut self, value: NsEnums) -> std::result::Result<(), JsValue> {
            self.enums = value;
            Ok(())
        }
        fn enums(&self) -> std::result::Result<NsEnums, JsValue> {
            Ok(self.enums.clone())
        }
        fn set_clear_log(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.clear_log = value;
            Ok(())
        }
        fn clear_log(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, JsValue>
        {
            Ok(self.clear_log.clone())
        }
        fn set_get_purchased_server_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_purchased_server_cost = value;
            Ok(())
        }
        fn get_purchased_server_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_purchased_server_cost.clone())
        }
        fn set_printf(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.printf = value;
            Ok(())
        }
        fn printf(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.printf.clone())
        }
        fn set_get_hacking_level(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_hacking_level = value;
            Ok(())
        }
        fn get_hacking_level(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_hacking_level.clone())
        }
        fn set_get_reset_info(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<ResetInfo, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_reset_info = value;
            Ok(())
        }
        fn get_reset_info(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<ResetInfo, JsValue>>,
            JsValue,
        > {
            Ok(self.get_reset_info.clone())
        }
        fn set_formulas(&mut self, value: Formulas) -> std::result::Result<(), JsValue> {
            self.formulas = value;
            Ok(())
        }
        fn formulas(&self) -> std::result::Result<Formulas, JsValue> {
            Ok(self.formulas.clone())
        }
        fn set_try_write_port(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(f64, NsTryWritePortParamsData) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.try_write_port = value;
            Ok(())
        }
        fn try_write_port(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(f64, NsTryWritePortParamsData) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.try_write_port.clone())
        }
        fn set_has_root_access(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.has_root_access = value;
            Ok(())
        }
        fn has_root_access(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.has_root_access.clone())
        }
        fn set_upgrade_purchased_server(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.upgrade_purchased_server = value;
            Ok(())
        }
        fn upgrade_purchased_server(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.upgrade_purchased_server.clone())
        }
        fn set_get_hack_time(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_hack_time = value;
            Ok(())
        }
        fn get_hack_time(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_hack_time.clone())
        }
        fn set_rename_purchased_server(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.rename_purchased_server = value;
            Ok(())
        }
        fn rename_purchased_server(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.rename_purchased_server.clone())
        }
        fn set_get_script_income(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    Vec<NsGetScriptIncomeParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_script_income = value;
            Ok(())
        }
        fn get_script_income(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    Vec<NsGetScriptIncomeParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.get_script_income.clone())
        }
        fn set_n_format(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.n_format = value;
            Ok(())
        }
        fn n_format(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<String, JsValue>>,
            JsValue,
        > {
            Ok(self.n_format.clone())
        }
        fn set_format_percent(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.format_percent = value;
            Ok(())
        }
        fn format_percent(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<String, JsValue>>,
            JsValue,
        > {
            Ok(self.format_percent.clone())
        }
        fn set_tprintf(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.tprintf = value;
            Ok(())
        }
        fn tprintf(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.tprintf.clone())
        }
        fn set_sleeve(&mut self, value: Sleeve) -> std::result::Result<(), JsValue> {
            self.sleeve = value;
            Ok(())
        }
        fn sleeve(&self) -> std::result::Result<Sleeve, JsValue> {
            Ok(self.sleeve.clone())
        }
        fn set_flags(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    Vec<NsFlagsParamsSchema>,
                ) -> std::result::Result<
                    std::collections::HashMap<String, NsFlagsReturn>,
                    JsValue,
                >,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.flags = value;
            Ok(())
        }
        fn flags(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    Vec<NsFlagsParamsSchema>,
                ) -> std::result::Result<
                    std::collections::HashMap<String, NsFlagsReturn>,
                    JsValue,
                >,
            >,
            JsValue,
        > {
            Ok(self.flags.clone())
        }
        fn set_hack_analyze_chance(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.hack_analyze_chance = value;
            Ok(())
        }
        fn hack_analyze_chance(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.hack_analyze_chance.clone())
        }
        fn set_peek(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<PortData, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.peek = value;
            Ok(())
        }
        fn peek(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<PortData, JsValue>>,
            JsValue,
        > {
            Ok(self.peek.clone())
        }
        fn set_get_hacking_multipliers(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<HackingMultipliers, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_hacking_multipliers = value;
            Ok(())
        }
        fn get_hacking_multipliers(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<HackingMultipliers, JsValue>>,
            JsValue,
        > {
            Ok(self.get_hacking_multipliers.clone())
        }
        fn set_get_script_ram(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_script_ram = value;
            Ok(())
        }
        fn get_script_ram(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_script_ram.clone())
        }
        fn set_script_running(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.script_running = value;
            Ok(())
        }
        fn script_running(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.script_running.clone())
        }
        fn set_is_running(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    FilenameOrPid,
                    String,
                    Vec<NsIsRunningParamsArgs>,
                ) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.is_running = value;
            Ok(())
        }
        fn is_running(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    FilenameOrPid,
                    String,
                    Vec<NsIsRunningParamsArgs>,
                ) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.is_running.clone())
        }
        fn set_share(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.share = value;
            Ok(())
        }
        fn share(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
            JsValue,
        > {
            Ok(self.share.clone())
        }
        fn set_toast(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    ToastVariant,
                    NsToastParamsDuration,
                ) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.toast = value;
            Ok(())
        }
        fn toast(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    ToastVariant,
                    NsToastParamsDuration,
                ) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        > {
            Ok(self.toast.clone())
        }
        fn set_get_money_sources(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<MoneySources, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_money_sources = value;
            Ok(())
        }
        fn get_money_sources(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<MoneySources, JsValue>>,
            JsValue,
        > {
            Ok(self.get_money_sources.clone())
        }
        fn set_file_exists(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.file_exists = value;
            Ok(())
        }
        fn file_exists(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.file_exists.clone())
        }
        fn set_get_server_required_hacking_level(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_server_required_hacking_level = value;
            Ok(())
        }
        fn get_server_required_hacking_level(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_server_required_hacking_level.clone())
        }
        fn set_mv(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String, String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.mv = value;
            Ok(())
        }
        fn mv(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.mv.clone())
        }
        fn set_gang(&mut self, value: Gang) -> std::result::Result<(), JsValue> {
            self.gang = value;
            Ok(())
        }
        fn gang(&self) -> std::result::Result<Gang, JsValue> {
            Ok(self.gang.clone())
        }
        fn set_grow(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.grow = value;
            Ok(())
        }
        fn grow(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.grow.clone())
        }
    }
    impl Ns {
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_function_ram_cost<S>(
            get_function_ram_cost: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_function_ram_cost = get_function_ram_cost.clone();
            let get_function_ram_cost_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_function_ram_cost(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_function_ram_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_format_ram<S>(
            format_ram: &std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<String, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let format_ram = format_ram.clone();
            let format_ram_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<String, JsValue> {
                    let result = format_ram(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<String, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &format_ram_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_rm<S>(
            rm: &std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let rm = rm.clone();
            let rm_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<bool, JsValue> {
                    let result = rm(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(serializer, &rm_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_upgrade_purchased_server<S>(
            upgrade_purchased_server: &std::rc::Rc<
                dyn Fn(String, f64) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let upgrade_purchased_server = upgrade_purchased_server.clone();
            let upgrade_purchased_server_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: f64| -> std::result::Result<bool, JsValue> {
                    let result = upgrade_purchased_server(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &upgrade_purchased_server_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_hack_time<S>(
            get_hack_time: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_hack_time = get_hack_time.clone();
            let get_hack_time_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_hack_time(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_hack_time_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_prompt<S>(
            prompt: &std::rc::Rc<
                dyn Fn(
                    String,
                    NsPromptParamsOptions,
                ) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let prompt = prompt.clone();
            let prompt_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue|
                      -> std::result::Result<js_sys::Promise, JsValue> {
                    let result = prompt(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue) -> std::result::Result<js_sys::Promise, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &prompt_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_server_max_money<S>(
            get_server_max_money: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_server_max_money = get_server_max_money.clone();
            let get_server_max_money_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_server_max_money(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_server_max_money_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_flags<S>(
            flags: &std::rc::Rc<
                dyn Fn(
                    Vec<NsFlagsParamsSchema>,
                ) -> std::result::Result<
                    std::collections::HashMap<String, NsFlagsReturn>,
                    JsValue,
                >,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let flags = flags.clone();
            let flags_closure = Closure::wrap(Box::new(
                move |arg0: JsValue| -> std::result::Result<
                    std::collections::HashMap<String, NsFlagsReturn>,
                    JsValue,
                > {
                    let result = flags({
                        let mut arg0_vec = vec![];
                        for arg0_item in arg0.iter() {
                            arg0_vec.push({
                                let mut arg0_item_vec = vec![];
                                let arg0_item_item_0 = arg0_item.get(0);
                                arg0_item_vec.push(&arg0_item_item_0);
                                let arg0_item_item_1 = arg0_item.get(1);
                                arg0_item_vec.push(
                                    &ts_bindgen_rt::from_jsvalue(&arg0_item_item_1)
                                        .map_err(ts_bindgen_rt::Error::from)?,
                                );
                                arg0_item_vec
                            });
                        }
                        arg0_vec
                    })?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        JsValue,
                    ) -> std::result::Result<
                        std::collections::HashMap<String, NsFlagsReturn>,
                        JsValue,
                    >,
                >);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &flags_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_growth_analyze<S>(
            growth_analyze: &std::rc::Rc<
                dyn Fn(String, f64, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let growth_analyze = growth_analyze.clone();
            let growth_analyze_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: f64, arg2: f64| -> std::result::Result<f64, JsValue> {
                    let result = growth_analyze(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &growth_analyze_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_has_root_access<S>(
            has_root_access: &std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let has_root_access = has_root_access.clone();
            let has_root_access_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<bool, JsValue> {
                    let result = has_root_access(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &has_root_access_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_tail<S>(
            tail: &std::rc::Rc<
                dyn Fn(
                    FilenameOrPid,
                    String,
                    Vec<NsTailParamsArgs>,
                ) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let tail = tail.clone();
            let tail_closure = Closure::wrap(Box::new(
                move |arg0: JsValue,
                      arg1: String,
                      _Variadic2_arg2: JsValue,
                      _Variadic3_arg2: JsValue,
                      _Variadic4_arg2: JsValue,
                      _Variadic5_arg2: JsValue,
                      _Variadic6_arg2: JsValue|
                      -> std::result::Result<(), JsValue> {
                    let arg2 = {
                        let arg2 = js_sys::Array::new();
                        arg2.push(&_Variadic2_arg2);
                        arg2.push(&_Variadic3_arg2);
                        arg2.push(&_Variadic4_arg2);
                        arg2.push(&_Variadic5_arg2);
                        arg2.push(&_Variadic6_arg2);
                        arg2
                    };
                    let result = tail(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        arg1,
                        {
                            let mut arg2_vec = vec![];
                            for arg2_item in arg2.iter() {
                                arg2_vec.push(
                                    ts_bindgen_rt::from_jsvalue(&arg2_item)
                                        .map_err(ts_bindgen_rt::Error::from)?,
                                );
                            }
                            arg2_vec
                        },
                    )?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        JsValue,
                        String,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                    ) -> std::result::Result<(), JsValue>,
                >);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &tail_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_hacking_level<S>(
            get_hacking_level: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_hacking_level = get_hacking_level.clone();
            let get_hacking_level_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_hacking_level()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_hacking_level_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_enable_log<S>(
            enable_log: &std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let enable_log = enable_log.clone();
            let enable_log_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<(), JsValue> {
                    let result = enable_log(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &enable_log_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_ftpcrack<S>(
            ftpcrack: &std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let ftpcrack = ftpcrack.clone();
            let ftpcrack_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<(), JsValue> {
                    let result = ftpcrack(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<(), JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &ftpcrack_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_total_script_income<S>(
            get_total_script_income: &std::rc::Rc<
                dyn Fn() -> std::result::Result<NsGetTotalScriptIncomeReturn, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_total_script_income = get_total_script_income.clone();
            let get_total_script_income_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_total_script_income()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        let result_item_0 = result.0;
                        result_array.push(&JsValue::from(result_item_0));
                        let result_item_1 = result.1;
                        result_array.push(&JsValue::from(result_item_1));
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_total_script_income_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_weaken_time<S>(
            get_weaken_time: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_weaken_time = get_weaken_time.clone();
            let get_weaken_time_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_weaken_time(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_weaken_time_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_server_growth<S>(
            get_server_growth: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_server_growth = get_server_growth.clone();
            let get_server_growth_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_server_growth(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_server_growth_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_hack_analyze_security<S>(
            hack_analyze_security: &std::rc::Rc<
                dyn Fn(f64, String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hack_analyze_security = hack_analyze_security.clone();
            let hack_analyze_security_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: String| -> std::result::Result<f64, JsValue> {
                    let result = hack_analyze_security(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &hack_analyze_security_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_script_kill<S>(
            script_kill: &std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let script_kill = script_kill.clone();
            let script_kill_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<bool, JsValue> {
                    let result = script_kill(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &script_kill_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_server<S>(
            get_server: &std::rc::Rc<dyn Fn(String) -> std::result::Result<Server, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_server = get_server.clone();
            let get_server_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<JsValue, JsValue> {
                    let result = get_server(arg0)?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_server_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_server_required_hacking_level<S>(
            get_server_required_hacking_level: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_server_required_hacking_level = get_server_required_hacking_level.clone();
            let get_server_required_hacking_level_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_server_required_hacking_level(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_server_required_hacking_level_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_run<S>(
            run: &std::rc::Rc<
                dyn Fn(
                    String,
                    NsRunParamsThreadOrOptions,
                    Vec<NsRunParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let run = run.clone();
            let run_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      _Variadic2_arg2: JsValue,
                      _Variadic3_arg2: JsValue,
                      _Variadic4_arg2: JsValue,
                      _Variadic5_arg2: JsValue,
                      _Variadic6_arg2: JsValue|
                      -> std::result::Result<f64, JsValue> {
                    let arg2 = {
                        let arg2 = js_sys::Array::new();
                        arg2.push(&_Variadic2_arg2);
                        arg2.push(&_Variadic3_arg2);
                        arg2.push(&_Variadic4_arg2);
                        arg2.push(&_Variadic5_arg2);
                        arg2.push(&_Variadic6_arg2);
                        arg2
                    };
                    let result = run(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        {
                            let mut arg2_vec = vec![];
                            for arg2_item in arg2.iter() {
                                arg2_vec.push(
                                    ts_bindgen_rt::from_jsvalue(&arg2_item)
                                        .map_err(ts_bindgen_rt::Error::from)?,
                                );
                            }
                            arg2_vec
                        },
                    )?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        String,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                    ) -> std::result::Result<f64, JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(serializer, &run_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_server_money_available<S>(
            get_server_money_available: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_server_money_available = get_server_money_available.clone();
            let get_server_money_available_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_server_money_available(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_server_money_available_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_grow<S>(
            grow: &std::rc::Rc<
                dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let grow = grow.clone();
            let grow_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue|
                      -> std::result::Result<js_sys::Promise, JsValue> {
                    let result = grow(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue) -> std::result::Result<js_sys::Promise, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &grow_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_vsprintf<S>(
            vsprintf: &std::rc::Rc<
                dyn Fn(String, Vec<JsValue>) -> std::result::Result<String, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let vsprintf = vsprintf.clone();
            let vsprintf_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: JsValue| -> std::result::Result<String, JsValue> {
                    let result = vsprintf(arg0, {
                        let mut arg1_vec = vec![];
                        for arg1_item in arg1.iter() {
                            arg1_vec.push(arg1_item);
                        }
                        arg1_vec
                    })?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue) -> std::result::Result<String, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &vsprintf_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_growth_analyze_security<S>(
            growth_analyze_security: &std::rc::Rc<
                dyn Fn(f64, String, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let growth_analyze_security = growth_analyze_security.clone();
            let growth_analyze_security_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: String, arg2: f64| -> std::result::Result<f64, JsValue> {
                    let result = growth_analyze_security(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, String, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &growth_analyze_security_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_money_sources<S>(
            get_money_sources: &std::rc::Rc<dyn Fn() -> std::result::Result<MoneySources, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_money_sources = get_money_sources.clone();
            let get_money_sources_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_money_sources()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_money_sources_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_sqlinject<S>(
            sqlinject: &std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let sqlinject = sqlinject.clone();
            let sqlinject_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<(), JsValue> {
                    let result = sqlinject(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<(), JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &sqlinject_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_file_exists<S>(
            file_exists: &std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let file_exists = file_exists.clone();
            let file_exists_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<bool, JsValue> {
                    let result = file_exists(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &file_exists_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_print<S>(
            print: &std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let print = print.clone();
            let print_closure = Closure::wrap(Box::new(
                move |_Variadic0_arg0: JsValue,
                      _Variadic1_arg0: JsValue,
                      _Variadic2_arg0: JsValue,
                      _Variadic3_arg0: JsValue,
                      _Variadic4_arg0: JsValue,
                      _Variadic5_arg0: JsValue,
                      _Variadic6_arg0: JsValue|
                      -> std::result::Result<(), JsValue> {
                    let arg0 = {
                        let arg0 = js_sys::Array::new();
                        arg0.push(&_Variadic0_arg0);
                        arg0.push(&_Variadic1_arg0);
                        arg0.push(&_Variadic2_arg0);
                        arg0.push(&_Variadic3_arg0);
                        arg0.push(&_Variadic4_arg0);
                        arg0.push(&_Variadic5_arg0);
                        arg0.push(&_Variadic6_arg0);
                        arg0
                    };
                    let result = print({
                        let mut arg0_vec = vec![];
                        for arg0_item in arg0.iter() {
                            arg0_vec.push(arg0_item);
                        }
                        arg0_vec
                    })?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                    ) -> std::result::Result<(), JsValue>,
                >);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &print_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_read<S>(
            read: &std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let read = read.clone();
            let read_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<String, JsValue> {
                    let result = read(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<String, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &read_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_purchase_server<S>(
            purchase_server: &std::rc::Rc<
                dyn Fn(String, f64) -> std::result::Result<String, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let purchase_server = purchase_server.clone();
            let purchase_server_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: f64| -> std::result::Result<String, JsValue> {
                    let result = purchase_server(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, f64) -> std::result::Result<String, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &purchase_server_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_share_power<S>(
            get_share_power: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_share_power = get_share_power.clone();
            let get_share_power_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_share_power()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_share_power_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_t_format<S>(
            t_format: &std::rc::Rc<dyn Fn(f64, bool) -> std::result::Result<String, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let t_format = t_format.clone();
            let t_format_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: bool| -> std::result::Result<String, JsValue> {
                    let result = t_format(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, bool) -> std::result::Result<String, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &t_format_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_read_port<S>(
            read_port: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<PortData, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let read_port = read_port.clone();
            let read_port_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<JsValue, JsValue> {
                    let result = read_port(arg0)?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<JsValue, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &read_port_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_hack_analyze_chance<S>(
            hack_analyze_chance: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hack_analyze_chance = hack_analyze_chance.clone();
            let hack_analyze_chance_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = hack_analyze_chance(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &hack_analyze_chance_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_purchased_server_cost<S>(
            get_purchased_server_cost: &std::rc::Rc<
                dyn Fn(f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_purchased_server_cost = get_purchased_server_cost.clone();
            let get_purchased_server_cost_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<f64, JsValue> {
                    let result = get_purchased_server_cost(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_purchased_server_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_hacknet_multipliers<S>(
            get_hacknet_multipliers: &std::rc::Rc<
                dyn Fn() -> std::result::Result<HacknetMultipliers, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_hacknet_multipliers = get_hacknet_multipliers.clone();
            let get_hacknet_multipliers_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_hacknet_multipliers()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_hacknet_multipliers_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_peek<S>(
            peek: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<PortData, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let peek = peek.clone();
            let peek_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<JsValue, JsValue> {
                    let result = peek(arg0)?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<JsValue, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &peek_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_script_running<S>(
            script_running: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let script_running = script_running.clone();
            let script_running_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<bool, JsValue> {
                    let result = script_running(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &script_running_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_write_port<S>(
            write_port: &std::rc::Rc<
                dyn Fn(
                    f64,
                    NsWritePortParamsData,
                ) -> std::result::Result<NsWritePortReturn, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let write_port = write_port.clone();
            let write_port_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: JsValue| -> std::result::Result<JsValue, JsValue> {
                    let result = write_port(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(f64, JsValue) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &write_port_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_purchased_server_upgrade_cost<S>(
            get_purchased_server_upgrade_cost: &std::rc::Rc<
                dyn Fn(String, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_purchased_server_upgrade_cost = get_purchased_server_upgrade_cost.clone();
            let get_purchased_server_upgrade_cost_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = get_purchased_server_upgrade_cost(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_purchased_server_upgrade_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_httpworm<S>(
            httpworm: &std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let httpworm = httpworm.clone();
            let httpworm_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<(), JsValue> {
                    let result = httpworm(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<(), JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &httpworm_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_player<S>(
            get_player: &std::rc::Rc<dyn Fn() -> std::result::Result<Player, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_player = get_player.clone();
            let get_player_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_player()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_player_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_script_income<S>(
            get_script_income: &std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    Vec<NsGetScriptIncomeParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_script_income = get_script_income.clone();
            let get_script_income_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: String,
                      _Variadic2_arg2: JsValue,
                      _Variadic3_arg2: JsValue,
                      _Variadic4_arg2: JsValue,
                      _Variadic5_arg2: JsValue,
                      _Variadic6_arg2: JsValue|
                      -> std::result::Result<f64, JsValue> {
                    let arg2 = {
                        let arg2 = js_sys::Array::new();
                        arg2.push(&_Variadic2_arg2);
                        arg2.push(&_Variadic3_arg2);
                        arg2.push(&_Variadic4_arg2);
                        arg2.push(&_Variadic5_arg2);
                        arg2.push(&_Variadic6_arg2);
                        arg2
                    };
                    let result = get_script_income(arg0, arg1, {
                        let mut arg2_vec = vec![];
                        for arg2_item in arg2.iter() {
                            arg2_vec.push(
                                ts_bindgen_rt::from_jsvalue(&arg2_item)
                                    .map_err(ts_bindgen_rt::Error::from)?,
                            );
                        }
                        arg2_vec
                    })?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        String,
                        String,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                    ) -> std::result::Result<f64, JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_script_income_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_spawn<S>(
            spawn: &std::rc::Rc<
                dyn Fn(
                    String,
                    NsSpawnParamsThreadOrOptions,
                    Vec<NsSpawnParamsArgs>,
                ) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let spawn = spawn.clone();
            let spawn_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      _Variadic2_arg2: JsValue,
                      _Variadic3_arg2: JsValue,
                      _Variadic4_arg2: JsValue,
                      _Variadic5_arg2: JsValue,
                      _Variadic6_arg2: JsValue|
                      -> std::result::Result<(), JsValue> {
                    let arg2 = {
                        let arg2 = js_sys::Array::new();
                        arg2.push(&_Variadic2_arg2);
                        arg2.push(&_Variadic3_arg2);
                        arg2.push(&_Variadic4_arg2);
                        arg2.push(&_Variadic5_arg2);
                        arg2.push(&_Variadic6_arg2);
                        arg2
                    };
                    let result = spawn(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        {
                            let mut arg2_vec = vec![];
                            for arg2_item in arg2.iter() {
                                arg2_vec.push(
                                    ts_bindgen_rt::from_jsvalue(&arg2_item)
                                        .map_err(ts_bindgen_rt::Error::from)?,
                                );
                            }
                            arg2_vec
                        },
                    )?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        String,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                    ) -> std::result::Result<(), JsValue>,
                >);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &spawn_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_purchased_servers<S>(
            get_purchased_servers: &std::rc::Rc<
                dyn Fn() -> std::result::Result<Vec<String>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_purchased_servers = get_purchased_servers.clone();
            let get_purchased_servers_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_purchased_servers()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_purchased_servers_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_tprintf<S>(
            tprintf: &std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let tprintf = tprintf.clone();
            let tprintf_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      _Variadic1_arg1: JsValue,
                      _Variadic2_arg1: JsValue,
                      _Variadic3_arg1: JsValue,
                      _Variadic4_arg1: JsValue,
                      _Variadic5_arg1: JsValue,
                      _Variadic6_arg1: JsValue|
                      -> std::result::Result<(), JsValue> {
                    let arg1 = {
                        let arg1 = js_sys::Array::new();
                        arg1.push(&_Variadic1_arg1);
                        arg1.push(&_Variadic2_arg1);
                        arg1.push(&_Variadic3_arg1);
                        arg1.push(&_Variadic4_arg1);
                        arg1.push(&_Variadic5_arg1);
                        arg1.push(&_Variadic6_arg1);
                        arg1
                    };
                    let result = tprintf(arg0, {
                        let mut arg1_vec = vec![];
                        for arg1_item in arg1.iter() {
                            arg1_vec.push(arg1_item);
                        }
                        arg1_vec
                    })?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        String,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                    ) -> std::result::Result<(), JsValue>,
                >);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &tprintf_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_server_used_ram<S>(
            get_server_used_ram: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_server_used_ram = get_server_used_ram.clone();
            let get_server_used_ram_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_server_used_ram(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_server_used_ram_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_script_logs<S>(
            get_script_logs: &std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    Vec<NsGetScriptLogsParamsArgs>,
                ) -> std::result::Result<Vec<String>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_script_logs = get_script_logs.clone();
            let get_script_logs_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: String,
                      _Variadic2_arg2: JsValue,
                      _Variadic3_arg2: JsValue,
                      _Variadic4_arg2: JsValue,
                      _Variadic5_arg2: JsValue,
                      _Variadic6_arg2: JsValue|
                      -> std::result::Result<JsValue, JsValue> {
                    let arg2 = {
                        let arg2 = js_sys::Array::new();
                        arg2.push(&_Variadic2_arg2);
                        arg2.push(&_Variadic3_arg2);
                        arg2.push(&_Variadic4_arg2);
                        arg2.push(&_Variadic5_arg2);
                        arg2.push(&_Variadic6_arg2);
                        arg2
                    };
                    let result = get_script_logs(arg0, arg1, {
                        let mut arg2_vec = vec![];
                        for arg2_item in arg2.iter() {
                            arg2_vec.push(
                                ts_bindgen_rt::from_jsvalue(&arg2_item)
                                    .map_err(ts_bindgen_rt::Error::from)?,
                            );
                        }
                        arg2_vec
                    })?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                },
            )
                as Box<
                    dyn Fn(
                        String,
                        String,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                    ) -> std::result::Result<JsValue, JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_script_logs_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_wget<S>(
            wget: &std::rc::Rc<
                dyn Fn(String, String, String) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let wget = wget.clone();
            let wget_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: String,
                      arg2: String|
                      -> std::result::Result<js_sys::Promise, JsValue> {
                    let result = wget(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(String, String, String) -> std::result::Result<js_sys::Promise, JsValue>,
                >);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &wget_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_time_since_last_aug<S>(
            get_time_since_last_aug: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_time_since_last_aug = get_time_since_last_aug.clone();
            let get_time_since_last_aug_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_time_since_last_aug()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_time_since_last_aug_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_killall<S>(
            killall: &std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let killall = killall.clone();
            let killall_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: bool| -> std::result::Result<bool, JsValue> {
                    let result = killall(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &killall_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_is_log_enabled<S>(
            is_log_enabled: &std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let is_log_enabled = is_log_enabled.clone();
            let is_log_enabled_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<bool, JsValue> {
                    let result = is_log_enabled(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &is_log_enabled_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_alert<S>(
            alert: &std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let alert = alert.clone();
            let alert_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<(), JsValue> {
                    let result = alert(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<(), JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &alert_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_weaken<S>(
            weaken: &std::rc::Rc<
                dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let weaken = weaken.clone();
            let weaken_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue|
                      -> std::result::Result<js_sys::Promise, JsValue> {
                    let result = weaken(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue) -> std::result::Result<js_sys::Promise, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &weaken_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_weaken_analyze<S>(
            weaken_analyze: &std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let weaken_analyze = weaken_analyze.clone();
            let weaken_analyze_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = weaken_analyze(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &weaken_analyze_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_brutessh<S>(
            brutessh: &std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let brutessh = brutessh.clone();
            let brutessh_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<(), JsValue> {
                    let result = brutessh(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<(), JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &brutessh_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_clear_log<S>(
            clear_log: &std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let clear_log = clear_log.clone();
            let clear_log_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<(), JsValue> {
                    let result = clear_log()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<(), JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &clear_log_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_asleep<S>(
            asleep: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<js_sys::Promise, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let asleep = asleep.clone();
            let asleep_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<js_sys::Promise, JsValue> {
                    let result = asleep(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<js_sys::Promise, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &asleep_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_relaysmtp<S>(
            relaysmtp: &std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let relaysmtp = relaysmtp.clone();
            let relaysmtp_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<(), JsValue> {
                    let result = relaysmtp(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<(), JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &relaysmtp_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_port_handle<S>(
            get_port_handle: &std::rc::Rc<
                dyn Fn(f64) -> std::result::Result<NetscriptPort, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_port_handle = get_port_handle.clone();
            let get_port_handle_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<JsValue, JsValue> {
                    let result = get_port_handle(arg0)?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_port_handle_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_kill<S>(
            kill: &std::rc::Rc<
                dyn Fn(String, String, Vec<ScriptArg>) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let kill = kill.clone();
            let kill_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: String,
                      _Variadic2_arg2: JsValue,
                      _Variadic3_arg2: JsValue,
                      _Variadic4_arg2: JsValue,
                      _Variadic5_arg2: JsValue,
                      _Variadic6_arg2: JsValue|
                      -> std::result::Result<bool, JsValue> {
                    let arg2 = {
                        let arg2 = js_sys::Array::new();
                        arg2.push(&_Variadic2_arg2);
                        arg2.push(&_Variadic3_arg2);
                        arg2.push(&_Variadic4_arg2);
                        arg2.push(&_Variadic5_arg2);
                        arg2.push(&_Variadic6_arg2);
                        arg2
                    };
                    let result = kill(arg0, arg1, {
                        let mut arg2_vec = vec![];
                        for arg2_item in arg2.iter() {
                            arg2_vec.push(
                                ts_bindgen_rt::from_jsvalue(&arg2_item)
                                    .map_err(ts_bindgen_rt::Error::from)?,
                            );
                        }
                        arg2_vec
                    })?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        String,
                        String,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                    ) -> std::result::Result<bool, JsValue>,
                >);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &kill_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_running_script<S>(
            get_running_script: &std::rc::Rc<
                dyn Fn(
                    FilenameOrPid,
                    String,
                    Vec<NsGetRunningScriptParamsArgs>,
                ) -> std::result::Result<NsGetRunningScriptReturn, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_running_script = get_running_script.clone();
            let get_running_script_closure = Closure::wrap(Box::new(
                move |arg0: JsValue,
                      arg1: String,
                      _Variadic2_arg2: JsValue,
                      _Variadic3_arg2: JsValue,
                      _Variadic4_arg2: JsValue,
                      _Variadic5_arg2: JsValue,
                      _Variadic6_arg2: JsValue|
                      -> std::result::Result<JsValue, JsValue> {
                    let arg2 = {
                        let arg2 = js_sys::Array::new();
                        arg2.push(&_Variadic2_arg2);
                        arg2.push(&_Variadic3_arg2);
                        arg2.push(&_Variadic4_arg2);
                        arg2.push(&_Variadic5_arg2);
                        arg2.push(&_Variadic6_arg2);
                        arg2
                    };
                    let result = get_running_script(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        arg1,
                        {
                            let mut arg2_vec = vec![];
                            for arg2_item in arg2.iter() {
                                arg2_vec.push(
                                    ts_bindgen_rt::from_jsvalue(&arg2_item)
                                        .map_err(ts_bindgen_rt::Error::from)?,
                                );
                            }
                            arg2_vec
                        },
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<
                    dyn Fn(
                        JsValue,
                        String,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                    ) -> std::result::Result<JsValue, JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_running_script_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_hacking_multipliers<S>(
            get_hacking_multipliers: &std::rc::Rc<
                dyn Fn() -> std::result::Result<HackingMultipliers, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_hacking_multipliers = get_hacking_multipliers.clone();
            let get_hacking_multipliers_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_hacking_multipliers()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_hacking_multipliers_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_purchased_server_limit<S>(
            get_purchased_server_limit: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_purchased_server_limit = get_purchased_server_limit.clone();
            let get_purchased_server_limit_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_purchased_server_limit()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_purchased_server_limit_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_write<S>(
            write: &std::rc::Rc<
                dyn Fn(String, String, NsWriteParamsMode) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let write = write.clone();
            let write_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: String,
                      arg2: JsValue|
                      -> std::result::Result<(), JsValue> {
                    let result = write(
                        arg0,
                        arg1,
                        ts_bindgen_rt::from_jsvalue(&arg2).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String, JsValue) -> std::result::Result<(), JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &write_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_total_script_exp_gain<S>(
            get_total_script_exp_gain: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_total_script_exp_gain = get_total_script_exp_gain.clone();
            let get_total_script_exp_gain_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_total_script_exp_gain()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_total_script_exp_gain_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_favor_to_donate<S>(
            get_favor_to_donate: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_favor_to_donate = get_favor_to_donate.clone();
            let get_favor_to_donate_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_favor_to_donate()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_favor_to_donate_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_server_exists<S>(
            server_exists: &std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let server_exists = server_exists.clone();
            let server_exists_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<bool, JsValue> {
                    let result = server_exists(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &server_exists_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_disable_log<S>(
            disable_log: &std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let disable_log = disable_log.clone();
            let disable_log_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<(), JsValue> {
                    let result = disable_log(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &disable_log_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_sprintf<S>(
            sprintf: &std::rc::Rc<
                dyn Fn(String, Vec<JsValue>) -> std::result::Result<String, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let sprintf = sprintf.clone();
            let sprintf_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      _Variadic1_arg1: JsValue,
                      _Variadic2_arg1: JsValue,
                      _Variadic3_arg1: JsValue,
                      _Variadic4_arg1: JsValue,
                      _Variadic5_arg1: JsValue,
                      _Variadic6_arg1: JsValue|
                      -> std::result::Result<String, JsValue> {
                    let arg1 = {
                        let arg1 = js_sys::Array::new();
                        arg1.push(&_Variadic1_arg1);
                        arg1.push(&_Variadic2_arg1);
                        arg1.push(&_Variadic3_arg1);
                        arg1.push(&_Variadic4_arg1);
                        arg1.push(&_Variadic5_arg1);
                        arg1.push(&_Variadic6_arg1);
                        arg1
                    };
                    let result = sprintf(arg0, {
                        let mut arg1_vec = vec![];
                        for arg1_item in arg1.iter() {
                            arg1_vec.push(arg1_item);
                        }
                        arg1_vec
                    })?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        String,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                    ) -> std::result::Result<String, JsValue>,
                >);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &sprintf_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_resize_tail<S>(
            resize_tail: &std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let resize_tail = resize_tail.clone();
            let resize_tail_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64, arg2: f64| -> std::result::Result<(), JsValue> {
                    let result = resize_tail(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64, f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &resize_tail_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_share<S>(
            share: &std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let share = share.clone();
            let share_closure = Closure::wrap(Box::new(
                move || -> std::result::Result<js_sys::Promise, JsValue> {
                    let result = share()?;
                    Ok(result)
                },
            )
                as Box<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &share_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_format_number<S>(
            format_number: &std::rc::Rc<
                dyn Fn(f64, f64, f64, bool) -> std::result::Result<String, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let format_number = format_number.clone();
            let format_number_closure = Closure::wrap(Box::new(
                move |arg0: f64,
                      arg1: f64,
                      arg2: f64,
                      arg3: bool|
                      -> std::result::Result<String, JsValue> {
                    let result = format_number(arg0, arg1, arg2, arg3)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64, f64, bool) -> std::result::Result<String, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &format_number_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_toast<S>(
            toast: &std::rc::Rc<
                dyn Fn(
                    String,
                    ToastVariant,
                    NsToastParamsDuration,
                ) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let toast = toast.clone();
            let toast_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: JsValue|
                      -> std::result::Result<(), JsValue> {
                    let result = toast(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg2).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, JsValue) -> std::result::Result<(), JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &toast_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_ps<S>(
            ps: &std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<ProcessInfo>, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let ps = ps.clone();
            let ps_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<JsValue, JsValue> {
                    let result = ps(arg0)?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(
                                &ts_bindgen_rt::to_jsvalue(&result_item)
                                    .map_err(ts_bindgen_rt::Error::from)?,
                            );
                        }
                        result_array.into()
                    })
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(serializer, &ps_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_scan<S>(
            scan: &std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let scan = scan.clone();
            let scan_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<JsValue, JsValue> {
                    let result = scan(arg0)?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<JsValue, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &scan_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_close_tail<S>(
            close_tail: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let close_tail = close_tail.clone();
            let close_tail_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<(), JsValue> {
                    let result = close_tail(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &close_tail_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_n_format<S>(
            n_format: &std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<String, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let n_format = n_format.clone();
            let n_format_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: String| -> std::result::Result<String, JsValue> {
                    let result = n_format(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, String) -> std::result::Result<String, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &n_format_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_server_security_level<S>(
            get_server_security_level: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_server_security_level = get_server_security_level.clone();
            let get_server_security_level_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_server_security_level(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_server_security_level_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_scp<S>(
            scp: &std::rc::Rc<
                dyn Fn(NsScpParamsFiles, String, String) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let scp = scp.clone();
            let scp_closure = Closure::wrap(Box::new(
                move |arg0: JsValue,
                      arg1: String,
                      arg2: String|
                      -> std::result::Result<bool, JsValue> {
                    let result = scp(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        arg1,
                        arg2,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue, String, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(serializer, &scp_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_script_exp_gain<S>(
            get_script_exp_gain: &std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    Vec<NsGetScriptExpGainParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_script_exp_gain = get_script_exp_gain.clone();
            let get_script_exp_gain_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: String,
                      _Variadic2_arg2: JsValue,
                      _Variadic3_arg2: JsValue,
                      _Variadic4_arg2: JsValue,
                      _Variadic5_arg2: JsValue,
                      _Variadic6_arg2: JsValue|
                      -> std::result::Result<f64, JsValue> {
                    let arg2 = {
                        let arg2 = js_sys::Array::new();
                        arg2.push(&_Variadic2_arg2);
                        arg2.push(&_Variadic3_arg2);
                        arg2.push(&_Variadic4_arg2);
                        arg2.push(&_Variadic5_arg2);
                        arg2.push(&_Variadic6_arg2);
                        arg2
                    };
                    let result = get_script_exp_gain(arg0, arg1, {
                        let mut arg2_vec = vec![];
                        for arg2_item in arg2.iter() {
                            arg2_vec.push(
                                ts_bindgen_rt::from_jsvalue(&arg2_item)
                                    .map_err(ts_bindgen_rt::Error::from)?,
                            );
                        }
                        arg2_vec
                    })?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        String,
                        String,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                    ) -> std::result::Result<f64, JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_script_exp_gain_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_reset_info<S>(
            get_reset_info: &std::rc::Rc<dyn Fn() -> std::result::Result<ResetInfo, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_reset_info = get_reset_info.clone();
            let get_reset_info_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_reset_info()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_reset_info_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_try_write_port<S>(
            try_write_port: &std::rc::Rc<
                dyn Fn(f64, NsTryWritePortParamsData) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let try_write_port = try_write_port.clone();
            let try_write_port_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: JsValue| -> std::result::Result<bool, JsValue> {
                    let result = try_write_port(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, JsValue) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &try_write_port_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_hack_analyze<S>(
            hack_analyze: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hack_analyze = hack_analyze.clone();
            let hack_analyze_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = hack_analyze(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &hack_analyze_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_grow_time<S>(
            get_grow_time: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_grow_time = get_grow_time.clone();
            let get_grow_time_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_grow_time(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_grow_time_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_printf<S>(
            printf: &std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let printf = printf.clone();
            let printf_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      _Variadic1_arg1: JsValue,
                      _Variadic2_arg1: JsValue,
                      _Variadic3_arg1: JsValue,
                      _Variadic4_arg1: JsValue,
                      _Variadic5_arg1: JsValue,
                      _Variadic6_arg1: JsValue|
                      -> std::result::Result<(), JsValue> {
                    let arg1 = {
                        let arg1 = js_sys::Array::new();
                        arg1.push(&_Variadic1_arg1);
                        arg1.push(&_Variadic2_arg1);
                        arg1.push(&_Variadic3_arg1);
                        arg1.push(&_Variadic4_arg1);
                        arg1.push(&_Variadic5_arg1);
                        arg1.push(&_Variadic6_arg1);
                        arg1
                    };
                    let result = printf(arg0, {
                        let mut arg1_vec = vec![];
                        for arg1_item in arg1.iter() {
                            arg1_vec.push(arg1_item);
                        }
                        arg1_vec
                    })?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        String,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                    ) -> std::result::Result<(), JsValue>,
                >);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &printf_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_hack_analyze_threads<S>(
            hack_analyze_threads: &std::rc::Rc<
                dyn Fn(String, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hack_analyze_threads = hack_analyze_threads.clone();
            let hack_analyze_threads_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = hack_analyze_threads(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &hack_analyze_threads_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_purchased_server_max_ram<S>(
            get_purchased_server_max_ram: &std::rc::Rc<
                dyn Fn() -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_purchased_server_max_ram = get_purchased_server_max_ram.clone();
            let get_purchased_server_max_ram_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_purchased_server_max_ram()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_purchased_server_max_ram_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_mv<S>(
            mv: &std::rc::Rc<dyn Fn(String, String, String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let mv = mv.clone();
            let mv_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: String,
                      arg2: String|
                      -> std::result::Result<(), JsValue> {
                    let result = mv(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String, String) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(serializer, &mv_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_exec<S>(
            exec: &std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    NsExecParamsThreadOrOptions,
                    Vec<NsExecParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let exec = exec.clone();
            let exec_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: String,
                      arg2: JsValue,
                      _Variadic3_arg3: JsValue,
                      _Variadic4_arg3: JsValue,
                      _Variadic5_arg3: JsValue,
                      _Variadic6_arg3: JsValue|
                      -> std::result::Result<f64, JsValue> {
                    let arg3 = {
                        let arg3 = js_sys::Array::new();
                        arg3.push(&_Variadic3_arg3);
                        arg3.push(&_Variadic4_arg3);
                        arg3.push(&_Variadic5_arg3);
                        arg3.push(&_Variadic6_arg3);
                        arg3
                    };
                    let result = exec(
                        arg0,
                        arg1,
                        ts_bindgen_rt::from_jsvalue(&arg2).map_err(ts_bindgen_rt::Error::from)?,
                        {
                            let mut arg3_vec = vec![];
                            for arg3_item in arg3.iter() {
                                arg3_vec.push(
                                    ts_bindgen_rt::from_jsvalue(&arg3_item)
                                        .map_err(ts_bindgen_rt::Error::from)?,
                                );
                            }
                            arg3_vec
                        },
                    )?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        String,
                        String,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                    ) -> std::result::Result<f64, JsValue>,
                >);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &exec_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_server_num_ports_required<S>(
            get_server_num_ports_required: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_server_num_ports_required = get_server_num_ports_required.clone();
            let get_server_num_ports_required_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_server_num_ports_required(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_server_num_ports_required_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_hostname<S>(
            get_hostname: &std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_hostname = get_hostname.clone();
            let get_hostname_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<String, JsValue> {
                    let result = get_hostname()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<String, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_hostname_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_server_base_security_level<S>(
            get_server_base_security_level: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_server_base_security_level = get_server_base_security_level.clone();
            let get_server_base_security_level_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_server_base_security_level(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_server_base_security_level_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_tprint<S>(
            tprint: &std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let tprint = tprint.clone();
            let tprint_closure = Closure::wrap(Box::new(
                move |_Variadic0_arg0: JsValue,
                      _Variadic1_arg0: JsValue,
                      _Variadic2_arg0: JsValue,
                      _Variadic3_arg0: JsValue,
                      _Variadic4_arg0: JsValue,
                      _Variadic5_arg0: JsValue,
                      _Variadic6_arg0: JsValue|
                      -> std::result::Result<(), JsValue> {
                    let arg0 = {
                        let arg0 = js_sys::Array::new();
                        arg0.push(&_Variadic0_arg0);
                        arg0.push(&_Variadic1_arg0);
                        arg0.push(&_Variadic2_arg0);
                        arg0.push(&_Variadic3_arg0);
                        arg0.push(&_Variadic4_arg0);
                        arg0.push(&_Variadic5_arg0);
                        arg0.push(&_Variadic6_arg0);
                        arg0
                    };
                    let result = tprint({
                        let mut arg0_vec = vec![];
                        for arg0_item in arg0.iter() {
                            arg0_vec.push(arg0_item);
                        }
                        arg0_vec
                    })?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                    ) -> std::result::Result<(), JsValue>,
                >);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &tprint_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_server_min_security_level<S>(
            get_server_min_security_level: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_server_min_security_level = get_server_min_security_level.clone();
            let get_server_min_security_level_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_server_min_security_level(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_server_min_security_level_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_recent_scripts<S>(
            get_recent_scripts: &std::rc::Rc<
                dyn Fn() -> std::result::Result<Vec<RecentScript>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_recent_scripts = get_recent_scripts.clone();
            let get_recent_scripts_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_recent_scripts()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(
                                &ts_bindgen_rt::to_jsvalue(&result_item)
                                    .map_err(ts_bindgen_rt::Error::from)?,
                            );
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_recent_scripts_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_rename_purchased_server<S>(
            rename_purchased_server: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let rename_purchased_server = rename_purchased_server.clone();
            let rename_purchased_server_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<bool, JsValue> {
                    let result = rename_purchased_server(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &rename_purchased_server_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_delete_server<S>(
            delete_server: &std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let delete_server = delete_server.clone();
            let delete_server_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<bool, JsValue> {
                    let result = delete_server(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &delete_server_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_ls<S>(
            ls: &std::rc::Rc<dyn Fn(String, String) -> std::result::Result<Vec<String>, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let ls = ls.clone();
            let ls_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<JsValue, JsValue> {
                    let result = ls(arg0, arg1)?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(serializer, &ls_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_server_max_ram<S>(
            get_server_max_ram: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_server_max_ram = get_server_max_ram.clone();
            let get_server_max_ram_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_server_max_ram(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_server_max_ram_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_is_running<S>(
            is_running: &std::rc::Rc<
                dyn Fn(
                    FilenameOrPid,
                    String,
                    Vec<NsIsRunningParamsArgs>,
                ) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let is_running = is_running.clone();
            let is_running_closure = Closure::wrap(Box::new(
                move |arg0: JsValue,
                      arg1: String,
                      _Variadic2_arg2: JsValue,
                      _Variadic3_arg2: JsValue,
                      _Variadic4_arg2: JsValue,
                      _Variadic5_arg2: JsValue,
                      _Variadic6_arg2: JsValue|
                      -> std::result::Result<bool, JsValue> {
                    let arg2 = {
                        let arg2 = js_sys::Array::new();
                        arg2.push(&_Variadic2_arg2);
                        arg2.push(&_Variadic3_arg2);
                        arg2.push(&_Variadic4_arg2);
                        arg2.push(&_Variadic5_arg2);
                        arg2.push(&_Variadic6_arg2);
                        arg2
                    };
                    let result = is_running(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        arg1,
                        {
                            let mut arg2_vec = vec![];
                            for arg2_item in arg2.iter() {
                                arg2_vec.push(
                                    ts_bindgen_rt::from_jsvalue(&arg2_item)
                                        .map_err(ts_bindgen_rt::Error::from)?,
                                );
                            }
                            arg2_vec
                        },
                    )?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(
                        JsValue,
                        String,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                        JsValue,
                    ) -> std::result::Result<bool, JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &is_running_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_hack<S>(
            hack: &std::rc::Rc<
                dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hack = hack.clone();
            let hack_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue|
                      -> std::result::Result<js_sys::Promise, JsValue> {
                    let result = hack(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue) -> std::result::Result<js_sys::Promise, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &hack_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_sleep<S>(
            sleep: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<js_sys::Promise, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let sleep = sleep.clone();
            let sleep_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<js_sys::Promise, JsValue> {
                    let result = sleep(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<js_sys::Promise, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &sleep_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_script_name<S>(
            get_script_name: &std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_script_name = get_script_name.clone();
            let get_script_name_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<String, JsValue> {
                    let result = get_script_name()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<String, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_script_name_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_clear<S>(
            clear: &std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let clear = clear.clone();
            let clear_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<(), JsValue> {
                    let result = clear(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<(), JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &clear_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_has_tor_router<S>(
            has_tor_router: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let has_tor_router = has_tor_router.clone();
            let has_tor_router_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = has_tor_router()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &has_tor_router_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_clear_port<S>(
            clear_port: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let clear_port = clear_port.clone();
            let clear_port_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<(), JsValue> {
                    let result = clear_port(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &clear_port_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_script_ram<S>(
            get_script_ram: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_script_ram = get_script_ram.clone();
            let get_script_ram_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<f64, JsValue> {
                    let result = get_script_ram(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_script_ram_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_nuke<S>(
            nuke: &std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let nuke = nuke.clone();
            let nuke_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<(), JsValue> {
                    let result = nuke(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<(), JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &nuke_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_move_tail<S>(
            move_tail: &std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let move_tail = move_tail.clone();
            let move_tail_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64, arg2: f64| -> std::result::Result<(), JsValue> {
                    let result = move_tail(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64, f64) -> std::result::Result<(), JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &move_tail_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_bit_node_multipliers<S>(
            get_bit_node_multipliers: &std::rc::Rc<
                dyn Fn(f64, f64) -> std::result::Result<BitNodeMultipliers, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_bit_node_multipliers = get_bit_node_multipliers.clone();
            let get_bit_node_multipliers_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<JsValue, JsValue> {
                    let result = get_bit_node_multipliers(arg0, arg1)?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_bit_node_multipliers_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_format_percent<S>(
            format_percent: &std::rc::Rc<
                dyn Fn(f64, f64, f64) -> std::result::Result<String, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let format_percent = format_percent.clone();
            let format_percent_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64, arg2: f64| -> std::result::Result<String, JsValue> {
                    let result = format_percent(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64, f64) -> std::result::Result<String, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &format_percent_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_function_ram_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_function_ram_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_function_ram_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_format_ram<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<String, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let format_ram: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            format_ram
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<String, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_rm<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let rm: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            rm.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(move |arg0: String, arg1: String| {
                    let arg0 = JsValue::from(arg0);
                    let arg1 = JsValue::from(arg1);
                    let _Args = js_sys::Array::new();
                    _Args.push(&arg0);
                    _Args.push(&arg1);
                    let ret = f.apply(&JsValue::null(), &_Args)?;
                    Ok(ret.into_serde().unwrap())
                })
                    as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_upgrade_purchased_server<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let upgrade_purchased_server: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            upgrade_purchased_server
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_hack_time<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_hack_time: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_hack_time
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_prompt<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    NsPromptParamsOptions,
                ) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let prompt: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            prompt
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: NsPromptParamsOptions| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                NsPromptParamsOptions,
                            )
                                -> std::result::Result<js_sys::Promise, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_server_max_money<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_server_max_money: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_server_max_money
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_flags<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    Vec<NsFlagsParamsSchema>,
                ) -> std::result::Result<
                    std::collections::HashMap<String, NsFlagsReturn>,
                    JsValue,
                >,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let flags: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            flags
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: Vec<NsFlagsParamsSchema>| {
                        let arg0 = {
                            let arg0_array = js_sys::Array::new();
                            for arg0_item in arg0 {
                                arg0_array.push(&{
                                    let arg0_item_array = js_sys::Array::new();
                                    let arg0_item_item_0 = arg0_item.0;
                                    arg0_item_array.push(&JsValue::from(arg0_item_item_0));
                                    let arg0_item_item_1 = arg0_item.1;
                                    arg0_item_array
                                        .push(&ts_bindgen_rt::to_jsvalue(&arg0_item_item_1));
                                    arg0_item_array.into()
                                });
                            }
                            arg0_array.into()
                        };
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                Vec<NsFlagsParamsSchema>,
                            ) -> std::result::Result<
                                std::collections::HashMap<String, NsFlagsReturn>,
                                JsValue,
                            >,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_growth_analyze<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let growth_analyze: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            growth_analyze
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: f64, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, f64, f64) -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_has_root_access<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let has_root_access: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            has_root_access
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_tail<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    FilenameOrPid,
                    String,
                    Vec<NsTailParamsArgs>,
                ) -> std::result::Result<(), JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let tail: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            tail.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(
                    move |arg0: FilenameOrPid, arg1: String, arg2: Vec<NsTailParamsArgs>| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = arg2
                            .into_iter()
                            .map(|arg2_item| {
                                ts_bindgen_rt::to_jsvalue(&arg2_item)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)
                            })
                            .collect::<std::result::Result<Vec<_>, _>>()
                            .into_boxed_slice();
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        for arg2 in arg2.into_iter() {
                            _Args.push(&arg2);
                        }
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    },
                )
                    as std::rc::Rc<
                        dyn Fn(
                            FilenameOrPid,
                            String,
                            Vec<NsTailParamsArgs>,
                        ) -> std::result::Result<(), JsValue>,
                    >
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_hacking_level<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_hacking_level: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_hacking_level
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_enable_log<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let enable_log: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            enable_log
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_ftpcrack<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let ftpcrack: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            ftpcrack
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_total_script_income<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<NsGetTotalScriptIncomeReturn, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_total_script_income: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_total_script_income
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn() -> std::result::Result<NsGetTotalScriptIncomeReturn, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_weaken_time<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_weaken_time: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_weaken_time
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_server_growth<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_server_growth: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_server_growth
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hack_analyze_security<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hack_analyze_security: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            hack_analyze_security
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_script_kill<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let script_kill: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            script_kill
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_server<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Server, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_server: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_server
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<Server, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_server_required_hacking_level<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_server_required_hacking_level: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_server_required_hacking_level
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_run<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    NsRunParamsThreadOrOptions,
                    Vec<NsRunParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let run: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            run.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(
                    move |arg0: String,
                          arg1: NsRunParamsThreadOrOptions,
                          arg2: Vec<NsRunParamsArgs>| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = arg2
                            .into_iter()
                            .map(|arg2_item| {
                                ts_bindgen_rt::to_jsvalue(&arg2_item)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)
                            })
                            .collect::<std::result::Result<Vec<_>, _>>()
                            .into_boxed_slice();
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        for arg2 in arg2.into_iter() {
                            _Args.push(&arg2);
                        }
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    },
                )
                    as std::rc::Rc<
                        dyn Fn(
                            String,
                            NsRunParamsThreadOrOptions,
                            Vec<NsRunParamsArgs>,
                        ) -> std::result::Result<f64, JsValue>,
                    >
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_server_money_available<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_server_money_available: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_server_money_available
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_grow<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let grow: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            grow.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(move |arg0: String, arg1: BasicHgwOptions| {
                    let arg0 = JsValue::from(arg0);
                    let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                    let _Args = js_sys::Array::new();
                    _Args.push(&arg0);
                    _Args.push(&arg1);
                    let ret = f.apply(&JsValue::null(), &_Args)?;
                    Ok(ret.into_serde().unwrap())
                })
                    as std::rc::Rc<
                        dyn Fn(
                            String,
                            BasicHgwOptions,
                        )
                            -> std::result::Result<js_sys::Promise, JsValue>,
                    >
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_vsprintf<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<String, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let vsprintf: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            vsprintf
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: Vec<JsValue>| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = {
                            let arg1_array = js_sys::Array::new();
                            for arg1_item in arg1 {
                                arg1_array.push(&JsValue::from(arg1_item));
                            }
                            arg1_array.into()
                        };
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, Vec<JsValue>) -> std::result::Result<String, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_growth_analyze_security<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let growth_analyze_security: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            growth_analyze_security
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: String, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(f64, String, f64) -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_money_sources<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<MoneySources, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_money_sources: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_money_sources
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<MoneySources, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_sqlinject<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let sqlinject: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            sqlinject
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_file_exists<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let file_exists: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            file_exists
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_print<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let print: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            print
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                        let arg0 = arg0
                            .into_iter()
                            .map(|arg0_item| JsValue::from(arg0_item))
                            .collect::<Vec<_>>()
                            .into_boxed_slice();
                        let _Args = js_sys::Array::new();
                        for arg0 in arg0.into_iter() {
                            _Args.push(&arg0);
                        }
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_read<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let read: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            read.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(move |arg0: String| {
                    let arg0 = JsValue::from(arg0);
                    let _Args = js_sys::Array::new();
                    _Args.push(&arg0);
                    let ret = f.apply(&JsValue::null(), &_Args)?;
                    Ok(ret.into_serde().unwrap())
                })
                    as std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_purchase_server<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<String, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let purchase_server: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            purchase_server
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<String, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_share_power<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_share_power: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_share_power
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_t_format<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, bool) -> std::result::Result<String, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let t_format: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            t_format
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: bool| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, bool) -> std::result::Result<String, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_read_port<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<PortData, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let read_port: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            read_port
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<PortData, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hack_analyze_chance<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hack_analyze_chance: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            hack_analyze_chance
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_purchased_server_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_purchased_server_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_purchased_server_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_hacknet_multipliers<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<HacknetMultipliers, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_hacknet_multipliers: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_hacknet_multipliers
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<HacknetMultipliers, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_peek<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<PortData, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let peek: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            peek.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(move |arg0: f64| {
                    let arg0 = JsValue::from(arg0);
                    let _Args = js_sys::Array::new();
                    _Args.push(&arg0);
                    let ret = f.apply(&JsValue::null(), &_Args)?;
                    Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                })
                    as std::rc::Rc<dyn Fn(f64) -> std::result::Result<PortData, JsValue>>
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_script_running<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let script_running: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            script_running
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_write_port<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    f64,
                    NsWritePortParamsData,
                ) -> std::result::Result<NsWritePortReturn, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let write_port: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            write_port
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: NsWritePortParamsData| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                f64,
                                NsWritePortParamsData,
                            )
                                -> std::result::Result<NsWritePortReturn, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_purchased_server_upgrade_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_purchased_server_upgrade_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_purchased_server_upgrade_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_httpworm<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let httpworm: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            httpworm
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_player<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Player, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_player: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_player
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Player, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_script_income<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    Vec<NsGetScriptIncomeParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_script_income: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_script_income
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String,
                              arg1: String,
                              arg2: Vec<NsGetScriptIncomeParamsArgs>| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = JsValue::from(arg1);
                            let arg2 = arg2
                                .into_iter()
                                .map(|arg2_item| {
                                    ts_bindgen_rt::to_jsvalue(&arg2_item)
                                        .map_err(ts_bindgen_rt::Error::from)
                                        .map_err(JsValue::from)
                                })
                                .collect::<std::result::Result<Vec<_>, _>>()
                                .into_boxed_slice();
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            for arg2 in arg2.into_iter() {
                                _Args.push(&arg2);
                            }
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                String,
                                Vec<NsGetScriptIncomeParamsArgs>,
                            )
                                -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_spawn<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    NsSpawnParamsThreadOrOptions,
                    Vec<NsSpawnParamsArgs>,
                ) -> std::result::Result<(), JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let spawn: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            spawn
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String,
                              arg1: NsSpawnParamsThreadOrOptions,
                              arg2: Vec<NsSpawnParamsArgs>| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = arg2
                                .into_iter()
                                .map(|arg2_item| {
                                    ts_bindgen_rt::to_jsvalue(&arg2_item)
                                        .map_err(ts_bindgen_rt::Error::from)
                                        .map_err(JsValue::from)
                                })
                                .collect::<std::result::Result<Vec<_>, _>>()
                                .into_boxed_slice();
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            for arg2 in arg2.into_iter() {
                                _Args.push(&arg2);
                            }
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                NsSpawnParamsThreadOrOptions,
                                Vec<NsSpawnParamsArgs>,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_purchased_servers<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_purchased_servers: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_purchased_servers
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_tprintf<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let tprintf: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            tprintf
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: Vec<JsValue>| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = arg1
                            .into_iter()
                            .map(|arg1_item| JsValue::from(arg1_item))
                            .collect::<Vec<_>>()
                            .into_boxed_slice();
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        for arg1 in arg1.into_iter() {
                            _Args.push(&arg1);
                        }
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, Vec<JsValue>) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_server_used_ram<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_server_used_ram: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_server_used_ram
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_script_logs<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    Vec<NsGetScriptLogsParamsArgs>,
                ) -> std::result::Result<Vec<String>, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_script_logs: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_script_logs
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: String, arg2: Vec<NsGetScriptLogsParamsArgs>| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = JsValue::from(arg1);
                            let arg2 = arg2
                                .into_iter()
                                .map(|arg2_item| {
                                    ts_bindgen_rt::to_jsvalue(&arg2_item)
                                        .map_err(ts_bindgen_rt::Error::from)
                                        .map_err(JsValue::from)
                                })
                                .collect::<std::result::Result<Vec<_>, _>>()
                                .into_boxed_slice();
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            for arg2 in arg2.into_iter() {
                                _Args.push(&arg2);
                            }
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                String,
                                Vec<NsGetScriptLogsParamsArgs>,
                            )
                                -> std::result::Result<Vec<String>, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_wget<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, String, String) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let wget: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            wget.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(move |arg0: String, arg1: String, arg2: String| {
                    let arg0 = JsValue::from(arg0);
                    let arg1 = JsValue::from(arg1);
                    let arg2 = JsValue::from(arg2);
                    let _Args = js_sys::Array::new();
                    _Args.push(&arg0);
                    _Args.push(&arg1);
                    _Args.push(&arg2);
                    let ret = f.apply(&JsValue::null(), &_Args)?;
                    Ok(ret.into_serde().unwrap())
                })
                    as std::rc::Rc<
                        dyn Fn(
                            String,
                            String,
                            String,
                        )
                            -> std::result::Result<js_sys::Promise, JsValue>,
                    >
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_time_since_last_aug<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_time_since_last_aug: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_time_since_last_aug
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_killall<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let killall: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            killall
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: bool| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, bool) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_is_log_enabled<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let is_log_enabled: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            is_log_enabled
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_alert<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let alert: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            alert
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_weaken<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let weaken: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            weaken
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: BasicHgwOptions| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                BasicHgwOptions,
                            )
                                -> std::result::Result<js_sys::Promise, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_weaken_analyze<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let weaken_analyze: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            weaken_analyze
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_brutessh<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let brutessh: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            brutessh
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_clear_log<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let clear_log: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            clear_log
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_asleep<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<js_sys::Promise, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let asleep: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            asleep
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<js_sys::Promise, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_relaysmtp<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let relaysmtp: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            relaysmtp
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_port_handle<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<NetscriptPort, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_port_handle: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_port_handle
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<NetscriptPort, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_kill<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, String, Vec<ScriptArg>) -> std::result::Result<bool, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let kill: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            kill.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(move |arg0: String, arg1: String, arg2: Vec<ScriptArg>| {
                    let arg0 = JsValue::from(arg0);
                    let arg1 = JsValue::from(arg1);
                    let arg2 = arg2
                        .into_iter()
                        .map(|arg2_item| {
                            ts_bindgen_rt::to_jsvalue(&arg2_item)
                                .map_err(ts_bindgen_rt::Error::from)
                                .map_err(JsValue::from)
                        })
                        .collect::<std::result::Result<Vec<_>, _>>()
                        .into_boxed_slice();
                    let _Args = js_sys::Array::new();
                    _Args.push(&arg0);
                    _Args.push(&arg1);
                    for arg2 in arg2.into_iter() {
                        _Args.push(&arg2);
                    }
                    let ret = f.apply(&JsValue::null(), &_Args)?;
                    Ok(ret.into_serde().unwrap())
                })
                    as std::rc::Rc<
                        dyn Fn(
                            String,
                            String,
                            Vec<ScriptArg>,
                        ) -> std::result::Result<bool, JsValue>,
                    >
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_running_script<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    FilenameOrPid,
                    String,
                    Vec<NsGetRunningScriptParamsArgs>,
                ) -> std::result::Result<NsGetRunningScriptReturn, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_running_script: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_running_script
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: FilenameOrPid,
                              arg1: String,
                              arg2: Vec<NsGetRunningScriptParamsArgs>| {
                            let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                            let arg1 = JsValue::from(arg1);
                            let arg2 = arg2
                                .into_iter()
                                .map(|arg2_item| {
                                    ts_bindgen_rt::to_jsvalue(&arg2_item)
                                        .map_err(ts_bindgen_rt::Error::from)
                                        .map_err(JsValue::from)
                                })
                                .collect::<std::result::Result<Vec<_>, _>>()
                                .into_boxed_slice();
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            for arg2 in arg2.into_iter() {
                                _Args.push(&arg2);
                            }
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                FilenameOrPid,
                                String,
                                Vec<NsGetRunningScriptParamsArgs>,
                            )
                                -> std::result::Result<NsGetRunningScriptReturn, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_hacking_multipliers<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<HackingMultipliers, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_hacking_multipliers: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_hacking_multipliers
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<HackingMultipliers, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_purchased_server_limit<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_purchased_server_limit: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_purchased_server_limit
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_write<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, String, NsWriteParamsMode) -> std::result::Result<(), JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let write: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            write
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String, arg2: NsWriteParamsMode| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = ts_bindgen_rt::to_jsvalue(&arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                String,
                                NsWriteParamsMode,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_total_script_exp_gain<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_total_script_exp_gain: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_total_script_exp_gain
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_favor_to_donate<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_favor_to_donate: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_favor_to_donate
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_server_exists<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let server_exists: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            server_exists
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_disable_log<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let disable_log: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            disable_log
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_sprintf<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<String, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let sprintf: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            sprintf
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: Vec<JsValue>| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = arg1
                            .into_iter()
                            .map(|arg1_item| JsValue::from(arg1_item))
                            .collect::<Vec<_>>()
                            .into_boxed_slice();
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        for arg1 in arg1.into_iter() {
                            _Args.push(&arg1);
                        }
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, Vec<JsValue>) -> std::result::Result<String, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_resize_tail<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let resize_tail: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            resize_tail
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_share<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let share: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            share
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<js_sys::Promise, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_format_number<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64, bool) -> std::result::Result<String, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let format_number: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            format_number
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64, arg2: f64, arg3: bool| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let arg3 = JsValue::from(arg3);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        _Args.push(&arg3);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(f64, f64, f64, bool) -> std::result::Result<String, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_toast<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    ToastVariant,
                    NsToastParamsDuration,
                ) -> std::result::Result<(), JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let toast: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            toast
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: ToastVariant, arg2: NsToastParamsDuration| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = ts_bindgen_rt::to_jsvalue(&arg2);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                ToastVariant,
                                NsToastParamsDuration,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_ps<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<ProcessInfo>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let ps: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            ps.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(move |arg0: String| {
                    let arg0 = JsValue::from(arg0);
                    let _Args = js_sys::Array::new();
                    _Args.push(&arg0);
                    let ret = f.apply(&JsValue::null(), &_Args)?;
                    Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                })
                    as std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<ProcessInfo>, JsValue>>
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_scan<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let scan: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            scan.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(move |arg0: String| {
                    let arg0 = JsValue::from(arg0);
                    let _Args = js_sys::Array::new();
                    _Args.push(&arg0);
                    let ret = f.apply(&JsValue::null(), &_Args)?;
                    Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                })
                    as std::rc::Rc<dyn Fn(String) -> std::result::Result<Vec<String>, JsValue>>
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_close_tail<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let close_tail: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            close_tail
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_n_format<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<String, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let n_format: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            n_format
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<String, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_server_security_level<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_server_security_level: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_server_security_level
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_scp<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(NsScpParamsFiles, String, String) -> std::result::Result<bool, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let scp: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            scp.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(move |arg0: NsScpParamsFiles, arg1: String, arg2: String| {
                    let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                    let arg1 = JsValue::from(arg1);
                    let arg2 = JsValue::from(arg2);
                    let _Args = js_sys::Array::new();
                    _Args.push(&arg0);
                    _Args.push(&arg1);
                    _Args.push(&arg2);
                    let ret = f.apply(&JsValue::null(), &_Args)?;
                    Ok(ret.into_serde().unwrap())
                })
                    as std::rc::Rc<
                        dyn Fn(
                            NsScpParamsFiles,
                            String,
                            String,
                        ) -> std::result::Result<bool, JsValue>,
                    >
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_script_exp_gain<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    Vec<NsGetScriptExpGainParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_script_exp_gain: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_script_exp_gain
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String,
                              arg1: String,
                              arg2: Vec<NsGetScriptExpGainParamsArgs>| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = JsValue::from(arg1);
                            let arg2 = arg2
                                .into_iter()
                                .map(|arg2_item| {
                                    ts_bindgen_rt::to_jsvalue(&arg2_item)
                                        .map_err(ts_bindgen_rt::Error::from)
                                        .map_err(JsValue::from)
                                })
                                .collect::<std::result::Result<Vec<_>, _>>()
                                .into_boxed_slice();
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            for arg2 in arg2.into_iter() {
                                _Args.push(&arg2);
                            }
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                String,
                                Vec<NsGetScriptExpGainParamsArgs>,
                            )
                                -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_reset_info<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<ResetInfo, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_reset_info: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_reset_info
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<ResetInfo, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_try_write_port<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(f64, NsTryWritePortParamsData) -> std::result::Result<bool, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let try_write_port: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            try_write_port
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: NsTryWritePortParamsData| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                f64,
                                NsTryWritePortParamsData,
                            )
                                -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hack_analyze<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hack_analyze: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            hack_analyze
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_grow_time<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_grow_time: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_grow_time
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_printf<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, Vec<JsValue>) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let printf: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            printf
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: Vec<JsValue>| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = arg1
                            .into_iter()
                            .map(|arg1_item| JsValue::from(arg1_item))
                            .collect::<Vec<_>>()
                            .into_boxed_slice();
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        for arg1 in arg1.into_iter() {
                            _Args.push(&arg1);
                        }
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, Vec<JsValue>) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hack_analyze_threads<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hack_analyze_threads: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            hack_analyze_threads
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_purchased_server_max_ram<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_purchased_server_max_ram: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_purchased_server_max_ram
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_mv<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String, String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let mv: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            mv.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(move |arg0: String, arg1: String, arg2: String| {
                    let arg0 = JsValue::from(arg0);
                    let arg1 = JsValue::from(arg1);
                    let arg2 = JsValue::from(arg2);
                    let _Args = js_sys::Array::new();
                    _Args.push(&arg0);
                    _Args.push(&arg1);
                    _Args.push(&arg2);
                    let ret = f.apply(&JsValue::null(), &_Args)?;
                    Ok(ret.into_serde().unwrap())
                })
                    as std::rc::Rc<
                        dyn Fn(String, String, String) -> std::result::Result<(), JsValue>,
                    >
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_exec<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    String,
                    NsExecParamsThreadOrOptions,
                    Vec<NsExecParamsArgs>,
                ) -> std::result::Result<f64, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let exec: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            exec.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(
                    move |arg0: String,
                          arg1: String,
                          arg2: NsExecParamsThreadOrOptions,
                          arg3: Vec<NsExecParamsArgs>| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = ts_bindgen_rt::to_jsvalue(&arg2);
                        let arg3 = arg3
                            .into_iter()
                            .map(|arg3_item| {
                                ts_bindgen_rt::to_jsvalue(&arg3_item)
                                    .map_err(ts_bindgen_rt::Error::from)
                                    .map_err(JsValue::from)
                            })
                            .collect::<std::result::Result<Vec<_>, _>>()
                            .into_boxed_slice();
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        for arg3 in arg3.into_iter() {
                            _Args.push(&arg3);
                        }
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    },
                )
                    as std::rc::Rc<
                        dyn Fn(
                            String,
                            String,
                            NsExecParamsThreadOrOptions,
                            Vec<NsExecParamsArgs>,
                        ) -> std::result::Result<f64, JsValue>,
                    >
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_server_num_ports_required<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_server_num_ports_required: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_server_num_ports_required
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_hostname<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_hostname: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_hostname
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_server_base_security_level<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_server_base_security_level: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_server_base_security_level
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_tprint<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let tprint: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            tprint
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: Vec<JsValue>| {
                        let arg0 = arg0
                            .into_iter()
                            .map(|arg0_item| JsValue::from(arg0_item))
                            .collect::<Vec<_>>()
                            .into_boxed_slice();
                        let _Args = js_sys::Array::new();
                        for arg0 in arg0.into_iter() {
                            _Args.push(&arg0);
                        }
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(Vec<JsValue>) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_server_min_security_level<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_server_min_security_level: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_server_min_security_level
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_recent_scripts<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<RecentScript>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_recent_scripts: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_recent_scripts
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<RecentScript>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_rename_purchased_server<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let rename_purchased_server: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            rename_purchased_server
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_delete_server<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let delete_server: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            delete_server
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_ls<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let ls: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            ls.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(move |arg0: String, arg1: String| {
                    let arg0 = JsValue::from(arg0);
                    let arg1 = JsValue::from(arg1);
                    let _Args = js_sys::Array::new();
                    _Args.push(&arg0);
                    _Args.push(&arg1);
                    let ret = f.apply(&JsValue::null(), &_Args)?;
                    Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                })
                    as std::rc::Rc<
                        dyn Fn(String, String) -> std::result::Result<Vec<String>, JsValue>,
                    >
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_server_max_ram<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_server_max_ram: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_server_max_ram
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_is_running<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    FilenameOrPid,
                    String,
                    Vec<NsIsRunningParamsArgs>,
                ) -> std::result::Result<bool, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let is_running: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            is_running
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: FilenameOrPid,
                              arg1: String,
                              arg2: Vec<NsIsRunningParamsArgs>| {
                            let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                            let arg1 = JsValue::from(arg1);
                            let arg2 = arg2
                                .into_iter()
                                .map(|arg2_item| {
                                    ts_bindgen_rt::to_jsvalue(&arg2_item)
                                        .map_err(ts_bindgen_rt::Error::from)
                                        .map_err(JsValue::from)
                                })
                                .collect::<std::result::Result<Vec<_>, _>>()
                                .into_boxed_slice();
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            for arg2 in arg2.into_iter() {
                                _Args.push(&arg2);
                            }
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                FilenameOrPid,
                                String,
                                Vec<NsIsRunningParamsArgs>,
                            )
                                -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hack<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, BasicHgwOptions) -> std::result::Result<js_sys::Promise, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hack: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            hack.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(move |arg0: String, arg1: BasicHgwOptions| {
                    let arg0 = JsValue::from(arg0);
                    let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                    let _Args = js_sys::Array::new();
                    _Args.push(&arg0);
                    _Args.push(&arg1);
                    let ret = f.apply(&JsValue::null(), &_Args)?;
                    Ok(ret.into_serde().unwrap())
                })
                    as std::rc::Rc<
                        dyn Fn(
                            String,
                            BasicHgwOptions,
                        )
                            -> std::result::Result<js_sys::Promise, JsValue>,
                    >
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_sleep<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<js_sys::Promise, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let sleep: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            sleep
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<js_sys::Promise, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_script_name<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_script_name: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_script_name
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<String, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_clear<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let clear: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            clear
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_has_tor_router<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let has_tor_router: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            has_tor_router
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_clear_port<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let clear_port: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            clear_port
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_script_ram<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_script_ram: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_script_ram
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_nuke<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let nuke: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            nuke.map(|f| {
                let f = f.clone();
                std::rc::Rc::new(move |arg0: String| {
                    let arg0 = JsValue::from(arg0);
                    let _Args = js_sys::Array::new();
                    _Args.push(&arg0);
                    let ret = f.apply(&JsValue::null(), &_Args)?;
                    Ok(ret.into_serde().unwrap())
                })
                    as std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>
            })
            .ok_or_else(|| {
                ts_bindgen_rt::jsvalue_serde::Error::InvalidType("expected function".to_string())
            })
            .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_move_tail<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let move_tail: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            move_tail
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_bit_node_multipliers<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<BitNodeMultipliers, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_bit_node_multipliers: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_bit_node_multipliers
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(f64, f64) -> std::result::Result<BitNodeMultipliers, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_format_percent<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<String, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let format_percent: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            format_percent
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(f64, f64, f64) -> std::result::Result<String, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct RunOptions {
        #[serde(rename = "temporary")]
        pub temporary: Option<bool>,
        #[serde(rename = "threads")]
        pub threads: Option<f64>,
        #[serde(rename = "ramOverride")]
        pub ram_override: Option<f64>,
        #[serde(rename = "preventDuplicates")]
        pub prevent_duplicates: Option<bool>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait RunOptions_Trait {
        fn set_temporary(&mut self, value: Option<bool>) -> std::result::Result<(), JsValue>;
        fn temporary(&self) -> std::result::Result<Option<bool>, JsValue>;
        fn set_threads(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn threads(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_ram_override(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue>;
        fn ram_override(&self) -> std::result::Result<Option<f64>, JsValue>;
        fn set_prevent_duplicates(
            &mut self,
            value: Option<bool>,
        ) -> std::result::Result<(), JsValue>;
        fn prevent_duplicates(&self) -> std::result::Result<Option<bool>, JsValue>;
    }
    impl RunOptions_Trait for RunOptions {
        fn set_temporary(&mut self, value: Option<bool>) -> std::result::Result<(), JsValue> {
            self.temporary = value;
            Ok(())
        }
        fn temporary(&self) -> std::result::Result<Option<bool>, JsValue> {
            Ok(self.temporary.clone())
        }
        fn set_threads(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.threads = value;
            Ok(())
        }
        fn threads(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.threads.clone())
        }
        fn set_ram_override(&mut self, value: Option<f64>) -> std::result::Result<(), JsValue> {
            self.ram_override = value;
            Ok(())
        }
        fn ram_override(&self) -> std::result::Result<Option<f64>, JsValue> {
            Ok(self.ram_override.clone())
        }
        fn set_prevent_duplicates(
            &mut self,
            value: Option<bool>,
        ) -> std::result::Result<(), JsValue> {
            self.prevent_duplicates = value;
            Ok(())
        }
        fn prevent_duplicates(&self) -> std::result::Result<Option<bool>, JsValue> {
            Ok(self.prevent_duplicates.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct SleeveCompanyTaskAliased {
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "companyName")]
        pub company_name: String,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait SleeveCompanyTaskAliased_Trait {
        fn set_company_name(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn company_name(&self) -> std::result::Result<String, JsValue>;
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn type_(&self) -> std::result::Result<String, JsValue>;
    }
    impl SleeveCompanyTaskAliased_Trait for SleeveCompanyTaskAliased {
        fn set_company_name(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.company_name = value;
            Ok(())
        }
        fn company_name(&self) -> std::result::Result<String, JsValue> {
            Ok(self.company_name.clone())
        }
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.type_ = value;
            Ok(())
        }
        fn type_(&self) -> std::result::Result<String, JsValue> {
            Ok(self.type_.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct OfficeApi {
        #[serde(
            rename = "getOfficeSizeUpgradeCost",
            serialize_with = "OfficeApi::__TSB__serialize_get_office_size_upgrade_cost",
            deserialize_with = "OfficeApi::__TSB__deserialize_get_office_size_upgrade_cost"
        )]
        pub get_office_size_upgrade_cost:
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "buyTea",
            serialize_with = "OfficeApi::__TSB__serialize_buy_tea",
            deserialize_with = "OfficeApi::__TSB__deserialize_buy_tea"
        )]
        pub buy_tea: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "setAutoJobAssignment",
            serialize_with = "OfficeApi::__TSB__serialize_set_auto_job_assignment",
            deserialize_with = "OfficeApi::__TSB__deserialize_set_auto_job_assignment"
        )]
        pub set_auto_job_assignment: std::rc::Rc<
            dyn Fn(String, CityName, String, f64) -> std::result::Result<bool, JsValue>,
        >,
        #[serde(
            rename = "hasResearched",
            serialize_with = "OfficeApi::__TSB__serialize_has_researched",
            deserialize_with = "OfficeApi::__TSB__deserialize_has_researched"
        )]
        pub has_researched:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "research",
            serialize_with = "OfficeApi::__TSB__serialize_research",
            deserialize_with = "OfficeApi::__TSB__deserialize_research"
        )]
        pub research: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "throwParty",
            serialize_with = "OfficeApi::__TSB__serialize_throw_party",
            deserialize_with = "OfficeApi::__TSB__deserialize_throw_party"
        )]
        pub throw_party:
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getHireAdVertCost",
            serialize_with = "OfficeApi::__TSB__serialize_get_hire_ad_vert_cost",
            deserialize_with = "OfficeApi::__TSB__deserialize_get_hire_ad_vert_cost"
        )]
        pub get_hire_ad_vert_cost: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "hireEmployee",
            serialize_with = "OfficeApi::__TSB__serialize_hire_employee",
            deserialize_with = "OfficeApi::__TSB__deserialize_hire_employee"
        )]
        pub hire_employee: std::rc::Rc<
            dyn Fn(String, CityName, CorpEmployeePosition) -> std::result::Result<bool, JsValue>,
        >,
        #[serde(
            rename = "upgradeOfficeSize",
            serialize_with = "OfficeApi::__TSB__serialize_upgrade_office_size",
            deserialize_with = "OfficeApi::__TSB__deserialize_upgrade_office_size"
        )]
        pub upgrade_office_size:
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "getResearchCost",
            serialize_with = "OfficeApi::__TSB__serialize_get_research_cost",
            deserialize_with = "OfficeApi::__TSB__deserialize_get_research_cost"
        )]
        pub get_research_cost:
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getOffice",
            serialize_with = "OfficeApi::__TSB__serialize_get_office",
            deserialize_with = "OfficeApi::__TSB__deserialize_get_office"
        )]
        pub get_office:
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Office, JsValue>>,
        #[serde(
            rename = "getHireAdVertCount",
            serialize_with = "OfficeApi::__TSB__serialize_get_hire_ad_vert_count",
            deserialize_with = "OfficeApi::__TSB__deserialize_get_hire_ad_vert_count"
        )]
        pub get_hire_ad_vert_count:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "hireAdVert",
            serialize_with = "OfficeApi::__TSB__serialize_hire_ad_vert",
            deserialize_with = "OfficeApi::__TSB__deserialize_hire_ad_vert"
        )]
        pub hire_ad_vert: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait OfficeApi_Trait {
        fn set_throw_party(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn throw_party(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_research_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_research_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_hire_employee(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    CorpEmployeePosition,
                ) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn hire_employee(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    CorpEmployeePosition,
                ) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        >;
        fn set_buy_tea(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn buy_tea(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_hire_ad_vert_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_hire_ad_vert_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_office_size_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_office_size_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_upgrade_office_size(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn upgrade_office_size(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_get_office(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Office, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_office(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Office, JsValue>>,
            JsValue,
        >;
        fn set_set_auto_job_assignment(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn set_auto_job_assignment(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        >;
        fn set_get_hire_ad_vert_count(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_hire_ad_vert_count(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_hire_ad_vert(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn hire_ad_vert(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_has_researched(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn has_researched(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_research(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn research(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
    }
    impl OfficeApi_Trait for OfficeApi {
        fn set_throw_party(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.throw_party = value;
            Ok(())
        }
        fn throw_party(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.throw_party.clone())
        }
        fn set_get_research_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_research_cost = value;
            Ok(())
        }
        fn get_research_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_research_cost.clone())
        }
        fn set_hire_employee(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    CorpEmployeePosition,
                ) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.hire_employee = value;
            Ok(())
        }
        fn hire_employee(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    CorpEmployeePosition,
                ) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.hire_employee.clone())
        }
        fn set_buy_tea(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.buy_tea = value;
            Ok(())
        }
        fn buy_tea(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.buy_tea.clone())
        }
        fn set_get_hire_ad_vert_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_hire_ad_vert_cost = value;
            Ok(())
        }
        fn get_hire_ad_vert_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_hire_ad_vert_cost.clone())
        }
        fn set_get_office_size_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_office_size_upgrade_cost = value;
            Ok(())
        }
        fn get_office_size_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_office_size_upgrade_cost.clone())
        }
        fn set_upgrade_office_size(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.upgrade_office_size = value;
            Ok(())
        }
        fn upgrade_office_size(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.upgrade_office_size.clone())
        }
        fn set_get_office(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Office, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_office = value;
            Ok(())
        }
        fn get_office(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Office, JsValue>>,
            JsValue,
        > {
            Ok(self.get_office.clone())
        }
        fn set_set_auto_job_assignment(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.set_auto_job_assignment = value;
            Ok(())
        }
        fn set_auto_job_assignment(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.set_auto_job_assignment.clone())
        }
        fn set_get_hire_ad_vert_count(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_hire_ad_vert_count = value;
            Ok(())
        }
        fn get_hire_ad_vert_count(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_hire_ad_vert_count.clone())
        }
        fn set_hire_ad_vert(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.hire_ad_vert = value;
            Ok(())
        }
        fn hire_ad_vert(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.hire_ad_vert.clone())
        }
        fn set_has_researched(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.has_researched = value;
            Ok(())
        }
        fn has_researched(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.has_researched.clone())
        }
        fn set_research(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.research = value;
            Ok(())
        }
        fn research(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.research.clone())
        }
    }
    impl OfficeApi {
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_office_size_upgrade_cost<S>(
            get_office_size_upgrade_cost: &std::rc::Rc<
                dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_office_size_upgrade_cost = get_office_size_upgrade_cost.clone();
            let get_office_size_upgrade_cost_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: f64|
                      -> std::result::Result<f64, JsValue> {
                    let result = get_office_size_upgrade_cost(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_office_size_upgrade_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_buy_tea<S>(
            buy_tea: &std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let buy_tea = buy_tea.clone();
            let buy_tea_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: JsValue| -> std::result::Result<bool, JsValue> {
                    let result = buy_tea(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue) -> std::result::Result<bool, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &buy_tea_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_auto_job_assignment<S>(
            set_auto_job_assignment: &std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_auto_job_assignment = set_auto_job_assignment.clone();
            let set_auto_job_assignment_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: String,
                      arg3: f64|
                      -> std::result::Result<bool, JsValue> {
                    let result = set_auto_job_assignment(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                        arg3,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, String, f64) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_auto_job_assignment_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_has_researched<S>(
            has_researched: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let has_researched = has_researched.clone();
            let has_researched_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<bool, JsValue> {
                    let result = has_researched(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &has_researched_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_research<S>(
            research: &std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let research = research.clone();
            let research_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<(), JsValue> {
                    let result = research(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<(), JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &research_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_throw_party<S>(
            throw_party: &std::rc::Rc<
                dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let throw_party = throw_party.clone();
            let throw_party_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: f64|
                      -> std::result::Result<f64, JsValue> {
                    let result = throw_party(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &throw_party_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_hire_ad_vert_cost<S>(
            get_hire_ad_vert_cost: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_hire_ad_vert_cost = get_hire_ad_vert_cost.clone();
            let get_hire_ad_vert_cost_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_hire_ad_vert_cost(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_hire_ad_vert_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_hire_employee<S>(
            hire_employee: &std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    CorpEmployeePosition,
                ) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hire_employee = hire_employee.clone();
            let hire_employee_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: JsValue,
                      arg2: JsValue|
                      -> std::result::Result<bool, JsValue> {
                    let result = hire_employee(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg2).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, JsValue) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &hire_employee_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_upgrade_office_size<S>(
            upgrade_office_size: &std::rc::Rc<
                dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let upgrade_office_size = upgrade_office_size.clone();
            let upgrade_office_size_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: JsValue, arg2: f64| -> std::result::Result<(), JsValue> {
                    let result = upgrade_office_size(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        arg2,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, JsValue, f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &upgrade_office_size_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_research_cost<S>(
            get_research_cost: &std::rc::Rc<
                dyn Fn(String, String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_research_cost = get_research_cost.clone();
            let get_research_cost_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: String| -> std::result::Result<f64, JsValue> {
                    let result = get_research_cost(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_research_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_office<S>(
            get_office: &std::rc::Rc<
                dyn Fn(String, CityName) -> std::result::Result<Office, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_office = get_office.clone();
            let get_office_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: JsValue| -> std::result::Result<JsValue, JsValue> {
                    let result = get_office(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(String, JsValue) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_office_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_hire_ad_vert_count<S>(
            get_hire_ad_vert_count: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_hire_ad_vert_count = get_hire_ad_vert_count.clone();
            let get_hire_ad_vert_count_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_hire_ad_vert_count(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_hire_ad_vert_count_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_hire_ad_vert<S>(
            hire_ad_vert: &std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hire_ad_vert = hire_ad_vert.clone();
            let hire_ad_vert_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<(), JsValue> {
                    let result = hire_ad_vert(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &hire_ad_vert_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_office_size_upgrade_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_office_size_upgrade_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_office_size_upgrade_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_buy_tea<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let buy_tea: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            buy_tea
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName) -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_auto_job_assignment<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, CityName, String, f64) -> std::result::Result<bool, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_auto_job_assignment: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_auto_job_assignment
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: String, arg3: f64| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                String,
                                f64,
                            )
                                -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_has_researched<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let has_researched: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            has_researched
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_research<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let research: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            research
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_throw_party<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let throw_party: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            throw_party
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName, f64) -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_hire_ad_vert_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_hire_ad_vert_cost: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_hire_ad_vert_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hire_employee<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    String,
                    CityName,
                    CorpEmployeePosition,
                ) -> std::result::Result<bool, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hire_employee: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            hire_employee
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: CityName, arg2: CorpEmployeePosition| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = ts_bindgen_rt::to_jsvalue(&arg2);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                CityName,
                                CorpEmployeePosition,
                            )
                                -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_upgrade_office_size<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let upgrade_office_size: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            upgrade_office_size
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName, f64) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_research_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_research_cost: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_research_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_office<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, CityName) -> std::result::Result<Office, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_office: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_office
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: CityName| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, CityName) -> std::result::Result<Office, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_hire_ad_vert_count<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_hire_ad_vert_count: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_hire_ad_vert_count
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hire_ad_vert<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hire_ad_vert: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            hire_ad_vert
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[wasm_bindgen]
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum CityName {
        Aevum = "Aevum",
        Chongqing = "Chongqing",
        Sector12 = "Sector-12",
        NewTokyo = "New Tokyo",
        Ishima = "Ishima",
        Volhaven = "Volhaven",
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NetscriptPortWriteParamsValue {
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Tix {
        #[serde(
            rename = "hasWSEAccount",
            serialize_with = "Tix::__TSB__serialize_has_wse_account",
            deserialize_with = "Tix::__TSB__deserialize_has_wse_account"
        )]
        pub has_wse_account: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getSymbols",
            serialize_with = "Tix::__TSB__serialize_get_symbols",
            deserialize_with = "Tix::__TSB__deserialize_get_symbols"
        )]
        pub get_symbols: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "sellStock",
            serialize_with = "Tix::__TSB__serialize_sell_stock",
            deserialize_with = "Tix::__TSB__deserialize_sell_stock"
        )]
        pub sell_stock: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "sellShort",
            serialize_with = "Tix::__TSB__serialize_sell_short",
            deserialize_with = "Tix::__TSB__deserialize_sell_short"
        )]
        pub sell_short: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "placeOrder",
            serialize_with = "Tix::__TSB__serialize_place_order",
            deserialize_with = "Tix::__TSB__deserialize_place_order"
        )]
        pub place_order: std::rc::Rc<
            dyn Fn(String, f64, f64, String, String) -> std::result::Result<bool, JsValue>,
        >,
        #[serde(
            rename = "buyStock",
            serialize_with = "Tix::__TSB__serialize_buy_stock",
            deserialize_with = "Tix::__TSB__deserialize_buy_stock"
        )]
        pub buy_stock: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getPosition",
            serialize_with = "Tix::__TSB__serialize_get_position",
            deserialize_with = "Tix::__TSB__deserialize_get_position"
        )]
        pub get_position:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<TixGetPositionReturn, JsValue>>,
        #[serde(
            rename = "getOrganization",
            serialize_with = "Tix::__TSB__serialize_get_organization",
            deserialize_with = "Tix::__TSB__deserialize_get_organization"
        )]
        pub get_organization: std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
        #[serde(
            rename = "purchase4SMarketDataTixApi",
            serialize_with = "Tix::__TSB__serialize_purchase4_s_market_data_tix_api",
            deserialize_with = "Tix::__TSB__deserialize_purchase4_s_market_data_tix_api"
        )]
        pub purchase4_s_market_data_tix_api:
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getForecast",
            serialize_with = "Tix::__TSB__serialize_get_forecast",
            deserialize_with = "Tix::__TSB__deserialize_get_forecast"
        )]
        pub get_forecast: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "purchaseTixApi",
            serialize_with = "Tix::__TSB__serialize_purchase_tix_api",
            deserialize_with = "Tix::__TSB__deserialize_purchase_tix_api"
        )]
        pub purchase_tix_api: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "has4SData",
            serialize_with = "Tix::__TSB__serialize_has4_s_data",
            deserialize_with = "Tix::__TSB__deserialize_has4_s_data"
        )]
        pub has4_s_data: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getPrice",
            serialize_with = "Tix::__TSB__serialize_get_price",
            deserialize_with = "Tix::__TSB__deserialize_get_price"
        )]
        pub get_price: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getOrders",
            serialize_with = "Tix::__TSB__serialize_get_orders",
            deserialize_with = "Tix::__TSB__deserialize_get_orders"
        )]
        pub get_orders: std::rc::Rc<dyn Fn() -> std::result::Result<StockOrder, JsValue>>,
        #[serde(
            rename = "getSaleGain",
            serialize_with = "Tix::__TSB__serialize_get_sale_gain",
            deserialize_with = "Tix::__TSB__deserialize_get_sale_gain"
        )]
        pub get_sale_gain:
            std::rc::Rc<dyn Fn(String, f64, String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "has4SDataTIXAPI",
            serialize_with = "Tix::__TSB__serialize_has4_s_data_tixapi",
            deserialize_with = "Tix::__TSB__deserialize_has4_s_data_tixapi"
        )]
        pub has4_s_data_tixapi: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "purchaseWseAccount",
            serialize_with = "Tix::__TSB__serialize_purchase_wse_account",
            deserialize_with = "Tix::__TSB__deserialize_purchase_wse_account"
        )]
        pub purchase_wse_account: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getVolatility",
            serialize_with = "Tix::__TSB__serialize_get_volatility",
            deserialize_with = "Tix::__TSB__deserialize_get_volatility"
        )]
        pub get_volatility: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "hasTIXAPIAccess",
            serialize_with = "Tix::__TSB__serialize_has_tixapi_access",
            deserialize_with = "Tix::__TSB__deserialize_has_tixapi_access"
        )]
        pub has_tixapi_access: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "purchase4SMarketData",
            serialize_with = "Tix::__TSB__serialize_purchase4_s_market_data",
            deserialize_with = "Tix::__TSB__deserialize_purchase4_s_market_data"
        )]
        pub purchase4_s_market_data: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "cancelOrder",
            serialize_with = "Tix::__TSB__serialize_cancel_order",
            deserialize_with = "Tix::__TSB__deserialize_cancel_order"
        )]
        pub cancel_order: std::rc::Rc<
            dyn Fn(String, f64, f64, String, String) -> std::result::Result<(), JsValue>,
        >,
        #[serde(
            rename = "getAskPrice",
            serialize_with = "Tix::__TSB__serialize_get_ask_price",
            deserialize_with = "Tix::__TSB__deserialize_get_ask_price"
        )]
        pub get_ask_price: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getMaxShares",
            serialize_with = "Tix::__TSB__serialize_get_max_shares",
            deserialize_with = "Tix::__TSB__deserialize_get_max_shares"
        )]
        pub get_max_shares: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "buyShort",
            serialize_with = "Tix::__TSB__serialize_buy_short",
            deserialize_with = "Tix::__TSB__deserialize_buy_short"
        )]
        pub buy_short: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getPurchaseCost",
            serialize_with = "Tix::__TSB__serialize_get_purchase_cost",
            deserialize_with = "Tix::__TSB__deserialize_get_purchase_cost"
        )]
        pub get_purchase_cost:
            std::rc::Rc<dyn Fn(String, f64, String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getBidPrice",
            serialize_with = "Tix::__TSB__serialize_get_bid_price",
            deserialize_with = "Tix::__TSB__deserialize_get_bid_price"
        )]
        pub get_bid_price: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait Tix_Trait {
        fn set_get_sale_gain(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_sale_gain(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_bid_price(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_bid_price(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_purchase_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_purchase_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_organization(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_organization(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
            JsValue,
        >;
        fn set_sell_short(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn sell_short(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_has_tixapi_access(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn has_tixapi_access(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_get_ask_price(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_ask_price(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_has_wse_account(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn has_wse_account(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_has4_s_data_tixapi(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn has4_s_data_tixapi(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_get_symbols(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_symbols(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
        fn set_get_max_shares(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_max_shares(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_volatility(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_volatility(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_buy_stock(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn buy_stock(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_buy_short(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn buy_short(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_purchase_wse_account(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn purchase_wse_account(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_cancel_order(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, f64, f64, String, String) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn cancel_order(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, f64, f64, String, String) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        >;
        fn set_place_order(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, f64, f64, String, String) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn place_order(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, f64, f64, String, String) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        >;
        fn set_purchase4_s_market_data_tix_api(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn purchase4_s_market_data_tix_api(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_get_forecast(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_forecast(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_price(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_price(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_orders(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<StockOrder, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_orders(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<StockOrder, JsValue>>,
            JsValue,
        >;
        fn set_sell_stock(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn sell_stock(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_get_position(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String) -> std::result::Result<TixGetPositionReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn get_position(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<TixGetPositionReturn, JsValue>>,
            JsValue,
        >;
        fn set_purchase_tix_api(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn purchase_tix_api(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_has4_s_data(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn has4_s_data(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
        fn set_purchase4_s_market_data(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn purchase4_s_market_data(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>;
    }
    impl Tix_Trait for Tix {
        fn set_get_sale_gain(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_sale_gain = value;
            Ok(())
        }
        fn get_sale_gain(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_sale_gain.clone())
        }
        fn set_get_bid_price(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_bid_price = value;
            Ok(())
        }
        fn get_bid_price(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_bid_price.clone())
        }
        fn set_get_purchase_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64, String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_purchase_cost = value;
            Ok(())
        }
        fn get_purchase_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64, String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_purchase_cost.clone())
        }
        fn set_get_organization(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_organization = value;
            Ok(())
        }
        fn get_organization(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
            JsValue,
        > {
            Ok(self.get_organization.clone())
        }
        fn set_sell_short(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.sell_short = value;
            Ok(())
        }
        fn sell_short(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.sell_short.clone())
        }
        fn set_has_tixapi_access(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.has_tixapi_access = value;
            Ok(())
        }
        fn has_tixapi_access(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.has_tixapi_access.clone())
        }
        fn set_get_ask_price(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_ask_price = value;
            Ok(())
        }
        fn get_ask_price(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_ask_price.clone())
        }
        fn set_has_wse_account(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.has_wse_account = value;
            Ok(())
        }
        fn has_wse_account(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.has_wse_account.clone())
        }
        fn set_has4_s_data_tixapi(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.has4_s_data_tixapi = value;
            Ok(())
        }
        fn has4_s_data_tixapi(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.has4_s_data_tixapi.clone())
        }
        fn set_get_symbols(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_symbols = value;
            Ok(())
        }
        fn get_symbols(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_symbols.clone())
        }
        fn set_get_max_shares(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_max_shares = value;
            Ok(())
        }
        fn get_max_shares(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_max_shares.clone())
        }
        fn set_get_volatility(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_volatility = value;
            Ok(())
        }
        fn get_volatility(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_volatility.clone())
        }
        fn set_buy_stock(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.buy_stock = value;
            Ok(())
        }
        fn buy_stock(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.buy_stock.clone())
        }
        fn set_buy_short(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.buy_short = value;
            Ok(())
        }
        fn buy_short(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.buy_short.clone())
        }
        fn set_purchase_wse_account(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.purchase_wse_account = value;
            Ok(())
        }
        fn purchase_wse_account(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.purchase_wse_account.clone())
        }
        fn set_cancel_order(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, f64, f64, String, String) -> std::result::Result<(), JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.cancel_order = value;
            Ok(())
        }
        fn cancel_order(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, f64, f64, String, String) -> std::result::Result<(), JsValue>,
            >,
            JsValue,
        > {
            Ok(self.cancel_order.clone())
        }
        fn set_place_order(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String, f64, f64, String, String) -> std::result::Result<bool, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.place_order = value;
            Ok(())
        }
        fn place_order(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, f64, f64, String, String) -> std::result::Result<bool, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.place_order.clone())
        }
        fn set_purchase4_s_market_data_tix_api(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.purchase4_s_market_data_tix_api = value;
            Ok(())
        }
        fn purchase4_s_market_data_tix_api(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.purchase4_s_market_data_tix_api.clone())
        }
        fn set_get_forecast(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_forecast = value;
            Ok(())
        }
        fn get_forecast(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_forecast.clone())
        }
        fn set_get_price(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_price = value;
            Ok(())
        }
        fn get_price(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_price.clone())
        }
        fn set_get_orders(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<StockOrder, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_orders = value;
            Ok(())
        }
        fn get_orders(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<StockOrder, JsValue>>,
            JsValue,
        > {
            Ok(self.get_orders.clone())
        }
        fn set_sell_stock(
            &mut self,
            value: std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.sell_stock = value;
            Ok(())
        }
        fn sell_stock(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.sell_stock.clone())
        }
        fn set_get_position(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(String) -> std::result::Result<TixGetPositionReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.get_position = value;
            Ok(())
        }
        fn get_position(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<TixGetPositionReturn, JsValue>>,
            JsValue,
        > {
            Ok(self.get_position.clone())
        }
        fn set_purchase_tix_api(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.purchase_tix_api = value;
            Ok(())
        }
        fn purchase_tix_api(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.purchase_tix_api.clone())
        }
        fn set_has4_s_data(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.has4_s_data = value;
            Ok(())
        }
        fn has4_s_data(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.has4_s_data.clone())
        }
        fn set_purchase4_s_market_data(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.purchase4_s_market_data = value;
            Ok(())
        }
        fn purchase4_s_market_data(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>, JsValue>
        {
            Ok(self.purchase4_s_market_data.clone())
        }
    }
    impl Tix {
        #[allow(non_snake_case)]
        fn __TSB__serialize_has_wse_account<S>(
            has_wse_account: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let has_wse_account = has_wse_account.clone();
            let has_wse_account_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = has_wse_account()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &has_wse_account_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_symbols<S>(
            get_symbols: &std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_symbols = get_symbols.clone();
            let get_symbols_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_symbols()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_symbols_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_sell_stock<S>(
            sell_stock: &std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let sell_stock = sell_stock.clone();
            let sell_stock_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = sell_stock(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &sell_stock_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_sell_short<S>(
            sell_short: &std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let sell_short = sell_short.clone();
            let sell_short_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = sell_short(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &sell_short_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_place_order<S>(
            place_order: &std::rc::Rc<
                dyn Fn(String, f64, f64, String, String) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let place_order = place_order.clone();
            let place_order_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: f64,
                      arg2: f64,
                      arg3: String,
                      arg4: String|
                      -> std::result::Result<bool, JsValue> {
                    let result = place_order(arg0, arg1, arg2, arg3, arg4)?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(String, f64, f64, String, String) -> std::result::Result<bool, JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &place_order_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_buy_stock<S>(
            buy_stock: &std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let buy_stock = buy_stock.clone();
            let buy_stock_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = buy_stock(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &buy_stock_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_position<S>(
            get_position: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<TixGetPositionReturn, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_position = get_position.clone();
            let get_position_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<JsValue, JsValue> {
                    let result = get_position(arg0)?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        let result_item_0 = result.0;
                        result_array.push(&JsValue::from(result_item_0));
                        let result_item_1 = result.1;
                        result_array.push(&JsValue::from(result_item_1));
                        let result_item_2 = result.2;
                        result_array.push(&JsValue::from(result_item_2));
                        let result_item_3 = result.3;
                        result_array.push(&JsValue::from(result_item_3));
                        result_array.into()
                    })
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_position_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_organization<S>(
            get_organization: &std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_organization = get_organization.clone();
            let get_organization_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<String, JsValue> {
                    let result = get_organization(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<String, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_organization_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_purchase4_s_market_data_tix_api<S>(
            purchase4_s_market_data_tix_api: &std::rc::Rc<
                dyn Fn() -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let purchase4_s_market_data_tix_api = purchase4_s_market_data_tix_api.clone();
            let purchase4_s_market_data_tix_api_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = purchase4_s_market_data_tix_api()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &purchase4_s_market_data_tix_api_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_forecast<S>(
            get_forecast: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_forecast = get_forecast.clone();
            let get_forecast_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_forecast(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_forecast_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_purchase_tix_api<S>(
            purchase_tix_api: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let purchase_tix_api = purchase_tix_api.clone();
            let purchase_tix_api_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = purchase_tix_api()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &purchase_tix_api_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_has4_s_data<S>(
            has4_s_data: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let has4_s_data = has4_s_data.clone();
            let has4_s_data_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = has4_s_data()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &has4_s_data_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_price<S>(
            get_price: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_price = get_price.clone();
            let get_price_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_price(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &get_price_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_orders<S>(
            get_orders: &std::rc::Rc<dyn Fn() -> std::result::Result<StockOrder, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_orders = get_orders.clone();
            let get_orders_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_orders()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_orders_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_sale_gain<S>(
            get_sale_gain: &std::rc::Rc<
                dyn Fn(String, f64, String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_sale_gain = get_sale_gain.clone();
            let get_sale_gain_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: f64, arg2: String| -> std::result::Result<f64, JsValue> {
                    let result = get_sale_gain(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, f64, String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_sale_gain_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_has4_s_data_tixapi<S>(
            has4_s_data_tixapi: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let has4_s_data_tixapi = has4_s_data_tixapi.clone();
            let has4_s_data_tixapi_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = has4_s_data_tixapi()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &has4_s_data_tixapi_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_purchase_wse_account<S>(
            purchase_wse_account: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let purchase_wse_account = purchase_wse_account.clone();
            let purchase_wse_account_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = purchase_wse_account()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &purchase_wse_account_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_volatility<S>(
            get_volatility: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_volatility = get_volatility.clone();
            let get_volatility_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_volatility(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_volatility_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_has_tixapi_access<S>(
            has_tixapi_access: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let has_tixapi_access = has_tixapi_access.clone();
            let has_tixapi_access_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = has_tixapi_access()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &has_tixapi_access_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_purchase4_s_market_data<S>(
            purchase4_s_market_data: &std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let purchase4_s_market_data = purchase4_s_market_data.clone();
            let purchase4_s_market_data_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<bool, JsValue> {
                    let result = purchase4_s_market_data()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &purchase4_s_market_data_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_cancel_order<S>(
            cancel_order: &std::rc::Rc<
                dyn Fn(String, f64, f64, String, String) -> std::result::Result<(), JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let cancel_order = cancel_order.clone();
            let cancel_order_closure = Closure::wrap(Box::new(
                move |arg0: String,
                      arg1: f64,
                      arg2: f64,
                      arg3: String,
                      arg4: String|
                      -> std::result::Result<(), JsValue> {
                    let result = cancel_order(arg0, arg1, arg2, arg3, arg4)?;
                    Ok(result)
                },
            )
                as Box<
                    dyn Fn(String, f64, f64, String, String) -> std::result::Result<(), JsValue>,
                >);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &cancel_order_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_ask_price<S>(
            get_ask_price: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_ask_price = get_ask_price.clone();
            let get_ask_price_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_ask_price(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_ask_price_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_max_shares<S>(
            get_max_shares: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_max_shares = get_max_shares.clone();
            let get_max_shares_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_max_shares(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_max_shares_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_buy_short<S>(
            buy_short: &std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let buy_short = buy_short.clone();
            let buy_short_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = buy_short(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &buy_short_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_purchase_cost<S>(
            get_purchase_cost: &std::rc::Rc<
                dyn Fn(String, f64, String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_purchase_cost = get_purchase_cost.clone();
            let get_purchase_cost_closure = Closure::wrap(Box::new(
                move |arg0: String, arg1: f64, arg2: String| -> std::result::Result<f64, JsValue> {
                    let result = get_purchase_cost(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String, f64, String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_purchase_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_bid_price<S>(
            get_bid_price: &std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_bid_price = get_bid_price.clone();
            let get_bid_price_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_bid_price(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_bid_price_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_has_wse_account<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let has_wse_account: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            has_wse_account
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_symbols<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_symbols: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_symbols
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_sell_stock<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let sell_stock: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            sell_stock
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_sell_short<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let sell_short: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            sell_short
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_place_order<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, f64, f64, String, String) -> std::result::Result<bool, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let place_order: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            place_order
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: f64, arg2: f64, arg3: String, arg4: String| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = JsValue::from(arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let arg4 = JsValue::from(arg4);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            _Args.push(&arg4);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                f64,
                                f64,
                                String,
                                String,
                            )
                                -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_buy_stock<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let buy_stock: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            buy_stock
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_position<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<TixGetPositionReturn, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_position: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_position
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String) -> std::result::Result<TixGetPositionReturn, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_organization<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_organization: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_organization
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<String, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_purchase4_s_market_data_tix_api<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let purchase4_s_market_data_tix_api: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            purchase4_s_market_data_tix_api
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_forecast<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_forecast: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_forecast
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_purchase_tix_api<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let purchase_tix_api: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            purchase_tix_api
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_has4_s_data<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let has4_s_data: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            has4_s_data
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_price<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_price: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_price
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_orders<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<StockOrder, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_orders: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_orders
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<StockOrder, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_sale_gain<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64, String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_sale_gain: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_sale_gain
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: f64, arg2: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, f64, String) -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_has4_s_data_tixapi<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let has4_s_data_tixapi: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            has4_s_data_tixapi
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_purchase_wse_account<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let purchase_wse_account: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            purchase_wse_account
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_volatility<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_volatility: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_volatility
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_has_tixapi_access<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let has_tixapi_access: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            has_tixapi_access
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_purchase4_s_market_data<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let purchase4_s_market_data: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            purchase4_s_market_data
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_cancel_order<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(String, f64, f64, String, String) -> std::result::Result<(), JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let cancel_order: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            cancel_order
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: String, arg1: f64, arg2: f64, arg3: String, arg4: String| {
                            let arg0 = JsValue::from(arg0);
                            let arg1 = JsValue::from(arg1);
                            let arg2 = JsValue::from(arg2);
                            let arg3 = JsValue::from(arg3);
                            let arg4 = JsValue::from(arg4);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            _Args.push(&arg3);
                            _Args.push(&arg4);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                String,
                                f64,
                                f64,
                                String,
                                String,
                            ) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_ask_price<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_ask_price: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_ask_price
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_max_shares<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_max_shares: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_max_shares
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_buy_short<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let buy_short: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            buy_short
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_purchase_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String, f64, String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_purchase_cost: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_purchase_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String, arg1: f64, arg2: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(String, f64, String) -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_bid_price<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_bid_price: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_bid_price
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct HackingMultipliers {
        #[serde(rename = "growth")]
        pub growth: f64,
        #[serde(rename = "money")]
        pub money: f64,
        #[serde(rename = "chance")]
        pub chance: f64,
        #[serde(rename = "speed")]
        pub speed: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait HackingMultipliers_Trait {
        fn set_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn money(&self) -> std::result::Result<f64, JsValue>;
        fn set_chance(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn chance(&self) -> std::result::Result<f64, JsValue>;
        fn set_growth(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn growth(&self) -> std::result::Result<f64, JsValue>;
        fn set_speed(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn speed(&self) -> std::result::Result<f64, JsValue>;
    }
    impl HackingMultipliers_Trait for HackingMultipliers {
        fn set_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.money = value;
            Ok(())
        }
        fn money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.money)
        }
        fn set_chance(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.chance = value;
            Ok(())
        }
        fn chance(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.chance)
        }
        fn set_growth(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.growth = value;
            Ok(())
        }
        fn growth(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.growth)
        }
        fn set_speed(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.speed = value;
            Ok(())
        }
        fn speed(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.speed)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct StockOrder {
        #[serde(flatten)]
        pub extra_fields: std::collections::HashMap<String, Vec<StockOrderObject>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait StockOrder_Trait {}
    impl StockOrder_Trait for StockOrder {}
    #[wasm_bindgen]
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum LocationName {
        AevumAeroCorp = "AeroCorp",
        AevumBachmanAndAssociates = "Bachman & Associates",
        AevumClarkeIncorporated = "Clarke Incorporated",
        AevumCrushFitnessGym = "Crush Fitness Gym",
        AevumECorp = "ECorp",
        AevumFulcrumTechnologies = "Fulcrum Technologies",
        AevumGalacticCybersystems = "Galactic Cybersystems",
        AevumNetLinkTechnologies = "NetLink Technologies",
        AevumPolice = "Aevum Police Headquarters",
        AevumRhoConstruction = "Rho Construction",
        AevumSnapFitnessGym = "Snap Fitness Gym",
        AevumSummitUniversity = "Summit University",
        AevumWatchdogSecurity = "Watchdog Security",
        AevumCasino = "Iker Molina Casino",
        ChongqingKuaiGongInternational = "KuaiGong International",
        ChongqingSolarisSpaceSystems = "Solaris Space Systems",
        ChongqingChurchOfTheMachineGod = "Church of the Machine God",
        Sector12AlphaEnterprises = "Alpha Enterprises",
        Sector12BladeIndustries = "Blade Industries",
        Sector12Cia = "Central Intelligence Agency",
        Sector12CarmichaelSecurity = "Carmichael Security",
        Sector12CityHall = "Sector-12 City Hall",
        Sector12DeltaOne = "DeltaOne",
        Sector12FoodNStuff = "FoodNStuff",
        Sector12FourSigma = "Four Sigma",
        Sector12IcarusMicrosystems = "Icarus Microsystems",
        Sector12IronGym = "Iron Gym",
        Sector12JoesGuns = "Joe's Guns",
        Sector12MegaCorp = "MegaCorp",
        Sector12Nsa = "National Security Agency",
        Sector12PowerhouseGym = "Powerhouse Gym",
        Sector12RothmanUniversity = "Rothman University",
        Sector12UniversalEnergy = "Universal Energy",
        NewTokyoDefComm = "DefComm",
        NewTokyoGlobalPharmaceuticals = "Global Pharmaceuticals",
        NewTokyoNoodleBar = "Noodle Bar",
        NewTokyoVitaLife = "VitaLife",
        NewTokyoArcade = "Arcade",
        IshimaNovaMedical = "Nova Medical",
        IshimaOmegaSoftware = "Omega Software",
        IshimaStormTechnologies = "Storm Technologies",
        IshimaGlitch = "0x6C1",
        VolhavenCompuTek = "CompuTek",
        VolhavenHeliosLabs = "Helios Labs",
        VolhavenLexoCorp = "LexoCorp",
        VolhavenMilleniumFitnessGym = "Millenium Fitness Gym",
        VolhavenNwo = "NWO",
        VolhavenOmniTekIncorporated = "OmniTek Incorporated",
        VolhavenOmniaCybersystems = "Omnia Cybersystems",
        VolhavenSysCoreSecurities = "SysCore Securities",
        VolhavenZbInstituteOfTechnology = "ZB Institute of Technology",
        Hospital = "Hospital",
        Slums = "The Slums",
        TravelAgency = "Travel Agency",
        WorldStockExchange = "World Stock Exchange",
        Void = "The Void",
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Warehouse {
        #[serde(rename = "sizeUsed")]
        pub size_used: f64,
        #[serde(rename = "city")]
        pub city: CityName,
        #[serde(rename = "level")]
        pub level: f64,
        #[serde(rename = "smartSupplyEnabled")]
        pub smart_supply_enabled: bool,
        #[serde(rename = "size")]
        pub size: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait Warehouse_Trait {
        fn set_smart_supply_enabled(&mut self, value: bool) -> std::result::Result<(), JsValue>;
        fn smart_supply_enabled(&self) -> std::result::Result<bool, JsValue>;
        fn set_level(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn level(&self) -> std::result::Result<f64, JsValue>;
        fn set_city(&mut self, value: CityName) -> std::result::Result<(), JsValue>;
        fn city(&self) -> std::result::Result<CityName, JsValue>;
        fn set_size_used(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn size_used(&self) -> std::result::Result<f64, JsValue>;
        fn set_size(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn size(&self) -> std::result::Result<f64, JsValue>;
    }
    impl Warehouse_Trait for Warehouse {
        fn set_smart_supply_enabled(&mut self, value: bool) -> std::result::Result<(), JsValue> {
            self.smart_supply_enabled = value;
            Ok(())
        }
        fn smart_supply_enabled(&self) -> std::result::Result<bool, JsValue> {
            Ok(self.smart_supply_enabled)
        }
        fn set_level(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.level = value;
            Ok(())
        }
        fn level(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.level)
        }
        fn set_city(&mut self, value: CityName) -> std::result::Result<(), JsValue> {
            self.city = value;
            Ok(())
        }
        fn city(&self) -> std::result::Result<CityName, JsValue> {
            Ok(self.city.clone())
        }
        fn set_size_used(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.size_used = value;
            Ok(())
        }
        fn size_used(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.size_used)
        }
        fn set_size(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.size = value;
            Ok(())
        }
        fn size(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.size)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct InfiltrationReward {
        #[serde(rename = "SoARep")]
        pub so_a_rep: f64,
        #[serde(rename = "tradeRep")]
        pub trade_rep: f64,
        #[serde(rename = "sellCash")]
        pub sell_cash: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait InfiltrationReward_Trait {
        fn set_sell_cash(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn sell_cash(&self) -> std::result::Result<f64, JsValue>;
        fn set_so_a_rep(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn so_a_rep(&self) -> std::result::Result<f64, JsValue>;
        fn set_trade_rep(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn trade_rep(&self) -> std::result::Result<f64, JsValue>;
    }
    impl InfiltrationReward_Trait for InfiltrationReward {
        fn set_sell_cash(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.sell_cash = value;
            Ok(())
        }
        fn sell_cash(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.sell_cash)
        }
        fn set_so_a_rep(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.so_a_rep = value;
            Ok(())
        }
        fn so_a_rep(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.so_a_rep)
        }
        fn set_trade_rep(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.trade_rep = value;
            Ok(())
        }
        fn trade_rep(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.trade_rep)
        }
    }
    #[allow(dead_code, non_camel_case_types)]
    type CorpUnlockName = CorpUnlockNameAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct AutocompleteDataFlagsParamsSchema(
        pub String,
        pub AutocompleteDataFlagsParamsSchemaTuple1,
    );
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsIsRunningParamsArgs {
        Bool(bool),
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum MaterialDemand {
        F64(f64),
        #[serde(
            serialize_with = "ts_bindgen_rt::serialize_undefined",
            deserialize_with = "ts_bindgen_rt::deserialize_undefined"
        )]
        TsBindgenRtUndefined,
    }
    #[allow(dead_code, non_camel_case_types)]
    type SleeveClassTask = SleeveClassTaskAliased;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Multipliers {
        #[serde(rename = "strength_exp")]
        pub strength_exp: f64,
        #[serde(rename = "dexterity")]
        pub dexterity: f64,
        #[serde(rename = "hacking_chance")]
        pub hacking_chance: f64,
        #[serde(rename = "faction_rep")]
        pub faction_rep: f64,
        #[serde(rename = "crime_success")]
        pub crime_success: f64,
        #[serde(rename = "charisma")]
        pub charisma: f64,
        #[serde(rename = "hacknet_node_level_cost")]
        pub hacknet_node_level_cost: f64,
        #[serde(rename = "hacking_exp")]
        pub hacking_exp: f64,
        #[serde(rename = "hacking_speed")]
        pub hacking_speed: f64,
        #[serde(rename = "dexterity_exp")]
        pub dexterity_exp: f64,
        #[serde(rename = "hacknet_node_money")]
        pub hacknet_node_money: f64,
        #[serde(rename = "bladeburner_analysis")]
        pub bladeburner_analysis: f64,
        #[serde(rename = "work_money")]
        pub work_money: f64,
        #[serde(rename = "hacking_money")]
        pub hacking_money: f64,
        #[serde(rename = "hacknet_node_purchase_cost")]
        pub hacknet_node_purchase_cost: f64,
        #[serde(rename = "bladeburner_stamina_gain")]
        pub bladeburner_stamina_gain: f64,
        #[serde(rename = "hacknet_node_ram_cost")]
        pub hacknet_node_ram_cost: f64,
        #[serde(rename = "company_rep")]
        pub company_rep: f64,
        #[serde(rename = "defense_exp")]
        pub defense_exp: f64,
        #[serde(rename = "agility_exp")]
        pub agility_exp: f64,
        #[serde(rename = "crime_money")]
        pub crime_money: f64,
        #[serde(rename = "hacknet_node_core_cost")]
        pub hacknet_node_core_cost: f64,
        #[serde(rename = "hacking_grow")]
        pub hacking_grow: f64,
        #[serde(rename = "charisma_exp")]
        pub charisma_exp: f64,
        #[serde(rename = "agility")]
        pub agility: f64,
        #[serde(rename = "strength")]
        pub strength: f64,
        #[serde(rename = "bladeburner_max_stamina")]
        pub bladeburner_max_stamina: f64,
        #[serde(rename = "hacking")]
        pub hacking: f64,
        #[serde(rename = "defense")]
        pub defense: f64,
        #[serde(rename = "bladeburner_success_chance")]
        pub bladeburner_success_chance: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait Multipliers_Trait {
        fn set_hacking_grow(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hacking_grow(&self) -> std::result::Result<f64, JsValue>;
        fn set_agility(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn agility(&self) -> std::result::Result<f64, JsValue>;
        fn set_dexterity(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn dexterity(&self) -> std::result::Result<f64, JsValue>;
        fn set_hacking_chance(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hacking_chance(&self) -> std::result::Result<f64, JsValue>;
        fn set_crime_success(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn crime_success(&self) -> std::result::Result<f64, JsValue>;
        fn set_charisma_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn charisma_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_hacknet_node_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hacknet_node_money(&self) -> std::result::Result<f64, JsValue>;
        fn set_hacknet_node_purchase_cost(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue>;
        fn hacknet_node_purchase_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_hacknet_node_core_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hacknet_node_core_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_agility_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn agility_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_charisma(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn charisma(&self) -> std::result::Result<f64, JsValue>;
        fn set_bladeburner_stamina_gain(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn bladeburner_stamina_gain(&self) -> std::result::Result<f64, JsValue>;
        fn set_work_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn work_money(&self) -> std::result::Result<f64, JsValue>;
        fn set_hacknet_node_level_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hacknet_node_level_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_hacking(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hacking(&self) -> std::result::Result<f64, JsValue>;
        fn set_bladeburner_max_stamina(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn bladeburner_max_stamina(&self) -> std::result::Result<f64, JsValue>;
        fn set_crime_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn crime_money(&self) -> std::result::Result<f64, JsValue>;
        fn set_hacknet_node_ram_cost(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hacknet_node_ram_cost(&self) -> std::result::Result<f64, JsValue>;
        fn set_bladeburner_analysis(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn bladeburner_analysis(&self) -> std::result::Result<f64, JsValue>;
        fn set_defense(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn defense(&self) -> std::result::Result<f64, JsValue>;
        fn set_company_rep(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn company_rep(&self) -> std::result::Result<f64, JsValue>;
        fn set_hacking_speed(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hacking_speed(&self) -> std::result::Result<f64, JsValue>;
        fn set_strength(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn strength(&self) -> std::result::Result<f64, JsValue>;
        fn set_faction_rep(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn faction_rep(&self) -> std::result::Result<f64, JsValue>;
        fn set_bladeburner_success_chance(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue>;
        fn bladeburner_success_chance(&self) -> std::result::Result<f64, JsValue>;
        fn set_hacking_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hacking_money(&self) -> std::result::Result<f64, JsValue>;
        fn set_hacking_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hacking_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_dexterity_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn dexterity_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_defense_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn defense_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_strength_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn strength_exp(&self) -> std::result::Result<f64, JsValue>;
    }
    impl Multipliers_Trait for Multipliers {
        fn set_hacking_grow(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hacking_grow = value;
            Ok(())
        }
        fn hacking_grow(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacking_grow)
        }
        fn set_agility(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.agility = value;
            Ok(())
        }
        fn agility(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.agility)
        }
        fn set_dexterity(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.dexterity = value;
            Ok(())
        }
        fn dexterity(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.dexterity)
        }
        fn set_hacking_chance(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hacking_chance = value;
            Ok(())
        }
        fn hacking_chance(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacking_chance)
        }
        fn set_crime_success(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.crime_success = value;
            Ok(())
        }
        fn crime_success(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.crime_success)
        }
        fn set_charisma_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.charisma_exp = value;
            Ok(())
        }
        fn charisma_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.charisma_exp)
        }
        fn set_hacknet_node_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hacknet_node_money = value;
            Ok(())
        }
        fn hacknet_node_money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacknet_node_money)
        }
        fn set_hacknet_node_purchase_cost(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue> {
            self.hacknet_node_purchase_cost = value;
            Ok(())
        }
        fn hacknet_node_purchase_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacknet_node_purchase_cost)
        }
        fn set_hacknet_node_core_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hacknet_node_core_cost = value;
            Ok(())
        }
        fn hacknet_node_core_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacknet_node_core_cost)
        }
        fn set_agility_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.agility_exp = value;
            Ok(())
        }
        fn agility_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.agility_exp)
        }
        fn set_charisma(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.charisma = value;
            Ok(())
        }
        fn charisma(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.charisma)
        }
        fn set_bladeburner_stamina_gain(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.bladeburner_stamina_gain = value;
            Ok(())
        }
        fn bladeburner_stamina_gain(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.bladeburner_stamina_gain)
        }
        fn set_work_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.work_money = value;
            Ok(())
        }
        fn work_money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.work_money)
        }
        fn set_hacknet_node_level_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hacknet_node_level_cost = value;
            Ok(())
        }
        fn hacknet_node_level_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacknet_node_level_cost)
        }
        fn set_hacking(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hacking = value;
            Ok(())
        }
        fn hacking(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacking)
        }
        fn set_bladeburner_max_stamina(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.bladeburner_max_stamina = value;
            Ok(())
        }
        fn bladeburner_max_stamina(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.bladeburner_max_stamina)
        }
        fn set_crime_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.crime_money = value;
            Ok(())
        }
        fn crime_money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.crime_money)
        }
        fn set_hacknet_node_ram_cost(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hacknet_node_ram_cost = value;
            Ok(())
        }
        fn hacknet_node_ram_cost(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacknet_node_ram_cost)
        }
        fn set_bladeburner_analysis(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.bladeburner_analysis = value;
            Ok(())
        }
        fn bladeburner_analysis(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.bladeburner_analysis)
        }
        fn set_defense(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.defense = value;
            Ok(())
        }
        fn defense(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.defense)
        }
        fn set_company_rep(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.company_rep = value;
            Ok(())
        }
        fn company_rep(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.company_rep)
        }
        fn set_hacking_speed(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hacking_speed = value;
            Ok(())
        }
        fn hacking_speed(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacking_speed)
        }
        fn set_strength(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.strength = value;
            Ok(())
        }
        fn strength(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.strength)
        }
        fn set_faction_rep(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.faction_rep = value;
            Ok(())
        }
        fn faction_rep(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.faction_rep)
        }
        fn set_bladeburner_success_chance(
            &mut self,
            value: f64,
        ) -> std::result::Result<(), JsValue> {
            self.bladeburner_success_chance = value;
            Ok(())
        }
        fn bladeburner_success_chance(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.bladeburner_success_chance)
        }
        fn set_hacking_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hacking_money = value;
            Ok(())
        }
        fn hacking_money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacking_money)
        }
        fn set_hacking_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hacking_exp = value;
            Ok(())
        }
        fn hacking_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacking_exp)
        }
        fn set_dexterity_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.dexterity_exp = value;
            Ok(())
        }
        fn dexterity_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.dexterity_exp)
        }
        fn set_defense_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.defense_exp = value;
            Ok(())
        }
        fn defense_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.defense_exp)
        }
        fn set_strength_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.strength_exp = value;
            Ok(())
        }
        fn strength_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.strength_exp)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct GangOtherInfo {
        #[serde(flatten)]
        pub extra_fields: std::collections::HashMap<String, GangOtherInfoObject>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait GangOtherInfo_Trait {}
    impl GangOtherInfo_Trait for GangOtherInfo {}
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsFlagsReturn {
        VecOfString(Vec<String>),
        ScriptArg(ScriptArg),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsToastParamsDuration {
        TsBindgenRtNull,
        F64(f64),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum ProductDesiredSellAmount {
        F64(f64),
        String(String),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct GangFormulas {
        #[serde(
            rename = "wantedLevelGain",
            serialize_with = "GangFormulas::__TSB__serialize_wanted_level_gain",
            deserialize_with = "GangFormulas::__TSB__deserialize_wanted_level_gain"
        )]
        pub wanted_level_gain: std::rc::Rc<
            dyn Fn(GangGenInfo, GangMemberInfo, GangTaskStats) -> std::result::Result<f64, JsValue>,
        >,
        #[serde(
            rename = "ascensionMultiplier",
            serialize_with = "GangFormulas::__TSB__serialize_ascension_multiplier",
            deserialize_with = "GangFormulas::__TSB__deserialize_ascension_multiplier"
        )]
        pub ascension_multiplier: std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "respectGain",
            serialize_with = "GangFormulas::__TSB__serialize_respect_gain",
            deserialize_with = "GangFormulas::__TSB__deserialize_respect_gain"
        )]
        pub respect_gain: std::rc::Rc<
            dyn Fn(GangGenInfo, GangMemberInfo, GangTaskStats) -> std::result::Result<f64, JsValue>,
        >,
        #[serde(
            rename = "ascensionPointsGain",
            serialize_with = "GangFormulas::__TSB__serialize_ascension_points_gain",
            deserialize_with = "GangFormulas::__TSB__deserialize_ascension_points_gain"
        )]
        pub ascension_points_gain: std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "wantedPenalty",
            serialize_with = "GangFormulas::__TSB__serialize_wanted_penalty",
            deserialize_with = "GangFormulas::__TSB__deserialize_wanted_penalty"
        )]
        pub wanted_penalty: std::rc::Rc<dyn Fn(GangGenInfo) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "moneyGain",
            serialize_with = "GangFormulas::__TSB__serialize_money_gain",
            deserialize_with = "GangFormulas::__TSB__deserialize_money_gain"
        )]
        pub money_gain: std::rc::Rc<
            dyn Fn(GangGenInfo, GangMemberInfo, GangTaskStats) -> std::result::Result<f64, JsValue>,
        >,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait GangFormulas_Trait {
        fn set_money_gain(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    GangGenInfo,
                    GangMemberInfo,
                    GangTaskStats,
                ) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn money_gain(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    GangGenInfo,
                    GangMemberInfo,
                    GangTaskStats,
                ) -> std::result::Result<f64, JsValue>,
            >,
            JsValue,
        >;
        fn set_ascension_multiplier(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn ascension_multiplier(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_wanted_level_gain(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    GangGenInfo,
                    GangMemberInfo,
                    GangTaskStats,
                ) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn wanted_level_gain(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    GangGenInfo,
                    GangMemberInfo,
                    GangTaskStats,
                ) -> std::result::Result<f64, JsValue>,
            >,
            JsValue,
        >;
        fn set_ascension_points_gain(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn ascension_points_gain(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_wanted_penalty(
            &mut self,
            value: std::rc::Rc<dyn Fn(GangGenInfo) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn wanted_penalty(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(GangGenInfo) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_respect_gain(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    GangGenInfo,
                    GangMemberInfo,
                    GangTaskStats,
                ) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn respect_gain(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    GangGenInfo,
                    GangMemberInfo,
                    GangTaskStats,
                ) -> std::result::Result<f64, JsValue>,
            >,
            JsValue,
        >;
    }
    impl GangFormulas_Trait for GangFormulas {
        fn set_money_gain(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    GangGenInfo,
                    GangMemberInfo,
                    GangTaskStats,
                ) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.money_gain = value;
            Ok(())
        }
        fn money_gain(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    GangGenInfo,
                    GangMemberInfo,
                    GangTaskStats,
                ) -> std::result::Result<f64, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.money_gain.clone())
        }
        fn set_ascension_multiplier(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.ascension_multiplier = value;
            Ok(())
        }
        fn ascension_multiplier(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.ascension_multiplier.clone())
        }
        fn set_wanted_level_gain(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    GangGenInfo,
                    GangMemberInfo,
                    GangTaskStats,
                ) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.wanted_level_gain = value;
            Ok(())
        }
        fn wanted_level_gain(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    GangGenInfo,
                    GangMemberInfo,
                    GangTaskStats,
                ) -> std::result::Result<f64, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.wanted_level_gain.clone())
        }
        fn set_ascension_points_gain(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.ascension_points_gain = value;
            Ok(())
        }
        fn ascension_points_gain(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.ascension_points_gain.clone())
        }
        fn set_wanted_penalty(
            &mut self,
            value: std::rc::Rc<dyn Fn(GangGenInfo) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.wanted_penalty = value;
            Ok(())
        }
        fn wanted_penalty(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(GangGenInfo) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.wanted_penalty.clone())
        }
        fn set_respect_gain(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    GangGenInfo,
                    GangMemberInfo,
                    GangTaskStats,
                ) -> std::result::Result<f64, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.respect_gain = value;
            Ok(())
        }
        fn respect_gain(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    GangGenInfo,
                    GangMemberInfo,
                    GangTaskStats,
                ) -> std::result::Result<f64, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.respect_gain.clone())
        }
    }
    impl GangFormulas {
        #[allow(non_snake_case)]
        fn __TSB__serialize_wanted_level_gain<S>(
            wanted_level_gain: &std::rc::Rc<
                dyn Fn(
                    GangGenInfo,
                    GangMemberInfo,
                    GangTaskStats,
                ) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let wanted_level_gain = wanted_level_gain.clone();
            let wanted_level_gain_closure = Closure::wrap(Box::new(
                move |arg0: JsValue,
                      arg1: JsValue,
                      arg2: JsValue|
                      -> std::result::Result<f64, JsValue> {
                    let result = wanted_level_gain(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg2).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue, JsValue, JsValue) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &wanted_level_gain_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_ascension_multiplier<S>(
            ascension_multiplier: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let ascension_multiplier = ascension_multiplier.clone();
            let ascension_multiplier_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<f64, JsValue> {
                    let result = ascension_multiplier(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &ascension_multiplier_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_respect_gain<S>(
            respect_gain: &std::rc::Rc<
                dyn Fn(
                    GangGenInfo,
                    GangMemberInfo,
                    GangTaskStats,
                ) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let respect_gain = respect_gain.clone();
            let respect_gain_closure = Closure::wrap(Box::new(
                move |arg0: JsValue,
                      arg1: JsValue,
                      arg2: JsValue|
                      -> std::result::Result<f64, JsValue> {
                    let result = respect_gain(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg2).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue, JsValue, JsValue) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &respect_gain_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_ascension_points_gain<S>(
            ascension_points_gain: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let ascension_points_gain = ascension_points_gain.clone();
            let ascension_points_gain_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<f64, JsValue> {
                    let result = ascension_points_gain(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &ascension_points_gain_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_wanted_penalty<S>(
            wanted_penalty: &std::rc::Rc<dyn Fn(GangGenInfo) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let wanted_penalty = wanted_penalty.clone();
            let wanted_penalty_closure = Closure::wrap(Box::new(
                move |arg0: JsValue| -> std::result::Result<f64, JsValue> {
                    let result = wanted_penalty(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &wanted_penalty_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_money_gain<S>(
            money_gain: &std::rc::Rc<
                dyn Fn(
                    GangGenInfo,
                    GangMemberInfo,
                    GangTaskStats,
                ) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let money_gain = money_gain.clone();
            let money_gain_closure = Closure::wrap(Box::new(
                move |arg0: JsValue,
                      arg1: JsValue,
                      arg2: JsValue|
                      -> std::result::Result<f64, JsValue> {
                    let result = money_gain(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                        ts_bindgen_rt::from_jsvalue(&arg2).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue, JsValue, JsValue) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &money_gain_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_wanted_level_gain<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    GangGenInfo,
                    GangMemberInfo,
                    GangTaskStats,
                ) -> std::result::Result<f64, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let wanted_level_gain: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            wanted_level_gain
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: GangGenInfo, arg1: GangMemberInfo, arg2: GangTaskStats| {
                            let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = ts_bindgen_rt::to_jsvalue(&arg2);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                GangGenInfo,
                                GangMemberInfo,
                                GangTaskStats,
                            )
                                -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_ascension_multiplier<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let ascension_multiplier: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            ascension_multiplier
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_respect_gain<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    GangGenInfo,
                    GangMemberInfo,
                    GangTaskStats,
                ) -> std::result::Result<f64, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let respect_gain: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            respect_gain
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: GangGenInfo, arg1: GangMemberInfo, arg2: GangTaskStats| {
                            let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = ts_bindgen_rt::to_jsvalue(&arg2);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                GangGenInfo,
                                GangMemberInfo,
                                GangTaskStats,
                            )
                                -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_ascension_points_gain<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let ascension_points_gain: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            ascension_points_gain
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_wanted_penalty<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(GangGenInfo) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let wanted_penalty: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            wanted_penalty
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: GangGenInfo| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(GangGenInfo) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_money_gain<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    GangGenInfo,
                    GangMemberInfo,
                    GangTaskStats,
                ) -> std::result::Result<f64, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let money_gain: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            money_gain
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(
                        move |arg0: GangGenInfo, arg1: GangMemberInfo, arg2: GangTaskStats| {
                            let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                            let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                            let arg2 = ts_bindgen_rt::to_jsvalue(&arg2);
                            let _Args = js_sys::Array::new();
                            _Args.push(&arg0);
                            _Args.push(&arg1);
                            _Args.push(&arg2);
                            let ret = f.apply(&JsValue::null(), &_Args)?;
                            Ok(ret.into_serde().unwrap())
                        },
                    )
                        as std::rc::Rc<
                            dyn Fn(
                                GangGenInfo,
                                GangMemberInfo,
                                GangTaskStats,
                            )
                                -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum GangAscendMemberReturn {
        GangMemberAscension(GangMemberAscension),
        #[serde(
            serialize_with = "ts_bindgen_rt::serialize_undefined",
            deserialize_with = "ts_bindgen_rt::deserialize_undefined"
        )]
        TsBindgenRtUndefined,
    }
    #[allow(dead_code, non_camel_case_types)]
    type CodingContractData = JsValue;
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct CrimeStats {
        #[serde(rename = "kills")]
        pub kills: f64,
        #[serde(rename = "time")]
        pub time: f64,
        #[serde(rename = "dexterity_exp")]
        pub dexterity_exp: f64,
        #[serde(rename = "charisma_exp")]
        pub charisma_exp: f64,
        #[serde(rename = "type")]
        pub type_: String,
        #[serde(rename = "charisma_success_weight")]
        pub charisma_success_weight: f64,
        #[serde(rename = "strength_success_weight")]
        pub strength_success_weight: f64,
        #[serde(rename = "defense_success_weight")]
        pub defense_success_weight: f64,
        #[serde(rename = "agility_exp")]
        pub agility_exp: f64,
        #[serde(rename = "difficulty")]
        pub difficulty: f64,
        #[serde(rename = "money")]
        pub money: f64,
        #[serde(rename = "intelligence_exp")]
        pub intelligence_exp: f64,
        #[serde(rename = "karma")]
        pub karma: f64,
        #[serde(rename = "defense_exp")]
        pub defense_exp: f64,
        #[serde(rename = "dexterity_success_weight")]
        pub dexterity_success_weight: f64,
        #[serde(rename = "hacking_success_weight")]
        pub hacking_success_weight: f64,
        #[serde(rename = "hacking_exp")]
        pub hacking_exp: f64,
        #[serde(rename = "agility_success_weight")]
        pub agility_success_weight: f64,
        #[serde(rename = "strength_exp")]
        pub strength_exp: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait CrimeStats_Trait {
        fn set_kills(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn kills(&self) -> std::result::Result<f64, JsValue>;
        fn set_hacking_success_weight(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hacking_success_weight(&self) -> std::result::Result<f64, JsValue>;
        fn set_strength_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn strength_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_time(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn time(&self) -> std::result::Result<f64, JsValue>;
        fn set_charisma_success_weight(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn charisma_success_weight(&self) -> std::result::Result<f64, JsValue>;
        fn set_defense_success_weight(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn defense_success_weight(&self) -> std::result::Result<f64, JsValue>;
        fn set_agility_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn agility_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_dexterity_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn dexterity_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_karma(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn karma(&self) -> std::result::Result<f64, JsValue>;
        fn set_charisma_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn charisma_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue>;
        fn type_(&self) -> std::result::Result<String, JsValue>;
        fn set_hacking_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn hacking_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_agility_success_weight(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn agility_success_weight(&self) -> std::result::Result<f64, JsValue>;
        fn set_money(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn money(&self) -> std::result::Result<f64, JsValue>;
        fn set_dexterity_success_weight(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn dexterity_success_weight(&self) -> std::result::Result<f64, JsValue>;
        fn set_strength_success_weight(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn strength_success_weight(&self) -> std::result::Result<f64, JsValue>;
        fn set_difficulty(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn difficulty(&self) -> std::result::Result<f64, JsValue>;
        fn set_intelligence_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn intelligence_exp(&self) -> std::result::Result<f64, JsValue>;
        fn set_defense_exp(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn defense_exp(&self) -> std::result::Result<f64, JsValue>;
    }
    impl CrimeStats_Trait for CrimeStats {
        fn set_kills(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.kills = value;
            Ok(())
        }
        fn kills(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.kills)
        }
        fn set_hacking_success_weight(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hacking_success_weight = value;
            Ok(())
        }
        fn hacking_success_weight(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacking_success_weight)
        }
        fn set_strength_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.strength_exp = value;
            Ok(())
        }
        fn strength_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.strength_exp)
        }
        fn set_time(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.time = value;
            Ok(())
        }
        fn time(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.time)
        }
        fn set_charisma_success_weight(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.charisma_success_weight = value;
            Ok(())
        }
        fn charisma_success_weight(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.charisma_success_weight)
        }
        fn set_defense_success_weight(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.defense_success_weight = value;
            Ok(())
        }
        fn defense_success_weight(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.defense_success_weight)
        }
        fn set_agility_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.agility_exp = value;
            Ok(())
        }
        fn agility_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.agility_exp)
        }
        fn set_dexterity_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.dexterity_exp = value;
            Ok(())
        }
        fn dexterity_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.dexterity_exp)
        }
        fn set_karma(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.karma = value;
            Ok(())
        }
        fn karma(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.karma)
        }
        fn set_charisma_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.charisma_exp = value;
            Ok(())
        }
        fn charisma_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.charisma_exp)
        }
        fn set_type_(&mut self, value: String) -> std::result::Result<(), JsValue> {
            self.type_ = value;
            Ok(())
        }
        fn type_(&self) -> std::result::Result<String, JsValue> {
            Ok(self.type_.clone())
        }
        fn set_hacking_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.hacking_exp = value;
            Ok(())
        }
        fn hacking_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.hacking_exp)
        }
        fn set_agility_success_weight(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.agility_success_weight = value;
            Ok(())
        }
        fn agility_success_weight(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.agility_success_weight)
        }
        fn set_money(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.money = value;
            Ok(())
        }
        fn money(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.money)
        }
        fn set_dexterity_success_weight(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.dexterity_success_weight = value;
            Ok(())
        }
        fn dexterity_success_weight(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.dexterity_success_weight)
        }
        fn set_strength_success_weight(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.strength_success_weight = value;
            Ok(())
        }
        fn strength_success_weight(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.strength_success_weight)
        }
        fn set_difficulty(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.difficulty = value;
            Ok(())
        }
        fn difficulty(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.difficulty)
        }
        fn set_intelligence_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.intelligence_exp = value;
            Ok(())
        }
        fn intelligence_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.intelligence_exp)
        }
        fn set_defense_exp(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.defense_exp = value;
            Ok(())
        }
        fn defense_exp(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.defense_exp)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum MaterialCompetition {
        F64(f64),
        #[serde(
            serialize_with = "ts_bindgen_rt::serialize_undefined",
            deserialize_with = "ts_bindgen_rt::deserialize_undefined"
        )]
        TsBindgenRtUndefined,
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Fragment {
        #[serde(rename = "id")]
        pub id: f64,
        #[serde(rename = "type")]
        pub type_: f64,
        #[serde(rename = "shape")]
        pub shape: Vec<Vec<bool>>,
        #[serde(rename = "limit")]
        pub limit: f64,
        #[serde(rename = "power")]
        pub power: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait Fragment_Trait {
        fn set_power(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn power(&self) -> std::result::Result<f64, JsValue>;
        fn set_limit(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn limit(&self) -> std::result::Result<f64, JsValue>;
        fn set_shape(&mut self, value: Vec<Vec<bool>>) -> std::result::Result<(), JsValue>;
        fn shape(&self) -> std::result::Result<Vec<Vec<bool>>, JsValue>;
        fn set_type_(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn type_(&self) -> std::result::Result<f64, JsValue>;
        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn id(&self) -> std::result::Result<f64, JsValue>;
    }
    impl Fragment_Trait for Fragment {
        fn set_power(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.power = value;
            Ok(())
        }
        fn power(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.power)
        }
        fn set_limit(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.limit = value;
            Ok(())
        }
        fn limit(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.limit)
        }
        fn set_shape(&mut self, value: Vec<Vec<bool>>) -> std::result::Result<(), JsValue> {
            self.shape = value;
            Ok(())
        }
        fn shape(&self) -> std::result::Result<Vec<Vec<bool>>, JsValue> {
            Ok(self.shape.clone())
        }
        fn set_type_(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.type_ = value;
            Ok(())
        }
        fn type_(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.type_)
        }
        fn set_id(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.id = value;
            Ok(())
        }
        fn id(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.id)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum GangGetAscensionResultReturn {
        GangMemberAscension(GangMemberAscension),
        #[serde(
            serialize_with = "ts_bindgen_rt::serialize_undefined",
            deserialize_with = "ts_bindgen_rt::deserialize_undefined"
        )]
        TsBindgenRtUndefined,
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct StockOrderObject {
        #[serde(rename = "shares")]
        pub shares: f64,
        #[serde(rename = "position")]
        pub position: PositionTypes,
        #[serde(rename = "type")]
        pub type_: OrderTypes,
        #[serde(rename = "price")]
        pub price: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait StockOrderObject_Trait {
        fn set_price(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn price(&self) -> std::result::Result<f64, JsValue>;
        fn set_position(&mut self, value: PositionTypes) -> std::result::Result<(), JsValue>;
        fn position(&self) -> std::result::Result<PositionTypes, JsValue>;
        fn set_shares(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn shares(&self) -> std::result::Result<f64, JsValue>;
        fn set_type_(&mut self, value: OrderTypes) -> std::result::Result<(), JsValue>;
        fn type_(&self) -> std::result::Result<OrderTypes, JsValue>;
    }
    impl StockOrderObject_Trait for StockOrderObject {
        fn set_price(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.price = value;
            Ok(())
        }
        fn price(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.price)
        }
        fn set_position(&mut self, value: PositionTypes) -> std::result::Result<(), JsValue> {
            self.position = value;
            Ok(())
        }
        fn position(&self) -> std::result::Result<PositionTypes, JsValue> {
            Ok(self.position.clone())
        }
        fn set_shares(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.shares = value;
            Ok(())
        }
        fn shares(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.shares)
        }
        fn set_type_(&mut self, value: OrderTypes) -> std::result::Result<(), JsValue> {
            self.type_ = value;
            Ok(())
        }
        fn type_(&self) -> std::result::Result<OrderTypes, JsValue> {
            Ok(self.type_.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum NsExecParamsThreadOrOptions {
        RunOptions(RunOptions),
        F64(f64),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct NsPromptParamsOptions {
        #[serde(rename = "type")]
        pub type_: Option<NsPromptParamsOptionsType>,
        #[serde(rename = "choices")]
        pub choices: Option<Vec<String>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait NsPromptParamsOptions_Trait {
        fn set_type_(
            &mut self,
            value: Option<NsPromptParamsOptionsType>,
        ) -> std::result::Result<(), JsValue>;
        fn type_(&self) -> std::result::Result<Option<NsPromptParamsOptionsType>, JsValue>;
        fn set_choices(&mut self, value: Option<Vec<String>>) -> std::result::Result<(), JsValue>;
        fn choices(&self) -> std::result::Result<Option<Vec<String>>, JsValue>;
    }
    impl NsPromptParamsOptions_Trait for NsPromptParamsOptions {
        fn set_type_(
            &mut self,
            value: Option<NsPromptParamsOptionsType>,
        ) -> std::result::Result<(), JsValue> {
            self.type_ = value;
            Ok(())
        }
        fn type_(&self) -> std::result::Result<Option<NsPromptParamsOptionsType>, JsValue> {
            Ok(self.type_.clone())
        }
        fn set_choices(&mut self, value: Option<Vec<String>>) -> std::result::Result<(), JsValue> {
            self.choices = value;
            Ok(())
        }
        fn choices(&self) -> std::result::Result<Option<Vec<String>>, JsValue> {
            Ok(self.choices.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct HacknetNodesFormulas {
        #[serde(
            rename = "coreUpgradeCost",
            serialize_with = "HacknetNodesFormulas::__TSB__serialize_core_upgrade_cost",
            deserialize_with = "HacknetNodesFormulas::__TSB__deserialize_core_upgrade_cost"
        )]
        pub core_upgrade_cost:
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "constants",
            serialize_with = "HacknetNodesFormulas::__TSB__serialize_constants",
            deserialize_with = "HacknetNodesFormulas::__TSB__deserialize_constants"
        )]
        pub constants: std::rc::Rc<dyn Fn() -> std::result::Result<HacknetNodeConstants, JsValue>>,
        #[serde(
            rename = "moneyGainRate",
            serialize_with = "HacknetNodesFormulas::__TSB__serialize_money_gain_rate",
            deserialize_with = "HacknetNodesFormulas::__TSB__deserialize_money_gain_rate"
        )]
        pub money_gain_rate:
            std::rc::Rc<dyn Fn(f64, f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "levelUpgradeCost",
            serialize_with = "HacknetNodesFormulas::__TSB__serialize_level_upgrade_cost",
            deserialize_with = "HacknetNodesFormulas::__TSB__deserialize_level_upgrade_cost"
        )]
        pub level_upgrade_cost:
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "ramUpgradeCost",
            serialize_with = "HacknetNodesFormulas::__TSB__serialize_ram_upgrade_cost",
            deserialize_with = "HacknetNodesFormulas::__TSB__deserialize_ram_upgrade_cost"
        )]
        pub ram_upgrade_cost:
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "hacknetNodeCost",
            serialize_with = "HacknetNodesFormulas::__TSB__serialize_hacknet_node_cost",
            deserialize_with = "HacknetNodesFormulas::__TSB__deserialize_hacknet_node_cost"
        )]
        pub hacknet_node_cost: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait HacknetNodesFormulas_Trait {
        fn set_level_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn level_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_core_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn core_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_ram_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn ram_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_constants(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<HacknetNodeConstants, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn constants(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<HacknetNodeConstants, JsValue>>,
            JsValue,
        >;
        fn set_hacknet_node_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn hacknet_node_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_money_gain_rate(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn money_gain_rate(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
    }
    impl HacknetNodesFormulas_Trait for HacknetNodesFormulas {
        fn set_level_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.level_upgrade_cost = value;
            Ok(())
        }
        fn level_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.level_upgrade_cost.clone())
        }
        fn set_core_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.core_upgrade_cost = value;
            Ok(())
        }
        fn core_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.core_upgrade_cost.clone())
        }
        fn set_ram_upgrade_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.ram_upgrade_cost = value;
            Ok(())
        }
        fn ram_upgrade_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.ram_upgrade_cost.clone())
        }
        fn set_constants(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<HacknetNodeConstants, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.constants = value;
            Ok(())
        }
        fn constants(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<HacknetNodeConstants, JsValue>>,
            JsValue,
        > {
            Ok(self.constants.clone())
        }
        fn set_hacknet_node_cost(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.hacknet_node_cost = value;
            Ok(())
        }
        fn hacknet_node_cost(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.hacknet_node_cost.clone())
        }
        fn set_money_gain_rate(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, f64, f64, f64) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.money_gain_rate = value;
            Ok(())
        }
        fn money_gain_rate(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.money_gain_rate.clone())
        }
    }
    impl HacknetNodesFormulas {
        #[allow(non_snake_case)]
        fn __TSB__serialize_core_upgrade_cost<S>(
            core_upgrade_cost: &std::rc::Rc<
                dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let core_upgrade_cost = core_upgrade_cost.clone();
            let core_upgrade_cost_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64, arg2: f64| -> std::result::Result<f64, JsValue> {
                    let result = core_upgrade_cost(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &core_upgrade_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_constants<S>(
            constants: &std::rc::Rc<dyn Fn() -> std::result::Result<HacknetNodeConstants, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let constants = constants.clone();
            let constants_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = constants()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &constants_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_money_gain_rate<S>(
            money_gain_rate: &std::rc::Rc<
                dyn Fn(f64, f64, f64, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let money_gain_rate = money_gain_rate.clone();
            let money_gain_rate_closure = Closure::wrap(Box::new(
                move |arg0: f64,
                      arg1: f64,
                      arg2: f64,
                      arg3: f64|
                      -> std::result::Result<f64, JsValue> {
                    let result = money_gain_rate(arg0, arg1, arg2, arg3)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64, f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &money_gain_rate_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_level_upgrade_cost<S>(
            level_upgrade_cost: &std::rc::Rc<
                dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let level_upgrade_cost = level_upgrade_cost.clone();
            let level_upgrade_cost_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64, arg2: f64| -> std::result::Result<f64, JsValue> {
                    let result = level_upgrade_cost(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &level_upgrade_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_ram_upgrade_cost<S>(
            ram_upgrade_cost: &std::rc::Rc<
                dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let ram_upgrade_cost = ram_upgrade_cost.clone();
            let ram_upgrade_cost_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64, arg2: f64| -> std::result::Result<f64, JsValue> {
                    let result = ram_upgrade_cost(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &ram_upgrade_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_hacknet_node_cost<S>(
            hacknet_node_cost: &std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let hacknet_node_cost = hacknet_node_cost.clone();
            let hacknet_node_cost_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: f64| -> std::result::Result<f64, JsValue> {
                    let result = hacknet_node_cost(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &hacknet_node_cost_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_core_upgrade_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let core_upgrade_cost: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            core_upgrade_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_constants<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<HacknetNodeConstants, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let constants: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            constants
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn() -> std::result::Result<HacknetNodeConstants, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_money_gain_rate<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let money_gain_rate: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            money_gain_rate
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64, arg2: f64, arg3: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let arg3 = JsValue::from(arg3);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        _Args.push(&arg3);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(f64, f64, f64, f64) -> std::result::Result<f64, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_level_upgrade_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let level_upgrade_cost: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            level_upgrade_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_ram_upgrade_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let ram_upgrade_cost: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            ram_upgrade_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64, arg2: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_hacknet_node_cost<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let hacknet_node_cost: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            hacknet_node_cost
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: f64| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, f64) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct ILocation {
        #[serde(rename = "name")]
        pub name: LocationName,
        #[serde(rename = "city")]
        pub city: CityName,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait ILocation_Trait {
        fn set_city(&mut self, value: CityName) -> std::result::Result<(), JsValue>;
        fn city(&self) -> std::result::Result<CityName, JsValue>;
        fn set_name(&mut self, value: LocationName) -> std::result::Result<(), JsValue>;
        fn name(&self) -> std::result::Result<LocationName, JsValue>;
    }
    impl ILocation_Trait for ILocation {
        fn set_city(&mut self, value: CityName) -> std::result::Result<(), JsValue> {
            self.city = value;
            Ok(())
        }
        fn city(&self) -> std::result::Result<CityName, JsValue> {
            Ok(self.city.clone())
        }
        fn set_name(&mut self, value: LocationName) -> std::result::Result<(), JsValue> {
            self.name = value;
            Ok(())
        }
        fn name(&self) -> std::result::Result<LocationName, JsValue> {
            Ok(self.name.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct ResetInfo {
        #[serde(rename = "currentNode")]
        pub current_node: f64,
        #[serde(rename = "lastAugReset")]
        pub last_aug_reset: f64,
        #[serde(rename = "lastNodeReset")]
        pub last_node_reset: f64,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait ResetInfo_Trait {
        fn set_last_node_reset(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn last_node_reset(&self) -> std::result::Result<f64, JsValue>;
        fn set_last_aug_reset(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn last_aug_reset(&self) -> std::result::Result<f64, JsValue>;
        fn set_current_node(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn current_node(&self) -> std::result::Result<f64, JsValue>;
    }
    impl ResetInfo_Trait for ResetInfo {
        fn set_last_node_reset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.last_node_reset = value;
            Ok(())
        }
        fn last_node_reset(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.last_node_reset)
        }
        fn set_last_aug_reset(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.last_aug_reset = value;
            Ok(())
        }
        fn last_aug_reset(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.last_aug_reset)
        }
        fn set_current_node(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.current_node = value;
            Ok(())
        }
        fn current_node(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.current_node)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    #[serde(untagged)]
    pub enum SingularityGetCurrentWorkReturn {
        TsBindgenRtNull,
        #[serde(
            serialize_with = "ts_bindgen_rt::serialize_jsvalue",
            deserialize_with = "ts_bindgen_rt::deserialize_as_jsvalue"
        )]
        JsValue(JsValue),
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct InfiltrationLocation {
        #[serde(rename = "difficulty")]
        pub difficulty: f64,
        #[serde(rename = "location")]
        pub location: ILocation,
        #[serde(rename = "reward")]
        pub reward: InfiltrationReward,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait InfiltrationLocation_Trait {
        fn set_reward(&mut self, value: InfiltrationReward) -> std::result::Result<(), JsValue>;
        fn reward(&self) -> std::result::Result<InfiltrationReward, JsValue>;
        fn set_difficulty(&mut self, value: f64) -> std::result::Result<(), JsValue>;
        fn difficulty(&self) -> std::result::Result<f64, JsValue>;
        fn set_location(&mut self, value: ILocation) -> std::result::Result<(), JsValue>;
        fn location(&self) -> std::result::Result<ILocation, JsValue>;
    }
    impl InfiltrationLocation_Trait for InfiltrationLocation {
        fn set_reward(&mut self, value: InfiltrationReward) -> std::result::Result<(), JsValue> {
            self.reward = value;
            Ok(())
        }
        fn reward(&self) -> std::result::Result<InfiltrationReward, JsValue> {
            Ok(self.reward.clone())
        }
        fn set_difficulty(&mut self, value: f64) -> std::result::Result<(), JsValue> {
            self.difficulty = value;
            Ok(())
        }
        fn difficulty(&self) -> std::result::Result<f64, JsValue> {
            Ok(self.difficulty)
        }
        fn set_location(&mut self, value: ILocation) -> std::result::Result<(), JsValue> {
            self.location = value;
            Ok(())
        }
        fn location(&self) -> std::result::Result<ILocation, JsValue> {
            Ok(self.location.clone())
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct Sleeve {
        #[serde(
            rename = "setToUniversityCourse",
            serialize_with = "Sleeve::__TSB__serialize_set_to_university_course",
            deserialize_with = "Sleeve::__TSB__deserialize_set_to_university_course"
        )]
        pub set_to_university_course:
            std::rc::Rc<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "setToCommitCrime",
            serialize_with = "Sleeve::__TSB__serialize_set_to_commit_crime",
            deserialize_with = "Sleeve::__TSB__deserialize_set_to_commit_crime"
        )]
        pub set_to_commit_crime:
            std::rc::Rc<dyn Fn(f64, CrimeType) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getSleeveAugmentations",
            serialize_with = "Sleeve::__TSB__serialize_get_sleeve_augmentations",
            deserialize_with = "Sleeve::__TSB__deserialize_get_sleeve_augmentations"
        )]
        pub get_sleeve_augmentations:
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<Vec<String>, JsValue>>,
        #[serde(
            rename = "purchaseSleeveAug",
            serialize_with = "Sleeve::__TSB__serialize_purchase_sleeve_aug",
            deserialize_with = "Sleeve::__TSB__deserialize_purchase_sleeve_aug"
        )]
        pub purchase_sleeve_aug:
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getSleeveAugmentationRepReq",
            serialize_with = "Sleeve::__TSB__serialize_get_sleeve_augmentation_rep_req",
            deserialize_with = "Sleeve::__TSB__deserialize_get_sleeve_augmentation_rep_req"
        )]
        pub get_sleeve_augmentation_rep_req:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getSleeve",
            serialize_with = "Sleeve::__TSB__serialize_get_sleeve",
            deserialize_with = "Sleeve::__TSB__deserialize_get_sleeve"
        )]
        pub get_sleeve: std::rc::Rc<dyn Fn(f64) -> std::result::Result<SleevePerson, JsValue>>,
        #[serde(
            rename = "getSleeveAugmentationPrice",
            serialize_with = "Sleeve::__TSB__serialize_get_sleeve_augmentation_price",
            deserialize_with = "Sleeve::__TSB__deserialize_get_sleeve_augmentation_price"
        )]
        pub get_sleeve_augmentation_price:
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "getTask",
            serialize_with = "Sleeve::__TSB__serialize_get_task",
            deserialize_with = "Sleeve::__TSB__deserialize_get_task"
        )]
        pub get_task: std::rc::Rc<dyn Fn(f64) -> std::result::Result<SleeveGetTaskReturn, JsValue>>,
        #[serde(
            rename = "getNumSleeves",
            serialize_with = "Sleeve::__TSB__serialize_get_num_sleeves",
            deserialize_with = "Sleeve::__TSB__deserialize_get_num_sleeves"
        )]
        pub get_num_sleeves: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        #[serde(
            rename = "setToGymWorkout",
            serialize_with = "Sleeve::__TSB__serialize_set_to_gym_workout",
            deserialize_with = "Sleeve::__TSB__deserialize_set_to_gym_workout"
        )]
        pub set_to_gym_workout:
            std::rc::Rc<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "setToFactionWork",
            serialize_with = "Sleeve::__TSB__serialize_set_to_faction_work",
            deserialize_with = "Sleeve::__TSB__deserialize_set_to_faction_work"
        )]
        pub set_to_faction_work: std::rc::Rc<
            dyn Fn(
                f64,
                String,
                FactionWorkType,
            ) -> std::result::Result<SleeveSetToFactionWorkReturn, JsValue>,
        >,
        #[serde(
            rename = "setToBladeburnerAction",
            serialize_with = "Sleeve::__TSB__serialize_set_to_bladeburner_action",
            deserialize_with = "Sleeve::__TSB__deserialize_set_to_bladeburner_action"
        )]
        pub set_to_bladeburner_action:
            std::rc::Rc<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "setToShockRecovery",
            serialize_with = "Sleeve::__TSB__serialize_set_to_shock_recovery",
            deserialize_with = "Sleeve::__TSB__deserialize_set_to_shock_recovery"
        )]
        pub set_to_shock_recovery: std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "travel",
            serialize_with = "Sleeve::__TSB__serialize_travel",
            deserialize_with = "Sleeve::__TSB__deserialize_travel"
        )]
        pub travel: std::rc::Rc<dyn Fn(f64, CityName) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "getSleevePurchasableAugs",
            serialize_with = "Sleeve::__TSB__serialize_get_sleeve_purchasable_augs",
            deserialize_with = "Sleeve::__TSB__deserialize_get_sleeve_purchasable_augs"
        )]
        pub get_sleeve_purchasable_augs:
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<Vec<AugmentPair>, JsValue>>,
        #[serde(
            rename = "setToCompanyWork",
            serialize_with = "Sleeve::__TSB__serialize_set_to_company_work",
            deserialize_with = "Sleeve::__TSB__deserialize_set_to_company_work"
        )]
        pub set_to_company_work:
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "setToSynchronize",
            serialize_with = "Sleeve::__TSB__serialize_set_to_synchronize",
            deserialize_with = "Sleeve::__TSB__deserialize_set_to_synchronize"
        )]
        pub set_to_synchronize: std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
        #[serde(
            rename = "setToIdle",
            serialize_with = "Sleeve::__TSB__serialize_set_to_idle",
            deserialize_with = "Sleeve::__TSB__deserialize_set_to_idle"
        )]
        pub set_to_idle: std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    pub trait Sleeve_Trait {
        fn set_set_to_synchronize(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_to_synchronize(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_num_sleeves(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_num_sleeves(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>;
        fn set_get_sleeve_augmentation_rep_req(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_sleeve_augmentation_rep_req(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_purchase_sleeve_aug(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn purchase_sleeve_aug(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_set_to_gym_workout(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_to_gym_workout(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_sleeve(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<SleevePerson, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_sleeve(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<SleevePerson, JsValue>>,
            JsValue,
        >;
        fn set_get_sleeve_augmentation_price(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_sleeve_augmentation_price(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        >;
        fn set_set_to_shock_recovery(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_to_shock_recovery(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_task(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<SleeveGetTaskReturn, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_task(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<SleeveGetTaskReturn, JsValue>>,
            JsValue,
        >;
        fn set_set_to_faction_work(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    f64,
                    String,
                    FactionWorkType,
                )
                    -> std::result::Result<SleeveSetToFactionWorkReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn set_to_faction_work(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    f64,
                    String,
                    FactionWorkType,
                )
                    -> std::result::Result<SleeveSetToFactionWorkReturn, JsValue>,
            >,
            JsValue,
        >;
        fn set_set_to_company_work(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_to_company_work(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_set_to_commit_crime(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, CrimeType) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_to_commit_crime(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, CrimeType) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_travel(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, CityName) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn travel(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, CityName) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_get_sleeve_purchasable_augs(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<Vec<AugmentPair>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_sleeve_purchasable_augs(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<Vec<AugmentPair>, JsValue>>,
            JsValue,
        >;
        fn set_set_to_bladeburner_action(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_to_bladeburner_action(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_set_to_university_course(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_to_university_course(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        >;
        fn set_set_to_idle(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_to_idle(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_get_sleeve_augmentations(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_sleeve_augmentations(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        >;
    }
    impl Sleeve_Trait for Sleeve {
        fn set_set_to_synchronize(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_to_synchronize = value;
            Ok(())
        }
        fn set_to_synchronize(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.set_to_synchronize.clone())
        }
        fn set_get_num_sleeves(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_num_sleeves = value;
            Ok(())
        }
        fn get_num_sleeves(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, JsValue>
        {
            Ok(self.get_num_sleeves.clone())
        }
        fn set_get_sleeve_augmentation_rep_req(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_sleeve_augmentation_rep_req = value;
            Ok(())
        }
        fn get_sleeve_augmentation_rep_req(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_sleeve_augmentation_rep_req.clone())
        }
        fn set_purchase_sleeve_aug(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.purchase_sleeve_aug = value;
            Ok(())
        }
        fn purchase_sleeve_aug(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.purchase_sleeve_aug.clone())
        }
        fn set_set_to_gym_workout(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_to_gym_workout = value;
            Ok(())
        }
        fn set_to_gym_workout(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.set_to_gym_workout.clone())
        }
        fn set_get_sleeve(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<SleevePerson, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_sleeve = value;
            Ok(())
        }
        fn get_sleeve(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<SleevePerson, JsValue>>,
            JsValue,
        > {
            Ok(self.get_sleeve.clone())
        }
        fn set_get_sleeve_augmentation_price(
            &mut self,
            value: std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_sleeve_augmentation_price = value;
            Ok(())
        }
        fn get_sleeve_augmentation_price(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            JsValue,
        > {
            Ok(self.get_sleeve_augmentation_price.clone())
        }
        fn set_set_to_shock_recovery(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_to_shock_recovery = value;
            Ok(())
        }
        fn set_to_shock_recovery(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.set_to_shock_recovery.clone())
        }
        fn set_get_task(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<SleeveGetTaskReturn, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_task = value;
            Ok(())
        }
        fn get_task(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<SleeveGetTaskReturn, JsValue>>,
            JsValue,
        > {
            Ok(self.get_task.clone())
        }
        fn set_set_to_faction_work(
            &mut self,
            value: std::rc::Rc<
                dyn Fn(
                    f64,
                    String,
                    FactionWorkType,
                )
                    -> std::result::Result<SleeveSetToFactionWorkReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.set_to_faction_work = value;
            Ok(())
        }
        fn set_to_faction_work(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    f64,
                    String,
                    FactionWorkType,
                )
                    -> std::result::Result<SleeveSetToFactionWorkReturn, JsValue>,
            >,
            JsValue,
        > {
            Ok(self.set_to_faction_work.clone())
        }
        fn set_set_to_company_work(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_to_company_work = value;
            Ok(())
        }
        fn set_to_company_work(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.set_to_company_work.clone())
        }
        fn set_set_to_commit_crime(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, CrimeType) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_to_commit_crime = value;
            Ok(())
        }
        fn set_to_commit_crime(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, CrimeType) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.set_to_commit_crime.clone())
        }
        fn set_travel(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, CityName) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.travel = value;
            Ok(())
        }
        fn travel(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, CityName) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.travel.clone())
        }
        fn set_get_sleeve_purchasable_augs(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<Vec<AugmentPair>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_sleeve_purchasable_augs = value;
            Ok(())
        }
        fn get_sleeve_purchasable_augs(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<Vec<AugmentPair>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_sleeve_purchasable_augs.clone())
        }
        fn set_set_to_bladeburner_action(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_to_bladeburner_action = value;
            Ok(())
        }
        fn set_to_bladeburner_action(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.set_to_bladeburner_action.clone())
        }
        fn set_set_to_university_course(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_to_university_course = value;
            Ok(())
        }
        fn set_to_university_course(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>,
            JsValue,
        > {
            Ok(self.set_to_university_course.clone())
        }
        fn set_set_to_idle(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_to_idle = value;
            Ok(())
        }
        fn set_to_idle(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.set_to_idle.clone())
        }
        fn set_get_sleeve_augmentations(
            &mut self,
            value: std::rc::Rc<dyn Fn(f64) -> std::result::Result<Vec<String>, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_sleeve_augmentations = value;
            Ok(())
        }
        fn get_sleeve_augmentations(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<Vec<String>, JsValue>>,
            JsValue,
        > {
            Ok(self.get_sleeve_augmentations.clone())
        }
    }
    impl Sleeve {
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_to_university_course<S>(
            set_to_university_course: &std::rc::Rc<
                dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_to_university_course = set_to_university_course.clone();
            let set_to_university_course_closure = Closure::wrap(Box::new(
                move |arg0: f64,
                      arg1: String,
                      arg2: String|
                      -> std::result::Result<bool, JsValue> {
                    let result = set_to_university_course(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_to_university_course_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_to_commit_crime<S>(
            set_to_commit_crime: &std::rc::Rc<
                dyn Fn(f64, CrimeType) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_to_commit_crime = set_to_commit_crime.clone();
            let set_to_commit_crime_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: JsValue| -> std::result::Result<bool, JsValue> {
                    let result = set_to_commit_crime(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, JsValue) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_to_commit_crime_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_sleeve_augmentations<S>(
            get_sleeve_augmentations: &std::rc::Rc<
                dyn Fn(f64) -> std::result::Result<Vec<String>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_sleeve_augmentations = get_sleeve_augmentations.clone();
            let get_sleeve_augmentations_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<JsValue, JsValue> {
                    let result = get_sleeve_augmentations(arg0)?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(&JsValue::from(result_item));
                        }
                        result_array.into()
                    })
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_sleeve_augmentations_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_purchase_sleeve_aug<S>(
            purchase_sleeve_aug: &std::rc::Rc<
                dyn Fn(f64, String) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let purchase_sleeve_aug = purchase_sleeve_aug.clone();
            let purchase_sleeve_aug_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: String| -> std::result::Result<bool, JsValue> {
                    let result = purchase_sleeve_aug(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &purchase_sleeve_aug_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_sleeve_augmentation_rep_req<S>(
            get_sleeve_augmentation_rep_req: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_sleeve_augmentation_rep_req = get_sleeve_augmentation_rep_req.clone();
            let get_sleeve_augmentation_rep_req_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_sleeve_augmentation_rep_req(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_sleeve_augmentation_rep_req_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_sleeve<S>(
            get_sleeve: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<SleevePerson, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_sleeve = get_sleeve.clone();
            let get_sleeve_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<JsValue, JsValue> {
                    let result = get_sleeve(arg0)?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_sleeve_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_sleeve_augmentation_price<S>(
            get_sleeve_augmentation_price: &std::rc::Rc<
                dyn Fn(String) -> std::result::Result<f64, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_sleeve_augmentation_price = get_sleeve_augmentation_price.clone();
            let get_sleeve_augmentation_price_closure = Closure::wrap(Box::new(
                move |arg0: String| -> std::result::Result<f64, JsValue> {
                    let result = get_sleeve_augmentation_price(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(String) -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_sleeve_augmentation_price_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_task<S>(
            get_task: &std::rc::Rc<
                dyn Fn(f64) -> std::result::Result<SleeveGetTaskReturn, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_task = get_task.clone();
            let get_task_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<JsValue, JsValue> {
                    let result = get_task(arg0)?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<JsValue, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &get_task_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_num_sleeves<S>(
            get_num_sleeves: &std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_num_sleeves = get_num_sleeves.clone();
            let get_num_sleeves_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<f64, JsValue> {
                    let result = get_num_sleeves()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<f64, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_num_sleeves_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_to_gym_workout<S>(
            set_to_gym_workout: &std::rc::Rc<
                dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_to_gym_workout = set_to_gym_workout.clone();
            let set_to_gym_workout_closure = Closure::wrap(Box::new(
                move |arg0: f64,
                      arg1: String,
                      arg2: String|
                      -> std::result::Result<bool, JsValue> {
                    let result = set_to_gym_workout(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_to_gym_workout_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_to_faction_work<S>(
            set_to_faction_work: &std::rc::Rc<
                dyn Fn(
                    f64,
                    String,
                    FactionWorkType,
                )
                    -> std::result::Result<SleeveSetToFactionWorkReturn, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_to_faction_work = set_to_faction_work.clone();
            let set_to_faction_work_closure = Closure::wrap(Box::new(
                move |arg0: f64,
                      arg1: String,
                      arg2: JsValue|
                      -> std::result::Result<JsValue, JsValue> {
                    let result = set_to_faction_work(
                        arg0,
                        arg1,
                        ts_bindgen_rt::from_jsvalue(&arg2).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                },
            )
                as Box<dyn Fn(f64, String, JsValue) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_to_faction_work_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_to_bladeburner_action<S>(
            set_to_bladeburner_action: &std::rc::Rc<
                dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_to_bladeburner_action = set_to_bladeburner_action.clone();
            let set_to_bladeburner_action_closure = Closure::wrap(Box::new(
                move |arg0: f64,
                      arg1: String,
                      arg2: String|
                      -> std::result::Result<bool, JsValue> {
                    let result = set_to_bladeburner_action(arg0, arg1, arg2)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_to_bladeburner_action_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_to_shock_recovery<S>(
            set_to_shock_recovery: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_to_shock_recovery = set_to_shock_recovery.clone();
            let set_to_shock_recovery_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<bool, JsValue> {
                    let result = set_to_shock_recovery(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_to_shock_recovery_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_travel<S>(
            travel: &std::rc::Rc<dyn Fn(f64, CityName) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let travel = travel.clone();
            let travel_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: JsValue| -> std::result::Result<bool, JsValue> {
                    let result = travel(
                        arg0,
                        ts_bindgen_rt::from_jsvalue(&arg1).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, JsValue) -> std::result::Result<bool, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &travel_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_sleeve_purchasable_augs<S>(
            get_sleeve_purchasable_augs: &std::rc::Rc<
                dyn Fn(f64) -> std::result::Result<Vec<AugmentPair>, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_sleeve_purchasable_augs = get_sleeve_purchasable_augs.clone();
            let get_sleeve_purchasable_augs_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<JsValue, JsValue> {
                    let result = get_sleeve_purchasable_augs(arg0)?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        for result_item in result {
                            result_array.push(
                                &ts_bindgen_rt::to_jsvalue(&result_item)
                                    .map_err(ts_bindgen_rt::Error::from)?,
                            );
                        }
                        result_array.into()
                    })
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_sleeve_purchasable_augs_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_to_company_work<S>(
            set_to_company_work: &std::rc::Rc<
                dyn Fn(f64, String) -> std::result::Result<bool, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_to_company_work = set_to_company_work.clone();
            let set_to_company_work_closure = Closure::wrap(Box::new(
                move |arg0: f64, arg1: String| -> std::result::Result<bool, JsValue> {
                    let result = set_to_company_work(arg0, arg1)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64, String) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_to_company_work_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_to_synchronize<S>(
            set_to_synchronize: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_to_synchronize = set_to_synchronize.clone();
            let set_to_synchronize_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<bool, JsValue> {
                    let result = set_to_synchronize(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<bool, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_to_synchronize_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_to_idle<S>(
            set_to_idle: &std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_to_idle = set_to_idle.clone();
            let set_to_idle_closure = Closure::wrap(Box::new(
                move |arg0: f64| -> std::result::Result<(), JsValue> {
                    let result = set_to_idle(arg0)?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(f64) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_to_idle_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_to_university_course<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_to_university_course: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_to_university_course
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: String, arg2: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_to_commit_crime<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, CrimeType) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_to_commit_crime: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_to_commit_crime
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: CrimeType| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, CrimeType) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_sleeve_augmentations<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<Vec<String>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_sleeve_augmentations: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_sleeve_augmentations
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<Vec<String>, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_purchase_sleeve_aug<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let purchase_sleeve_aug: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            purchase_sleeve_aug
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_sleeve_augmentation_rep_req<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_sleeve_augmentation_rep_req: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_sleeve_augmentation_rep_req
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_sleeve<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<SleevePerson, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_sleeve: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_sleeve
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<SleevePerson, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_sleeve_augmentation_price<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_sleeve_augmentation_price: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_sleeve_augmentation_price
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: String| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(String) -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_task<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<SleeveGetTaskReturn, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_task: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_task
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(f64) -> std::result::Result<SleeveGetTaskReturn, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_num_sleeves<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_num_sleeves: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_num_sleeves
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<f64, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_to_gym_workout<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_to_gym_workout: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_to_gym_workout
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: String, arg2: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_to_faction_work<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<
                dyn Fn(
                    f64,
                    String,
                    FactionWorkType,
                )
                    -> std::result::Result<SleeveSetToFactionWorkReturn, JsValue>,
            >,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_to_faction_work: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_to_faction_work
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: String, arg2: FactionWorkType| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = ts_bindgen_rt::to_jsvalue(&arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(
                                f64,
                                String,
                                FactionWorkType,
                            )
                                -> std::result::Result<SleeveSetToFactionWorkReturn, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_to_bladeburner_action<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_to_bladeburner_action: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_to_bladeburner_action
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: String, arg2: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let arg2 = JsValue::from(arg2);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        _Args.push(&arg2);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(f64, String, String) -> std::result::Result<bool, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_to_shock_recovery<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_to_shock_recovery: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_to_shock_recovery
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_travel<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, CityName) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let travel: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            travel
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: CityName| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = ts_bindgen_rt::to_jsvalue(&arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, CityName) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_sleeve_purchasable_augs<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<Vec<AugmentPair>, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_sleeve_purchasable_augs: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_sleeve_purchasable_augs
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(f64) -> std::result::Result<Vec<AugmentPair>, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_to_company_work<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_to_company_work: Option<&js_sys::Function> =
                wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_to_company_work
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64, arg1: String| {
                        let arg0 = JsValue::from(arg0);
                        let arg1 = JsValue::from(arg1);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        _Args.push(&arg1);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64, String) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_to_synchronize<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_to_synchronize: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_to_synchronize
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<bool, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_to_idle<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_to_idle: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_to_idle
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: f64| {
                        let arg0 = JsValue::from(arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(f64) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
    #[derive(Clone, serde :: Serialize, serde :: Deserialize)]
    pub struct UserInterface {
        #[serde(
            rename = "clearTerminal",
            serialize_with = "UserInterface::__TSB__serialize_clear_terminal",
            deserialize_with = "UserInterface::__TSB__deserialize_clear_terminal"
        )]
        pub clear_terminal: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "windowSize",
            serialize_with = "UserInterface::__TSB__serialize_window_size",
            deserialize_with = "UserInterface::__TSB__deserialize_window_size"
        )]
        pub window_size:
            std::rc::Rc<dyn Fn() -> std::result::Result<UserInterfaceWindowSizeReturn, JsValue>>,
        #[serde(
            rename = "getTheme",
            serialize_with = "UserInterface::__TSB__serialize_get_theme",
            deserialize_with = "UserInterface::__TSB__deserialize_get_theme"
        )]
        pub get_theme: std::rc::Rc<dyn Fn() -> std::result::Result<UserInterfaceTheme, JsValue>>,
        #[serde(
            rename = "setStyles",
            serialize_with = "UserInterface::__TSB__serialize_set_styles",
            deserialize_with = "UserInterface::__TSB__deserialize_set_styles"
        )]
        pub set_styles: std::rc::Rc<dyn Fn(IStyleSettings) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "getGameInfo",
            serialize_with = "UserInterface::__TSB__serialize_get_game_info",
            deserialize_with = "UserInterface::__TSB__deserialize_get_game_info"
        )]
        pub get_game_info: std::rc::Rc<dyn Fn() -> std::result::Result<GameInfo, JsValue>>,
        #[serde(
            rename = "getStyles",
            serialize_with = "UserInterface::__TSB__serialize_get_styles",
            deserialize_with = "UserInterface::__TSB__deserialize_get_styles"
        )]
        pub get_styles: std::rc::Rc<dyn Fn() -> std::result::Result<IStyleSettings, JsValue>>,
        #[serde(
            rename = "setTheme",
            serialize_with = "UserInterface::__TSB__serialize_set_theme",
            deserialize_with = "UserInterface::__TSB__deserialize_set_theme"
        )]
        pub set_theme: std::rc::Rc<dyn Fn(UserInterfaceTheme) -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "resetStyles",
            serialize_with = "UserInterface::__TSB__serialize_reset_styles",
            deserialize_with = "UserInterface::__TSB__deserialize_reset_styles"
        )]
        pub reset_styles: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        #[serde(
            rename = "resetTheme",
            serialize_with = "UserInterface::__TSB__serialize_reset_theme",
            deserialize_with = "UserInterface::__TSB__deserialize_reset_theme"
        )]
        pub reset_theme: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
    }
    #[allow(non_camel_case_types, non_snake_case)]
    trait UserInterface_Trait {
        fn set_get_styles(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<IStyleSettings, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_styles(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<IStyleSettings, JsValue>>,
            JsValue,
        >;
        fn set_get_theme(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<UserInterfaceTheme, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_theme(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<UserInterfaceTheme, JsValue>>,
            JsValue,
        >;
        fn set_set_theme(
            &mut self,
            value: std::rc::Rc<dyn Fn(UserInterfaceTheme) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_theme(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(UserInterfaceTheme) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_clear_terminal(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn clear_terminal(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, JsValue>;
        fn set_reset_theme(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn reset_theme(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, JsValue>;
        fn set_set_styles(
            &mut self,
            value: std::rc::Rc<dyn Fn(IStyleSettings) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn set_styles(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(IStyleSettings) -> std::result::Result<(), JsValue>>,
            JsValue,
        >;
        fn set_get_game_info(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<GameInfo, JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn get_game_info(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<GameInfo, JsValue>>,
            JsValue,
        >;
        fn set_reset_styles(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue>;
        fn reset_styles(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, JsValue>;
        fn set_window_size(
            &mut self,
            value: std::rc::Rc<
                dyn Fn() -> std::result::Result<UserInterfaceWindowSizeReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue>;
        fn window_size(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<UserInterfaceWindowSizeReturn, JsValue>>,
            JsValue,
        >;
    }
    impl UserInterface_Trait for UserInterface {
        fn set_get_styles(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<IStyleSettings, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_styles = value;
            Ok(())
        }
        fn get_styles(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<IStyleSettings, JsValue>>,
            JsValue,
        > {
            Ok(self.get_styles.clone())
        }
        fn set_get_theme(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<UserInterfaceTheme, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_theme = value;
            Ok(())
        }
        fn get_theme(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<UserInterfaceTheme, JsValue>>,
            JsValue,
        > {
            Ok(self.get_theme.clone())
        }
        fn set_set_theme(
            &mut self,
            value: std::rc::Rc<dyn Fn(UserInterfaceTheme) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_theme = value;
            Ok(())
        }
        fn set_theme(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(UserInterfaceTheme) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.set_theme.clone())
        }
        fn set_clear_terminal(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.clear_terminal = value;
            Ok(())
        }
        fn clear_terminal(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, JsValue>
        {
            Ok(self.clear_terminal.clone())
        }
        fn set_reset_theme(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.reset_theme = value;
            Ok(())
        }
        fn reset_theme(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, JsValue>
        {
            Ok(self.reset_theme.clone())
        }
        fn set_set_styles(
            &mut self,
            value: std::rc::Rc<dyn Fn(IStyleSettings) -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.set_styles = value;
            Ok(())
        }
        fn set_styles(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(IStyleSettings) -> std::result::Result<(), JsValue>>,
            JsValue,
        > {
            Ok(self.set_styles.clone())
        }
        fn set_get_game_info(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<GameInfo, JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.get_game_info = value;
            Ok(())
        }
        fn get_game_info(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<GameInfo, JsValue>>,
            JsValue,
        > {
            Ok(self.get_game_info.clone())
        }
        fn set_reset_styles(
            &mut self,
            value: std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
        ) -> std::result::Result<(), JsValue> {
            self.reset_styles = value;
            Ok(())
        }
        fn reset_styles(
            &self,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, JsValue>
        {
            Ok(self.reset_styles.clone())
        }
        fn set_window_size(
            &mut self,
            value: std::rc::Rc<
                dyn Fn() -> std::result::Result<UserInterfaceWindowSizeReturn, JsValue>,
            >,
        ) -> std::result::Result<(), JsValue> {
            self.window_size = value;
            Ok(())
        }
        fn window_size(
            &self,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<UserInterfaceWindowSizeReturn, JsValue>>,
            JsValue,
        > {
            Ok(self.window_size.clone())
        }
    }
    impl UserInterface {
        #[allow(non_snake_case)]
        fn __TSB__serialize_clear_terminal<S>(
            clear_terminal: &std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let clear_terminal = clear_terminal.clone();
            let clear_terminal_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<(), JsValue> {
                    let result = clear_terminal()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &clear_terminal_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_window_size<S>(
            window_size: &std::rc::Rc<
                dyn Fn() -> std::result::Result<UserInterfaceWindowSizeReturn, JsValue>,
            >,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let window_size = window_size.clone();
            let window_size_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = window_size()?;
                    Ok({
                        let result_array = js_sys::Array::new();
                        let result_item_0 = result.0;
                        result_array.push(&JsValue::from(result_item_0));
                        let result_item_1 = result.1;
                        result_array.push(&JsValue::from(result_item_1));
                        result_array.into()
                    })
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &window_size_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_theme<S>(
            get_theme: &std::rc::Rc<dyn Fn() -> std::result::Result<UserInterfaceTheme, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_theme = get_theme.clone();
            let get_theme_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_theme()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &get_theme_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_styles<S>(
            set_styles: &std::rc::Rc<dyn Fn(IStyleSettings) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_styles = set_styles.clone();
            let set_styles_closure = Closure::wrap(Box::new(
                move |arg0: JsValue| -> std::result::Result<(), JsValue> {
                    let result = set_styles(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue) -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &set_styles_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_game_info<S>(
            get_game_info: &std::rc::Rc<dyn Fn() -> std::result::Result<GameInfo, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_game_info = get_game_info.clone();
            let get_game_info_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_game_info()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_game_info_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_get_styles<S>(
            get_styles: &std::rc::Rc<dyn Fn() -> std::result::Result<IStyleSettings, JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let get_styles = get_styles.clone();
            let get_styles_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<JsValue, JsValue> {
                    let result = get_styles()?;
                    Ok(ts_bindgen_rt::to_jsvalue(&result).map_err(ts_bindgen_rt::Error::from)?)
                })
                    as Box<dyn Fn() -> std::result::Result<JsValue, JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &get_styles_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_set_theme<S>(
            set_theme: &std::rc::Rc<dyn Fn(UserInterfaceTheme) -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let set_theme = set_theme.clone();
            let set_theme_closure = Closure::wrap(Box::new(
                move |arg0: JsValue| -> std::result::Result<(), JsValue> {
                    let result = set_theme(
                        ts_bindgen_rt::from_jsvalue(&arg0).map_err(ts_bindgen_rt::Error::from)?,
                    )?;
                    Ok(result)
                },
            )
                as Box<dyn Fn(JsValue) -> std::result::Result<(), JsValue>>);
            let jsv =
                ts_bindgen_rt::serialize_as_jsvalue(serializer, &set_theme_closure.into_js_value());
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_reset_styles<S>(
            reset_styles: &std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let reset_styles = reset_styles.clone();
            let reset_styles_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<(), JsValue> {
                    let result = reset_styles()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &reset_styles_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__serialize_reset_theme<S>(
            reset_theme: &std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>,
            serializer: S,
        ) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            let reset_theme = reset_theme.clone();
            let reset_theme_closure =
                Closure::wrap(Box::new(move || -> std::result::Result<(), JsValue> {
                    let result = reset_theme()?;
                    Ok(result)
                })
                    as Box<dyn Fn() -> std::result::Result<(), JsValue>>);
            let jsv = ts_bindgen_rt::serialize_as_jsvalue(
                serializer,
                &reset_theme_closure.into_js_value(),
            );
            jsv
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_clear_terminal<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let clear_terminal: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            clear_terminal
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_window_size<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<UserInterfaceWindowSizeReturn, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let window_size: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            window_size
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn() -> std::result::Result<UserInterfaceWindowSizeReturn, JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_theme<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<UserInterfaceTheme, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_theme: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_theme
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<UserInterfaceTheme, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_styles<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(IStyleSettings) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_styles: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_styles
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: IStyleSettings| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn(IStyleSettings) -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_game_info<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<GameInfo, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_game_info: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_game_info
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<GameInfo, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_get_styles<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn() -> std::result::Result<IStyleSettings, JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let get_styles: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            get_styles
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ts_bindgen_rt::from_jsvalue(&ret).unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<IStyleSettings, JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_set_theme<'de, D>(
            deserializer: D,
        ) -> std::result::Result<
            std::rc::Rc<dyn Fn(UserInterfaceTheme) -> std::result::Result<(), JsValue>>,
            D::Error,
        >
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let set_theme: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            set_theme
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move |arg0: UserInterfaceTheme| {
                        let arg0 = ts_bindgen_rt::to_jsvalue(&arg0);
                        let _Args = js_sys::Array::new();
                        _Args.push(&arg0);
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<
                            dyn Fn(UserInterfaceTheme) -> std::result::Result<(), JsValue>,
                        >
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_reset_styles<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let reset_styles: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            reset_styles
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
        #[allow(non_snake_case)]
        fn __TSB__deserialize_reset_theme<'de, D>(
            deserializer: D,
        ) -> std::result::Result<std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>, D::Error>
        where
            D: serde::de::Deserializer<'de>,
        {
            let jsv: JsValue = ts_bindgen_rt::deserialize_as_jsvalue(deserializer)?;
            let reset_theme: Option<&js_sys::Function> = wasm_bindgen::JsCast::dyn_ref(&jsv);
            reset_theme
                .map(|f| {
                    let f = f.clone();
                    std::rc::Rc::new(move || {
                        let _Args = js_sys::Array::new();
                        let ret = f.apply(&JsValue::null(), &_Args)?;
                        Ok(ret.into_serde().unwrap())
                    })
                        as std::rc::Rc<dyn Fn() -> std::result::Result<(), JsValue>>
                })
                .ok_or_else(|| {
                    ts_bindgen_rt::jsvalue_serde::Error::InvalidType(
                        "expected function".to_string(),
                    )
                })
                .map_err(serde::de::Error::custom)
        }
    }
}
